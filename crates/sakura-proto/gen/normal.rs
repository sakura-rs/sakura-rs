// This file is @generated by prost-build.
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketHead {
    #[prost(uint32, tag = "1")]
    pub packet_id: u32,
    #[prost(uint32, tag = "2")]
    pub rpc_id: u32,
    #[prost(uint32, tag = "3")]
    pub client_sequence_id: u32,
    #[prost(uint32, tag = "4")]
    pub enet_channel_id: u32,
    #[prost(uint32, tag = "5")]
    pub enet_is_reliable: u32,
    #[prost(uint64, tag = "6")]
    pub sent_ms: u64,
    #[prost(uint32, tag = "7")]
    pub user_id: u32,
    #[prost(uint32, tag = "8")]
    pub user_ip: u32,
    #[prost(uint32, tag = "9")]
    pub user_session_id: u32,
    #[prost(uint64, tag = "10")]
    pub recv_time_ms: u64,
    #[prost(uint32, tag = "11")]
    pub rpc_begin_time_ms: u32,
    #[prost(map = "uint32, uint32", tag = "12")]
    pub ext_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "13")]
    pub sender_app_id: u32,
    #[prost(uint32, tag = "14")]
    pub source_service: u32,
    #[prost(uint32, tag = "15")]
    pub target_service: u32,
    #[prost(map = "uint32, uint32", tag = "16")]
    pub service_app_id_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "17")]
    pub is_set_game_thread: bool,
    #[prost(uint32, tag = "18")]
    pub game_thread_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityInvokeEntryHead {
    #[prost(int32, tag = "1")]
    pub modifier_config_local_id: i32,
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
    #[prost(uint32, tag = "3")]
    pub instanced_modifier_id: u32,
    #[prost(uint32, tag = "4")]
    pub instanced_ability_id: u32,
    #[prost(bool, tag = "5")]
    pub is_serverbuff_modifier: bool,
    #[prost(uint32, tag = "6")]
    pub server_buff_uid: u32,
    #[prost(int32, tag = "7")]
    pub local_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityInvokeEntry {
    #[prost(message, optional, tag = "1")]
    pub head: ::core::option::Option<AbilityInvokeEntryHead>,
    #[prost(bytes = "vec", tag = "2")]
    pub ability_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub event_id: u32,
    #[prost(bool, tag = "4")]
    pub is_ignore_auth: bool,
    #[prost(uint32, tag = "5")]
    pub forward_peer: u32,
    #[prost(uint32, tag = "6")]
    pub entity_id: u32,
    #[prost(enumeration = "ForwardType", tag = "7")]
    pub forward_type: i32,
    #[prost(enumeration = "AbilityInvokeArgument", tag = "8")]
    pub argument_type: i32,
    #[prost(double, tag = "9")]
    pub total_tick_time: f64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityInvocationFixedNotify {
    #[prost(message, optional, tag = "1")]
    pub invoke1st: ::core::option::Option<AbilityInvokeEntry>,
    #[prost(message, optional, tag = "2")]
    pub invoke6th: ::core::option::Option<AbilityInvokeEntry>,
    #[prost(message, optional, tag = "3")]
    pub invoke2nd: ::core::option::Option<AbilityInvokeEntry>,
    #[prost(message, optional, tag = "4")]
    pub invoke3rd: ::core::option::Option<AbilityInvokeEntry>,
    #[prost(message, optional, tag = "5")]
    pub invoke4th: ::core::option::Option<AbilityInvokeEntry>,
    #[prost(message, optional, tag = "6")]
    pub invoke5th: ::core::option::Option<AbilityInvokeEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityInvocationsNotify {
    #[prost(message, repeated, tag = "1")]
    pub invokes: ::prost::alloc::vec::Vec<AbilityInvokeEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMetaReInitOverrideMap {
    #[prost(message, repeated, tag = "1")]
    pub override_map: ::prost::alloc::vec::Vec<AbilityScalarValueEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMetaAddAbility {
    #[prost(message, optional, tag = "1")]
    pub ability: ::core::option::Option<AbilityAppliedAbility>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifierProperty {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<AbilityString>,
    #[prost(float, tag = "2")]
    pub value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMetaModifierChange {
    #[prost(message, optional, tag = "1")]
    pub parent_ability_override: ::core::option::Option<AbilityString>,
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<ModifierProperty>,
    #[prost(message, optional, tag = "3")]
    pub parent_ability_name: ::core::option::Option<AbilityString>,
    #[prost(message, optional, tag = "4")]
    pub attached_instanced_modifier: ::core::option::Option<AbilityAttachedModifier>,
    #[prost(enumeration = "ModifierAction", tag = "5")]
    pub action: i32,
    #[prost(int32, tag = "6")]
    pub modifier_local_id: i32,
    #[prost(uint32, tag = "7")]
    pub apply_entity_id: u32,
    #[prost(bool, tag = "8")]
    pub is_mute_remote: bool,
    #[prost(bool, tag = "9")]
    pub is_attached_parent_ability: bool,
    #[prost(bool, tag = "10")]
    pub is_durability_zero: bool,
    #[prost(uint32, tag = "11")]
    pub server_buff_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaDurabilityIsZero {
    #[prost(bool, tag = "1")]
    pub is_zero: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaSetKilledState {
    #[prost(bool, tag = "1")]
    pub killed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaSetModifierApplyEntityId {
    #[prost(uint32, tag = "1")]
    pub apply_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaModifierDurabilityChange {
    #[prost(float, tag = "1")]
    pub remain_durability: f32,
    #[prost(float, tag = "2")]
    pub reduce_durability: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaTriggerElementReaction {
    #[prost(uint32, tag = "1")]
    pub trigger_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub element_source_type: u32,
    #[prost(uint32, tag = "3")]
    pub element_reaction_type: u32,
    #[prost(int32, tag = "4")]
    pub hit_index: i32,
    #[prost(uint32, tag = "5")]
    pub element_reactor_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaLoseHp {
    #[prost(uint32, tag = "1")]
    pub lose_hp_config_idx: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMetaSetPoseParameter {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<AnimatorParameterValueInfoPair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMetaUpdateBaseReactionDamage {
    #[prost(message, optional, tag = "1")]
    pub global_value_key: ::core::option::Option<AbilityString>,
    #[prost(message, optional, tag = "2")]
    pub ability_name: ::core::option::Option<AbilityString>,
    #[prost(uint32, tag = "3")]
    pub source_caster_id: u32,
    #[prost(uint32, tag = "4")]
    pub reaction_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionTriggerAbility {
    #[prost(uint32, tag = "1")]
    pub other_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionSetCrashDamage {
    #[prost(message, optional, tag = "1")]
    pub hit_pos: ::core::option::Option<Vector>,
    #[prost(float, tag = "2")]
    pub damage: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityBornType {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub move_dir: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub rot: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityFireworkBornType {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub move_dir: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub effect_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionSummon {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionBlink {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionCreateGadget {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionSetRandomOverrideMapValue {
    #[prost(float, tag = "1")]
    pub random_value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityActionServerMonsterLog {
    #[prost(int32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<i32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionCreateTile {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionDestroyTile {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionFireAfterImage {
    #[prost(message, optional, tag = "1")]
    pub dir: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityApplyLevelModifier {
    #[prost(uint32, tag = "1")]
    pub apply_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionGenerateElemBall {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionDeductStamina {
    #[prost(bool, tag = "1")]
    pub is_swim: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionHitEffect {
    #[prost(uint32, tag = "1")]
    pub trigger_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityActionSetBulletTrackTarget {
    #[prost(uint32, tag = "1")]
    pub lock_point_index: u32,
    #[prost(uint32, tag = "2")]
    pub chased_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinAvatarSteerByCamera {
    #[prost(message, optional, tag = "1")]
    pub target_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub target_dir: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinWindZone {
    #[prost(uint32, repeated, tag = "1")]
    pub entity_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub zone_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinCostStamina {
    #[prost(bool, tag = "1")]
    pub is_swim: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinEliteShield {
    #[prost(float, tag = "1")]
    pub sub_shield: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinElementShield {
    #[prost(uint32, tag = "1")]
    pub absorb_type: u32,
    #[prost(float, tag = "2")]
    pub max_shield: f32,
    #[prost(float, tag = "3")]
    pub shield: f32,
    #[prost(float, tag = "4")]
    pub sub_shield: f32,
    #[prost(bool, tag = "5")]
    pub is_shield_broken: bool,
    #[prost(uint32, tag = "6")]
    pub player_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinGlobalShield {
    #[prost(string, tag = "1")]
    pub shield_effect_name: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub sub_shield: f32,
    #[prost(uint32, tag = "3")]
    pub avatar_id: u32,
    #[prost(bool, tag = "4")]
    pub is_create_effect: bool,
    #[prost(float, tag = "5")]
    pub height_offset: f32,
    #[prost(float, tag = "6")]
    pub max_shield: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinShieldBar {
    #[prost(uint32, tag = "1")]
    pub element_type: u32,
    #[prost(uint32, tag = "2")]
    pub player_num: u32,
    #[prost(float, tag = "3")]
    pub shield: f32,
    #[prost(float, tag = "4")]
    pub max_shield: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinWindSeedSpawner {
    #[prost(oneof = "ability_mixin_wind_seed_spawner::Cmd", tags = "1, 2, 3")]
    pub cmd: ::core::option::Option<ability_mixin_wind_seed_spawner::Cmd>,
}
/// Nested message and enum types in `AbilityMixinWindSeedSpawner`.
pub mod ability_mixin_wind_seed_spawner {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Cmd {
        #[prost(message, tag = "1")]
        AddSignal(super::AddSignal),
        #[prost(message, tag = "2")]
        RefreshSeed(super::RefreshSeed),
        #[prost(message, tag = "3")]
        CatchSeed(super::CatchSeed),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddSignal {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshSeed {
    #[prost(message, repeated, tag = "1")]
    pub pos_list: ::prost::alloc::vec::Vec<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CatchSeed {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinDoActionByElementReaction {
    #[prost(uint32, tag = "1")]
    pub target_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinFieldEntityCountChange {
    #[prost(uint32, tag = "1")]
    pub field_entity_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinScenePropSync {
    #[prost(int64, repeated, tag = "1")]
    pub delete_id_list: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "2")]
    pub massive_prop_list: ::prost::alloc::vec::Vec<MassivePropSyncInfo>,
    #[prost(bool, tag = "3")]
    pub is_clear_all: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinWidgetMpSupport {
    #[prost(uint32, tag = "1")]
    pub target_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinDoActionBySelfModifierElementDurabilityRatio {
    #[prost(float, tag = "1")]
    pub last_durability_ratio: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinFireworksLauncher {
    #[prost(uint32, repeated, tag = "1")]
    pub fireworks_config: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub phase: u32,
    #[prost(uint32, tag = "3")]
    pub fired_bullet_count: u32,
    #[prost(uint32, tag = "4")]
    pub invoke_type: u32,
    #[prost(uint32, tag = "5")]
    pub start_count_down_time: u32,
    #[prost(uint32, tag = "6")]
    pub turn_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinUgcTimeControl {
    #[prost(uint64, tag = "1")]
    pub start_move_time_ms: u64,
    #[prost(uint32, tag = "2")]
    pub start_move_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinUiInteract {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinAvatarCombat {
    #[prost(bool, tag = "1")]
    pub is_enter_combat: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinShootFromCamera {
    #[prost(message, optional, tag = "1")]
    pub init_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub forward: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinEraseBrickActivity {
    #[prost(uint32, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BreakoutSyncCreateConnect {
    #[prost(message, repeated, tag = "1")]
    pub uid_info_list: ::prost::alloc::vec::Vec<BreakoutSyncConnectUidInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutSyncPing {
    #[prost(uint64, tag = "1")]
    pub client_game_time: u64,
    #[prost(uint64, tag = "2")]
    pub server_game_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutSyncFinishGame {
    #[prost(uint64, tag = "1")]
    pub server_game_time: u64,
    #[prost(bool, tag = "2")]
    pub is_win: bool,
    #[prost(bool, tag = "3")]
    pub is_stop_gallery: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BreakoutSyncSnapShot {
    #[prost(message, optional, tag = "1")]
    pub snap_shot: ::core::option::Option<BreakoutSnapShot>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutSyncAction {
    #[prost(message, optional, tag = "1")]
    pub action: ::core::option::Option<BreakoutAction>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinBreakout {
    #[prost(enumeration = "SyncType", tag = "1")]
    pub sync_type: i32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(oneof = "ability_mixin_breakout::Sync", tags = "3, 4, 5, 6, 7")]
    pub sync: ::core::option::Option<ability_mixin_breakout::Sync>,
}
/// Nested message and enum types in `AbilityMixinBreakout`.
pub mod ability_mixin_breakout {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Sync {
        #[prost(message, tag = "3")]
        SyncCreateConnect(super::BreakoutSyncCreateConnect),
        #[prost(message, tag = "4")]
        SyncPing(super::BreakoutSyncPing),
        #[prost(message, tag = "5")]
        SyncFinishGame(super::BreakoutSyncFinishGame),
        #[prost(message, tag = "6")]
        SyncSnapShot(super::BreakoutSyncSnapShot),
        #[prost(message, tag = "7")]
        SyncAction(super::BreakoutSyncAction),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinDamageLoanSync {
    #[prost(uint32, tag = "1")]
    pub create_count: u32,
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
    #[prost(float, tag = "3")]
    pub damage_loan: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttackResultCreateCount {
    #[prost(uint32, repeated, tag = "1")]
    pub create_count_no_cost_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub create_count_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinBroadcastGv {
    #[prost(float, tag = "1")]
    pub gv_value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinReceiveGv {
    #[prost(float, tag = "1")]
    pub gv_value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityMixinEnergyCrystalTarget {
    #[prost(bool, tag = "1")]
    pub is_dis_crystal: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientAbilityInitBeginNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1104)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientAbilityInitFinishNotify {
    #[prost(message, repeated, tag = "1")]
    pub invokes: ::prost::alloc::vec::Vec<AbilityInvokeEntry>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1105)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityInvocationFailNotify {
    #[prost(message, optional, tag = "1")]
    pub invoke: ::core::option::Option<AbilityInvokeEntry>,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityAbilityInvokeEntry {
    #[prost(message, repeated, tag = "1")]
    pub invokes: ::prost::alloc::vec::Vec<AbilityInvokeEntry>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1106)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientAbilitiesInitFinishCombineNotify {
    #[prost(message, repeated, tag = "1")]
    pub entity_invoke_list: ::prost::alloc::vec::Vec<EntityAbilityInvokeEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1107)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindSeedClientNotify {
    #[prost(oneof = "wind_seed_client_notify::Notify", tags = "1, 2, 3")]
    pub notify: ::core::option::Option<wind_seed_client_notify::Notify>,
}
/// Nested message and enum types in `WindSeedClientNotify`.
pub mod wind_seed_client_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Notify {
        #[prost(message, tag = "1")]
        RefreshNotify(super::RefreshNotify),
        #[prost(message, tag = "2")]
        AddWindBulletNotify(super::AddWindBulletNotify),
        #[prost(message, tag = "3")]
        AreaNotify(super::AreaNotify),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RefreshNotify {
    #[prost(uint32, tag = "1")]
    pub refresh_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddWindBulletNotify {
    #[prost(message, optional, tag = "1")]
    pub seed_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub catch_player_uid: u32,
    #[prost(uint32, tag = "3")]
    pub seed_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AreaNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub area_code: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub area_type: u32,
    #[prost(uint32, tag = "3")]
    pub area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1108)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub ability_control_block: ::core::option::Option<AbilityControlBlock>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1109)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientAbilityChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub invokes: ::prost::alloc::vec::Vec<AbilityInvokeEntry>,
    #[prost(bool, tag = "2")]
    pub is_init_hash: bool,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1110)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerUpdateGlobalValueNotify {
    #[prost(uint32, tag = "1")]
    pub key_hash: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(enumeration = "UpdateType", tag = "3")]
    pub update_type: i32,
    #[prost(float, tag = "4")]
    pub delta: f32,
    #[prost(float, tag = "5")]
    pub value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerGlobalValueChangeNotify {
    #[prost(uint32, tag = "1")]
    pub key_hash: u32,
    #[prost(float, tag = "2")]
    pub value: f32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1112)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientAiStateNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub cur_tactic: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1113)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerCombatEndNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub combat_end_type_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1114)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientRemoveCombatEndModifierNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub combat_end_type_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1115)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformOperationNotify {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub index: u32,
    #[prost(enumeration = "OperateType", tag = "5")]
    pub operate_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Achievement {
    #[prost(enumeration = "AchievementStatus", tag = "1")]
    pub status: i32,
    #[prost(uint32, tag = "2")]
    pub cur_progress: u32,
    #[prost(uint32, tag = "3")]
    pub total_progress: u32,
    #[prost(uint32, tag = "4")]
    pub id: u32,
    #[prost(uint32, tag = "5")]
    pub finish_timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2601)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AchievementAllDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub reward_taken_goal_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub achievement_list: ::prost::alloc::vec::Vec<Achievement>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2602)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AchievementUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub achievement_list: ::prost::alloc::vec::Vec<Achievement>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2603)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeAchievementRewardReq {
    #[prost(uint32, repeated, tag = "1")]
    pub id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2604)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeAchievementRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, repeated, tag = "2")]
    pub id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2605)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeAchievementGoalRewardReq {
    #[prost(uint32, repeated, tag = "1")]
    pub id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2606)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeAchievementGoalRewardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetActivityScheduleReq {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityScheduleInfo {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(uint32, tag = "4")]
    pub begin_time: u32,
    #[prost(uint32, tag = "5")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActivityScheduleRsp {
    #[prost(message, repeated, tag = "1")]
    pub activity_schedule_list: ::prost::alloc::vec::Vec<ActivityScheduleInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub remain_fly_sea_lamp_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActivityInfoReq {
    #[prost(uint32, repeated, tag = "1")]
    pub activity_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub expire_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub meet_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub activity_coin_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub wish_gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub taken_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "6")]
    pub quick_open_pre_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "7")]
    pub watcher_info_list: ::prost::alloc::vec::Vec<ActivityWatcherInfo>,
    #[prost(message, repeated, tag = "8")]
    pub activity_push_tips_data_list: ::prost::alloc::vec::Vec<ActivityPushTipsData>,
    #[prost(uint32, tag = "9")]
    pub selected_avatar_reward_id: u32,
    #[prost(uint32, tag = "10")]
    pub activity_type: u32,
    #[prost(uint32, tag = "11")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "12")]
    pub cur_score: u32,
    #[prost(bool, tag = "13")]
    pub is_common_content_closed: bool,
    #[prost(bool, tag = "14")]
    pub is_quick_open: bool,
    #[prost(bool, tag = "15")]
    pub is_play_open_anim: bool,
    #[prost(uint32, tag = "16")]
    pub score_limit: u32,
    #[prost(uint32, tag = "17")]
    pub first_day_start_time: u32,
    #[prost(uint32, tag = "18")]
    pub end_time: u32,
    #[prost(uint32, tag = "19")]
    pub begin_time: u32,
    #[prost(uint32, tag = "20")]
    pub activity_id: u32,
    #[prost(bool, tag = "21")]
    pub is_finished: bool,
    #[prost(bool, tag = "22")]
    pub is_starting: bool,
    #[prost(bool, tag = "23")]
    pub is_hidden: bool,
    #[prost(bool, tag = "24")]
    pub is_banner_cleared: bool,
    #[prost(
        oneof = "activity_info::Detail",
        tags = "25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101"
    )]
    pub detail: ::core::option::Option<activity_info::Detail>,
}
/// Nested message and enum types in `ActivityInfo`.
pub mod activity_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "25")]
        SamLampInfo(super::SeaLampActivityDetailInfo),
        #[prost(message, tag = "26")]
        CrucibleInfo(super::CrucibleActivityDetailInfo),
        #[prost(message, tag = "27")]
        SalesmanInfo(super::SalesmanActivityDetailInfo),
        #[prost(message, tag = "28")]
        TrialAvatarInfo(super::TrialAvatarActivityDetailInfo),
        #[prost(message, tag = "29")]
        DeliveryInfo(super::DeliveryActivityDetailInfo),
        #[prost(message, tag = "30")]
        AsterInfo(super::AsterActivityDetailInfo),
        #[prost(message, tag = "31")]
        FlightInfo(super::FlightActivityDetailInfo),
        #[prost(message, tag = "32")]
        DragonSpineInfo(super::DragonSpineActivityDetailInfo),
        #[prost(message, tag = "33")]
        EffigyInfo(super::EffigyActivityDetailInfo),
        #[prost(message, tag = "34")]
        TreasureMapInfo(super::TreasureMapActivityDetailInfo),
        #[prost(message, tag = "35")]
        BlessingInfo(super::BlessingActivityDetailInfo),
        #[prost(message, tag = "36")]
        SeaLampInfo(super::SeaLampActivityInfo),
        #[prost(message, tag = "37")]
        ExpeditionInfo(super::ExpeditionActivityDetailInfo),
        #[prost(message, tag = "38")]
        ArenaChallengeInfo(super::ArenaChallengeActivityDetailInfo),
        #[prost(message, tag = "39")]
        FleurFairInfo(super::FleurFairActivityDetailInfo),
        #[prost(message, tag = "40")]
        WaterSpiritInfo(super::WaterSpiritActivityDetailInfo),
        #[prost(message, tag = "41")]
        ChannelerSlabInfo(super::ChannelerSlabActivityDetailInfo),
        #[prost(message, tag = "42")]
        MistTrialActivityInfo(super::MistTrialActivityDetailInfo),
        #[prost(message, tag = "43")]
        HideAndSeekInfo(super::HideAndSeekActivityDetailInfo),
        #[prost(message, tag = "44")]
        FindHilichurlInfo(super::FindHilichurlDetailInfo),
        #[prost(message, tag = "45")]
        SummerTimeInfo(super::SummerTimeDetailInfo),
        #[prost(message, tag = "46")]
        BuoyantCombatInfo(super::BuoyantCombatDetailInfo),
        #[prost(message, tag = "47")]
        EchoShellInfo(super::EchoShellDetailInfo),
        #[prost(message, tag = "48")]
        BounceConjuringInfo(super::BounceConjuringActivityDetailInfo),
        #[prost(message, tag = "49")]
        BlitzRushInfo(super::BlitzRushActivityDetailInfo),
        #[prost(message, tag = "50")]
        ChessInfo(super::ChessActivityDetailInfo),
        #[prost(message, tag = "51")]
        SumoInfo(super::SumoActivityDetailInfo),
        #[prost(message, tag = "52")]
        MoonfinTrialInfo(super::MoonfinTrialActivityDetailInfo),
        #[prost(message, tag = "53")]
        LunaRiteInfo(super::LunaRiteDetailInfo),
        #[prost(message, tag = "54")]
        PlantFlowerInfo(super::PlantFlowerActivityDetailInfo),
        #[prost(message, tag = "55")]
        MusicGameInfo(super::MusicGameActivityDetailInfo),
        #[prost(message, tag = "56")]
        RoguelikeDungeonInfo(super::RoguelikeDungeonActivityDetailInfo),
        #[prost(message, tag = "57")]
        DigInfo(super::DigActivityDetailInfo),
        #[prost(message, tag = "58")]
        HachiInfo(super::HachiActivityDetailInfo),
        #[prost(message, tag = "59")]
        WinterCampInfo(super::WinterCampActivityDetailInfo),
        #[prost(message, tag = "60")]
        PotionInfo(super::PotionActivityDetailInfo),
        #[prost(message, tag = "61")]
        TanukiTravelActivityInfo(super::TanukiTravelActivityDetailInfo),
        #[prost(message, tag = "62")]
        LanternRiteActivityInfo(super::LanternRiteActivityDetailInfo),
        #[prost(message, tag = "63")]
        MichiaeMatsuriInfo(super::MichiaeMatsuriActivityDetailInfo),
        #[prost(message, tag = "64")]
        BartenderInfo(super::BartenderActivityDetailInfo),
        #[prost(message, tag = "65")]
        UgcInfo(super::UgcActivityDetailInfo),
        #[prost(message, tag = "66")]
        CrystalLinkInfo(super::CrystalLinkActivityDetailInfo),
        #[prost(message, tag = "67")]
        IrodoriInfo(super::IrodoriActivityDetailInfo),
        #[prost(message, tag = "68")]
        PhotoInfo(super::PhotoActivityDetailInfo),
        #[prost(message, tag = "69")]
        SpiceInfo(super::SpiceActivityDetailInfo),
        #[prost(message, tag = "70")]
        GachaInfo(super::GachaActivityDetailInfo),
        #[prost(message, tag = "71")]
        LuminanceStoneChallengeInfo(super::LuminanceStoneChallengeActivityDetailInfo),
        #[prost(message, tag = "72")]
        RogueDiaryInfo(super::RogueDiaryActivityDetailInfo),
        #[prost(message, tag = "73")]
        SummerTimeV2Info(super::SummerTimeV2DetailInfo),
        #[prost(message, tag = "74")]
        IslandPartyInfo(super::IslandPartyDetailInfo),
        #[prost(message, tag = "75")]
        GearInfo(super::GearActivityDetailInfo),
        #[prost(message, tag = "76")]
        GravenInnocenceInfo(super::GravenInnocenceDetailInfo),
        #[prost(message, tag = "77")]
        InstableSprayInfo(super::InstableSprayDetailInfo),
        #[prost(message, tag = "78")]
        MuqadasPotionInfo(super::MuqadasPotionActivityDetailInfo),
        #[prost(message, tag = "79")]
        TreasureSeelieInfo(super::TreasureSeelieActivityDetailInfo),
        #[prost(message, tag = "80")]
        RockBoardExploreInfo(super::RockBoardExploreDetailInfo),
        #[prost(message, tag = "81")]
        VintageInfo(super::VintageActivityDetailInfo),
        #[prost(message, tag = "82")]
        WindFieldInfo(super::WindFieldDetailInfo),
        #[prost(message, tag = "83")]
        FungusFighterInfo(super::FungusFighterDetailInfo),
        #[prost(message, tag = "84")]
        CharAmusementInfo(super::CharAmusementDetailInfo),
        #[prost(message, tag = "85")]
        EffigyChallengeInfo(super::EffigyChallengeV2DetailInfo),
        #[prost(message, tag = "86")]
        CoinCollectInfo(super::CoinCollectDetailInfo),
        #[prost(message, tag = "87")]
        BrickBreakerInfo(super::BrickBreakerDetailInfo),
        #[prost(message, tag = "88")]
        DuelHeartInfo(super::DuelHeartDetailInfo),
        #[prost(message, tag = "89")]
        SeaLampV3Info(super::SeaLampV3DetailInfo),
        #[prost(message, tag = "90")]
        TeamChainInfo(super::TeamChainDetailInfo),
        #[prost(message, tag = "91")]
        ElectroherculesBattleInfo(super::ElectroherculesBattleDetailInfo),
        #[prost(message, tag = "92")]
        GcgFestivalInfo(super::GcgFestivalDetailInfo),
        #[prost(message, tag = "93")]
        FleurFairV2Info(super::FleurFairV2DetailInfo),
        #[prost(message, tag = "94")]
        FungusFighterV2Info(super::FungusFighterV2DetailInfo),
        #[prost(message, tag = "95")]
        AkaFesInfo(super::AkaFesDetailInfo),
        #[prost(message, tag = "96")]
        SandwormCannonDetailInfo(super::SandwormCannonDetailInfo),
        #[prost(message, tag = "97")]
        SorushTrialInfo(super::SorushTrialDetailInfo),
        #[prost(message, tag = "98")]
        JourneyInfo(super::JourneyDetailInfo),
        #[prost(message, tag = "99")]
        EffigyChallengeV4Info(super::EffigyChallengeV4DetailInfo),
        #[prost(message, tag = "100")]
        GcgPveInfo(super::GcgpveDetailInfo),
        #[prost(message, tag = "101")]
        UgcV2Info(super::UgcV2DetailInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2103)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActivityInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub disable_transfer_point_interaction_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(message, repeated, tag = "2")]
    pub activity_info_list: ::prost::alloc::vec::Vec<ActivityInfo>,
    #[prost(uint32, repeated, tag = "3")]
    pub activated_sale_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityPlayOpenAnimNotify {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2002)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub activity_info: ::core::option::Option<ActivityInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2105)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityScheduleInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub activity_schedule_list: ::prost::alloc::vec::Vec<ActivityScheduleInfo>,
    #[prost(uint32, tag = "2")]
    pub remain_fly_sea_lamp_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityWatcherInfo {
    #[prost(uint32, tag = "1")]
    pub total_progress: u32,
    #[prost(bool, tag = "2")]
    pub is_taken_reward: bool,
    #[prost(uint32, tag = "3")]
    pub cur_progress: u32,
    #[prost(uint32, tag = "4")]
    pub watcher_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityTakeWatcherRewardReq {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub watcher_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2106)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityTakeWatcherRewardRsp {
    #[prost(uint32, tag = "1")]
    pub watcher_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2004)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityUpdateWatcherNotify {
    #[prost(message, optional, tag = "1")]
    pub watcher_info: ::core::option::Option<ActivityWatcherInfo>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2005)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivitySelectAvatarCardReq {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2006)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivitySelectAvatarCardRsp {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2007)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityCoinInfoNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub activity_coin_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampActivityDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub taken_phase_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub taken_contribution_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub contribution: u32,
    #[prost(uint32, tag = "4")]
    pub phase_id: u32,
    #[prost(uint32, tag = "5")]
    pub progress: u32,
    #[prost(uint32, tag = "6")]
    pub days: u32,
    #[prost(uint32, tag = "7")]
    pub factor: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2107)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampFlyLampReq {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
    #[prost(uint32, tag = "3")]
    pub item_num: u32,
    #[prost(int32, tag = "4")]
    pub param: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2108)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampFlyLampRsp {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(uint32, tag = "2")]
    pub item_num: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2109)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampTakeContributionRewardReq {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2008)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampTakeContributionRewardRsp {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2009)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampTakePhaseRewardReq {
    #[prost(uint32, tag = "1")]
    pub phase_id: u32,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2010)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampTakePhaseRewardRsp {
    #[prost(uint32, tag = "1")]
    pub phase_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2011)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampContributeItemReq {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2110)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampContributeItemRsp {
    #[prost(uint32, tag = "1")]
    pub total_contribution: u32,
    #[prost(uint32, tag = "2")]
    pub add_contribution: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub add_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampSectionInfo {
    #[prost(uint32, tag = "1")]
    pub section_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampActivityInfo {
    #[prost(message, repeated, tag = "1")]
    pub section_info_list: ::prost::alloc::vec::Vec<SeaLampSectionInfo>,
    #[prost(uint32, tag = "2")]
    pub mechanicus_id: u32,
    #[prost(uint32, tag = "3")]
    pub sea_lamp_coin: u32,
    #[prost(uint32, tag = "4")]
    pub first_day_start_time: u32,
    #[prost(bool, tag = "5")]
    pub is_mechanicus_feature_close: bool,
    #[prost(bool, tag = "6")]
    pub is_content_closed: bool,
    #[prost(bool, tag = "7")]
    pub is_mechanicus_open: bool,
    #[prost(uint32, tag = "8")]
    pub popularity: u32,
    #[prost(uint32, tag = "9")]
    pub day_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2012)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampFlyLampNotify {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
    #[prost(int32, tag = "3")]
    pub param: i32,
    #[prost(uint32, tag = "4")]
    pub item_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampCoinNotify {
    #[prost(uint32, tag = "1")]
    pub sea_lamp_coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2112)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampPopularityNotify {
    #[prost(uint32, tag = "1")]
    pub popularity: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnounceData {
    #[prost(string, tag = "1")]
    pub count_down_text: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub center_system_text: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dungeon_confirm_text: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub begin_time: u32,
    #[prost(bool, tag = "5")]
    pub is_center_system_last_5_every_minutes: bool,
    #[prost(uint32, tag = "6")]
    pub center_system_frequency: u32,
    #[prost(uint32, tag = "7")]
    pub count_down_frequency: u32,
    #[prost(uint32, tag = "8")]
    pub config_id: u32,
    #[prost(uint32, tag = "9")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2013)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LoadActivityTerrainNotify {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2014)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerAnnounceNotify {
    #[prost(message, repeated, tag = "1")]
    pub announce_data_list: ::prost::alloc::vec::Vec<AnnounceData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2113)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerAnnounceRevokeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub config_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2015)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityBannerNotify {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2016)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityBannerClearReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2017)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityBannerClearRsp {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SalesmanActivityDetailInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub selected_reward_id_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "2")]
    pub is_has_taken_special_reward: bool,
    #[prost(bool, tag = "3")]
    pub is_today_has_delivered: bool,
    #[prost(uint32, tag = "4")]
    pub special_reward_preview_id: u32,
    #[prost(uint32, tag = "5")]
    pub day_index: u32,
    #[prost(uint32, tag = "6")]
    pub last_deliver_time: u32,
    #[prost(uint32, tag = "7")]
    pub cond_day_count: u32,
    #[prost(uint32, tag = "8")]
    pub day_reward_id: u32,
    #[prost(uint32, tag = "9")]
    pub deliver_count: u32,
    #[prost(enumeration = "SalesmanStatusType", tag = "10")]
    pub status: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2114)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalesmanDeliverItemReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2115)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalesmanDeliverItemRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2018)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalesmanTakeRewardReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub position: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2116)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalesmanTakeRewardRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub position: u32,
    #[prost(uint32, tag = "4")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2117)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityCondStateChangeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub meet_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub disable_transfer_point_interaction_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, repeated, tag = "3")]
    pub activated_sale_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub expire_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub activity_id: u32,
    #[prost(uint32, tag = "6")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2118)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalesmanTakeSpecialRewardReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2119)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalesmanTakeSpecialRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2120)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAuthSalesmanInfoReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2121)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAuthSalesmanInfoRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub day_reward_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrialAvatarActivityRewardDetailInfo {
    #[prost(uint32, tag = "1")]
    pub trial_avatar_index_id: u32,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
    #[prost(bool, tag = "3")]
    pub passed_dungeon: bool,
    #[prost(bool, tag = "4")]
    pub received_reward: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialAvatarActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub reward_info_list: ::prost::alloc::vec::Vec<TrialAvatarActivityRewardDetailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2122)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterTrialAvatarActivityDungeonReq {
    #[prost(uint32, tag = "1")]
    pub trial_avatar_index_id: u32,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(uint32, tag = "3")]
    pub enter_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2123)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterTrialAvatarActivityDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(uint32, tag = "3")]
    pub trial_avatar_index_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2019)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceivedTrialAvatarActivityRewardReq {
    #[prost(uint32, tag = "1")]
    pub trial_avatar_index_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2124)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceivedTrialAvatarActivityRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub trial_avatar_index_id: u32,
    #[prost(uint32, tag = "3")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2020)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrialAvatarFirstPassDungeonNotify {
    #[prost(uint32, tag = "1")]
    pub trial_avatar_index_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2125)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrialAvatarInDungeonIndexNotify {
    #[prost(uint32, tag = "1")]
    pub trial_avatar_index_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrucibleBattleUidInfo {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
    #[prost(uint32, tag = "5")]
    pub icon: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrucibleActivityDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, repeated, tag = "2")]
    pub uid_info_list: ::prost::alloc::vec::Vec<CrucibleBattleUidInfo>,
    #[prost(uint32, tag = "3")]
    pub cost_time: u32,
    #[prost(uint32, tag = "4")]
    pub battle_world_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryActivityDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_delivery_quest_index: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_taken_reward: bool,
    #[prost(uint32, tag = "3")]
    pub day_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2021)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeDeliveryDailyRewardReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2126)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeDeliveryDailyRewardRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2022)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinishDeliveryNotify {
    #[prost(uint32, tag = "1")]
    pub day_index: u32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub finished_quest_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterLittleDetailInfo {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub stage_begin_time: u32,
    #[prost(enumeration = "AsterLittleStageState", tag = "4")]
    pub stage_state: i32,
    #[prost(uint32, tag = "5")]
    pub begin_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterMidCampInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub camp_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsterMidDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub camp_list: ::prost::alloc::vec::Vec<AsterMidCampInfo>,
    #[prost(uint32, tag = "2")]
    pub collect_count: u32,
    #[prost(uint32, tag = "3")]
    pub begin_time: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterLargeDetailInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub begin_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterProgressDetailInfo {
    #[prost(uint32, tag = "1")]
    pub last_auto_add_time: u32,
    #[prost(uint32, tag = "2")]
    pub count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsterActivityDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub aster_little: ::core::option::Option<AsterLittleDetailInfo>,
    #[prost(message, optional, tag = "2")]
    pub aster_mid: ::core::option::Option<AsterMidDetailInfo>,
    #[prost(message, optional, tag = "3")]
    pub aster_large: ::core::option::Option<AsterLargeDetailInfo>,
    #[prost(message, optional, tag = "4")]
    pub aster_progress: ::core::option::Option<AsterProgressDetailInfo>,
    #[prost(uint32, tag = "5")]
    pub content_close_time: u32,
    #[prost(bool, tag = "6")]
    pub is_special_reward_taken: bool,
    #[prost(bool, tag = "7")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "8")]
    pub aster_token: u32,
    #[prost(uint32, tag = "9")]
    pub aster_credit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2023)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectAsterMidDifficultyReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2024)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectAsterMidDifficultyRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2025)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterProgressInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<AsterProgressDetailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2127)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterLittleInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<AsterLittleDetailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2128)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsterMidInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<AsterMidDetailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2129)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterMiscInfoNotify {
    #[prost(uint32, tag = "1")]
    pub aster_credit: u32,
    #[prost(uint32, tag = "2")]
    pub aster_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2026)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeAsterSpecialRewardReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2027)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeAsterSpecialRewardRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2028)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsterLargeInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<AsterLargeDetailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightDailyRecord {
    #[prost(uint32, repeated, tag = "1")]
    pub watcher_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_touched: bool,
    #[prost(uint32, tag = "3")]
    pub best_score: u32,
    #[prost(uint32, tag = "4")]
    pub start_time: u32,
    #[prost(uint32, tag = "5")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub daily_record_list: ::prost::alloc::vec::Vec<FlightDailyRecord>,
    #[prost(uint32, tag = "2")]
    pub preview_reward_id: u32,
    #[prost(uint32, tag = "3")]
    pub min_open_player_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2029)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlightActivitySettleNotify {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(uint32, tag = "5")]
    pub medal_level: u32,
    #[prost(uint32, tag = "6")]
    pub left_time: u32,
    #[prost(uint32, tag = "7")]
    pub total_num: u32,
    #[prost(uint32, tag = "8")]
    pub collect_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2130)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlightActivityRestartReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2131)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlightActivityRestartRsp {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2132)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsterMidCampInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub camp_list: ::prost::alloc::vec::Vec<AsterMidCampInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DragonSpineActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub chapter_info_list: ::prost::alloc::vec::Vec<DragonSpineChapterInfo>,
    #[prost(bool, tag = "2")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "3")]
    pub warm_essence: u32,
    #[prost(uint32, tag = "4")]
    pub wondrous_essence: u32,
    #[prost(uint32, tag = "5")]
    pub weapon_enhance_level: u32,
    #[prost(uint32, tag = "6")]
    pub shimmering_essence: u32,
    #[prost(uint32, tag = "7")]
    pub content_finish_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DragonSpineChapterInfo {
    #[prost(uint32, tag = "1")]
    pub finished_mission_num: u32,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(uint32, tag = "3")]
    pub progress: u32,
    #[prost(uint32, tag = "4")]
    pub chapter_id: u32,
    #[prost(bool, tag = "5")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2030)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DragonSpineChapterOpenNotify {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2133)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DragonSpineChapterProgressChangeNotify {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub cur_progress: u32,
    #[prost(uint32, tag = "3")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2031)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DragonSpineChapterFinishNotify {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
    #[prost(uint32, tag = "2")]
    pub weapon_enhance_level: u32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2134)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DragonSpineCoinChangeNotify {
    #[prost(uint32, tag = "1")]
    pub shimmering_essence: u32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub wondrous_essence: u32,
    #[prost(uint32, tag = "4")]
    pub warm_essence: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2032)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivitySaleChangeNotify {
    #[prost(bool, tag = "1")]
    pub is_close: bool,
    #[prost(uint32, tag = "2")]
    pub sale_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyDailyInfo {
    #[prost(uint32, tag = "1")]
    pub challenge_total_score: u32,
    #[prost(bool, tag = "2")]
    pub is_first_pass_reward_taken: bool,
    #[prost(uint32, tag = "3")]
    pub day_index: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_max_score: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "6")]
    pub begin_time: u32,
    #[prost(uint32, tag = "7")]
    pub challenge_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub daily_info_list: ::prost::alloc::vec::Vec<EffigyDailyInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub taken_reward_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub last_difficulty_id: u32,
    #[prost(uint32, tag = "4")]
    pub cur_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2135)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartEffigyChallengeReq {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2136)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartEffigyChallengeRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "5")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2033)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub challenge_score: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeDungeonResultInfo {
    #[prost(uint32, tag = "1")]
    pub challenge_id: u32,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(bool, tag = "3")]
    pub is_in_time_limit: bool,
    #[prost(uint32, tag = "4")]
    pub challenge_max_score: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2034)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeResultNotify {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_score: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2137)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeEffigyFirstPassRewardReq {
    #[prost(uint32, tag = "1")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2035)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeEffigyFirstPassRewardRsp {
    #[prost(uint32, tag = "1")]
    pub challenge_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2036)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeEffigyRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2138)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeEffigyRewardRsp {
    #[prost(uint32, tag = "1")]
    pub reward_index: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2037)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectEffigyChallengeConditionReq {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2139)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectEffigyChallengeConditionRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2140)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartEffigyChallengeReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2141)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartEffigyChallengeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapRegionInfo {
    #[prost(message, optional, tag = "1")]
    pub region_center_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub region_radius: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
    #[prost(uint32, tag = "4")]
    pub current_progress: u32,
    #[prost(uint32, tag = "5")]
    pub goal_points: u32,
    #[prost(bool, tag = "6")]
    pub is_done_mp_spot: bool,
    #[prost(bool, tag = "7")]
    pub is_find_mp_spot: bool,
    #[prost(uint32, tag = "8")]
    pub start_time: u32,
    #[prost(uint32, tag = "9")]
    pub region_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureMapBonusChallengeInfo {
    #[prost(map = "uint32, bool", tag = "1")]
    pub fragment_map: ::std::collections::HashMap<u32, bool>,
    #[prost(uint32, tag = "2")]
    pub solution_id: u32,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
    #[prost(bool, tag = "4")]
    pub is_active: bool,
    #[prost(bool, tag = "5")]
    pub is_done: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureMapActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub region_info_list: ::prost::alloc::vec::Vec<TreasureMapRegionInfo>,
    #[prost(message, repeated, tag = "2")]
    pub bonus_challenge_list: ::prost::alloc::vec::Vec<TreasureMapBonusChallengeInfo>,
    #[prost(bool, tag = "3")]
    pub is_mp_challenge_touched: bool,
    #[prost(uint32, tag = "4")]
    pub total_mp_spot_num: u32,
    #[prost(uint32, tag = "5")]
    pub currency_num: u32,
    #[prost(uint32, tag = "6")]
    pub active_region_index: u32,
    #[prost(uint32, tag = "7")]
    pub treasure_close_time: u32,
    #[prost(uint32, tag = "8")]
    pub preview_reward_id: u32,
    #[prost(uint32, tag = "9")]
    pub min_open_player_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2038)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapRegionInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub region_info: ::core::option::Option<TreasureMapRegionInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2039)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapCurrencyNotify {
    #[prost(uint32, tag = "1")]
    pub currency_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2040)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapRegionActiveNotify {
    #[prost(uint32, tag = "1")]
    pub active_region_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2142)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapMpChallengeNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2041)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureMapBonusChallengeNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<TreasureMapBonusChallengeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2042)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapGuideTaskDoneNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2143)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureMapPreTaskDoneNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingActivityDetailInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub pic_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "2")]
    pub is_activated: bool,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "4")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "5")]
    pub cur_day_scan_num: u32,
    #[prost(uint32, tag = "6")]
    pub redeem_reward_num: u32,
    #[prost(uint32, tag = "7")]
    pub cur_day_scan_type: u32,
    #[prost(uint32, tag = "8")]
    pub content_close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2144)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingScanReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2145)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingScanRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub cur_day_scan_num: u32,
    #[prost(uint32, tag = "3")]
    pub scan_pic_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2146)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingRedeemRewardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2147)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingRedeemRewardRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub pic_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingFriendPicData {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub pic_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(string, tag = "3")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub signature: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "7")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingRecvPicRecord {
    #[prost(string, tag = "1")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "4")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
    #[prost(uint32, tag = "7")]
    pub index: u32,
    #[prost(bool, tag = "8")]
    pub is_recv: bool,
    #[prost(uint32, tag = "9")]
    pub pic_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2043)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingGetFriendPicListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2044)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingGetFriendPicListRsp {
    #[prost(message, repeated, tag = "1")]
    pub friend_pic_data_list: ::prost::alloc::vec::Vec<BlessingFriendPicData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2045)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingGiveFriendPicReq {
    #[prost(uint32, tag = "1")]
    pub pic_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2046)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingGiveFriendPicRsp {
    #[prost(uint32, tag = "1")]
    pub pic_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2148)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingAcceptGivePicReq {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2149)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingAcceptGivePicRsp {
    #[prost(uint32, tag = "1")]
    pub pic_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2047)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingGetAllRecvPicRecordListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2150)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingGetAllRecvPicRecordListRsp {
    #[prost(message, repeated, tag = "1")]
    pub recv_pic_record_list: ::prost::alloc::vec::Vec<BlessingRecvPicRecord>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2048)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingRecvFriendPicNotify {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub pic_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2049)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlessingAcceptAllGivePicReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2151)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlessingAcceptAllGivePicRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub accept_pic_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub accept_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpeditionPathInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub assist_uid: u32,
    #[prost(uint32, tag = "4")]
    pub start_time: u32,
    #[prost(uint32, tag = "5")]
    pub assist_avatar_id: u32,
    #[prost(uint32, tag = "6")]
    pub assist_costume_id: u32,
    #[prost(enumeration = "ExpeditionState", tag = "7")]
    pub state: i32,
    #[prost(float, tag = "8")]
    pub bonus_probability: f32,
    #[prost(uint32, tag = "9")]
    pub mark_id: u32,
    #[prost(uint32, tag = "10")]
    pub path_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionChallengeInfo {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(bool, tag = "3")]
    pub is_finished: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpeditionActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub path_info_list: ::prost::alloc::vec::Vec<ExpeditionPathInfo>,
    #[prost(message, repeated, tag = "2")]
    pub challenge_info_list: ::prost::alloc::vec::Vec<ExpeditionChallengeInfo>,
    #[prost(uint32, tag = "3")]
    pub content_close_time: u32,
    #[prost(uint32, tag = "4")]
    pub cur_challenge_id: u32,
    #[prost(uint32, tag = "5")]
    pub expedition_count: u32,
    #[prost(bool, tag = "6")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2050)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpeditionStartReq {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub path_id: u32,
    #[prost(uint32, tag = "3")]
    pub assist_avatar_id: u32,
    #[prost(uint32, tag = "4")]
    pub assist_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2051)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpeditionStartRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub assist_uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub path_id: u32,
    #[prost(uint32, tag = "5")]
    pub assist_avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2052)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionRecallReq {
    #[prost(uint32, tag = "1")]
    pub path_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2152)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionRecallRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub path_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2153)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionTakeRewardReq {
    #[prost(uint32, tag = "1")]
    pub path_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2154)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionTakeRewardRsp {
    #[prost(uint32, tag = "1")]
    pub path_id: u32,
    #[prost(bool, tag = "2")]
    pub is_bonus: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub reward_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpeditionAssistInfo {
    #[prost(string, tag = "1")]
    pub target_nick_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "4")]
    pub assist_time: u32,
    #[prost(uint32, tag = "5")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2053)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetExpeditionAssistInfoListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2155)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExpeditionAssistInfoListRsp {
    #[prost(message, repeated, tag = "1")]
    pub assist_info_list: ::prost::alloc::vec::Vec<ExpeditionAssistInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2156)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCurExpeditionChallengeIdReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2157)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCurExpeditionChallengeIdRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2158)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionChallengeEnterRegionNotify {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(bool, tag = "2")]
    pub is_puzzle_finished: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2159)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpeditionChallengeFinishedNotify {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaterSpiritActivityDetailInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub search_time_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub mp_play_id: u32,
    #[prost(uint32, tag = "3")]
    pub region_search_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairChapterInfo {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairBalloonInfo {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairFallInfo {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairMusicRecord {
    #[prost(bool, tag = "1")]
    pub is_unlock: bool,
    #[prost(uint32, tag = "2")]
    pub max_combo: u32,
    #[prost(uint32, tag = "3")]
    pub max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairMusicGameInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub music_record_map: ::std::collections::HashMap<u32, FleurFairMusicRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairMinigameInfo {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub minigame_id: u32,
    #[prost(oneof = "fleur_fair_minigame_info::Detail", tags = "4, 5, 6")]
    pub detail: ::core::option::Option<fleur_fair_minigame_info::Detail>,
}
/// Nested message and enum types in `FleurFairMinigameInfo`.
pub mod fleur_fair_minigame_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "4")]
        BalloonInfo(super::FleurFairBalloonInfo),
        #[prost(message, tag = "5")]
        FallInfo(super::FleurFairFallInfo),
        #[prost(message, tag = "6")]
        MusicInfo(super::FleurFairMusicGameInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairDungeonSectionInfo {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub section_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairActivityDetailInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub minigame_info_map: ::std::collections::HashMap<u32, FleurFairMinigameInfo>,
    #[prost(message, repeated, tag = "2")]
    pub chapter_info_list: ::prost::alloc::vec::Vec<FleurFairChapterInfo>,
    #[prost(map = "uint32, message", tag = "3")]
    pub dungeon_section_info_map: ::std::collections::HashMap<
        u32,
        FleurFairDungeonSectionInfo,
    >,
    #[prost(bool, tag = "4")]
    pub is_content_closed: bool,
    #[prost(bool, tag = "5")]
    pub is_dungeon_unlocked: bool,
    #[prost(uint32, tag = "6")]
    pub obtained_token: u32,
    #[prost(uint32, tag = "7")]
    pub content_close_time: u32,
    #[prost(uint32, tag = "8")]
    pub dungeon_punish_over_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairBalloonSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<BalloonSettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairFallSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<FallSettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2160)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairBalloonSettleNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub settle_info_map: ::std::collections::HashMap<u32, FleurFairBalloonSettleInfo>,
    #[prost(uint32, tag = "2")]
    pub minigame_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2161)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairFallSettleNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub settle_info_map: ::std::collections::HashMap<u32, FleurFairFallSettleInfo>,
    #[prost(uint32, tag = "2")]
    pub minigame_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2162)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairMusicGameSettleReq {
    #[prost(uint32, tag = "1")]
    pub correct_hit: u32,
    #[prost(uint32, tag = "2")]
    pub music_basic_id: u32,
    #[prost(uint32, tag = "3")]
    pub combo: u32,
    #[prost(uint32, tag = "4")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2163)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairMusicGameSettleRsp {
    #[prost(uint32, tag = "1")]
    pub music_basic_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_unlock_next_level: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2164)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairMusicGameStartReq {
    #[prost(uint32, tag = "1")]
    pub music_basic_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2165)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairMusicGameStartRsp {
    #[prost(uint32, tag = "1")]
    pub music_basic_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2054)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairReplayMiniGameReq {
    #[prost(uint32, tag = "1")]
    pub minigame_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2166)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairReplayMiniGameRsp {
    #[prost(uint32, tag = "1")]
    pub minigame_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ArenaChallengeMonsterLevel {
    #[prost(uint32, tag = "1")]
    pub arena_challenge_id: u32,
    #[prost(uint32, tag = "2")]
    pub arena_challenge_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArenaChallengeActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_list: ::prost::alloc::vec::Vec<ArenaChallengeMonsterLevel>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub level_open_time_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "3")]
    pub is_finish_any_level: bool,
    #[prost(uint32, tag = "4")]
    pub world_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2167)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartArenaChallengeLevelReq {
    #[prost(uint32, tag = "1")]
    pub arena_challenge_id: u32,
    #[prost(uint32, tag = "2")]
    pub arena_challenge_level: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2055)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartArenaChallengeLevelRsp {
    #[prost(uint32, tag = "1")]
    pub arena_challenge_level: u32,
    #[prost(uint32, tag = "2")]
    pub arena_challenge_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ArenaChallengeChildChallengeInfo {
    #[prost(bool, tag = "1")]
    pub is_settled: bool,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(uint32, tag = "3")]
    pub challenge_index: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_type: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2056)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArenaChallengeFinishNotify {
    #[prost(message, repeated, tag = "1")]
    pub child_challenge_list: ::prost::alloc::vec::Vec<ArenaChallengeChildChallengeInfo>,
    #[prost(uint32, tag = "2")]
    pub arena_challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub arena_challenge_level: u32,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2057)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WaterSpritePhaseFinishNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2168)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTakeWatcherRewardBatchReq {
    #[prost(uint32, repeated, tag = "1")]
    pub watcher_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2058)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTakeWatcherRewardBatchRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, repeated, tag = "2")]
    pub watcher_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabCamp {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub buff_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabChallenge {
    #[prost(message, repeated, tag = "1")]
    pub camp_list: ::prost::alloc::vec::Vec<ChannelerSlabCamp>,
    #[prost(uint32, tag = "2")]
    pub active_camp_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabOneoffDungeon {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(bool, tag = "2")]
    pub is_done: bool,
    #[prost(uint32, tag = "3")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabChallengeStage {
    #[prost(message, repeated, tag = "1")]
    pub challenge_list: ::prost::alloc::vec::Vec<ChannelerSlabChallenge>,
    #[prost(message, optional, tag = "2")]
    pub dungeon_info: ::core::option::Option<ChannelerSlabOneoffDungeon>,
    #[prost(uint32, tag = "3")]
    pub open_time: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(bool, tag = "5")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabBuffSchemeInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub slot_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub total_energy: u32,
    #[prost(uint32, tag = "3")]
    pub self_energy: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabAssistInfo {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_level: u32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabBuffInfo {
    #[prost(message, optional, tag = "1")]
    pub mp_buff_scheme_info: ::core::option::Option<ChannelerSlabBuffSchemeInfo>,
    #[prost(message, optional, tag = "2")]
    pub single_buff_scheme_info: ::core::option::Option<ChannelerSlabBuffSchemeInfo>,
    #[prost(uint32, repeated, tag = "3")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub assist_info_list: ::prost::alloc::vec::Vec<ChannelerSlabAssistInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub last_condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(bool, tag = "3")]
    pub is_first_pass_reward_taken: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
    #[prost(uint32, tag = "5")]
    pub dungeon_index: u32,
    #[prost(uint32, tag = "6")]
    pub open_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonStageInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub taken_reward_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub dungeon_info_list: ::prost::alloc::vec::Vec<ChannelerSlabLoopDungeonInfo>,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(uint32, tag = "4")]
    pub open_time: u32,
    #[prost(uint32, tag = "5")]
    pub last_difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabActivityDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub loop_dungeon_stage_info: ::core::option::Option<
        ChannelerSlabLoopDungeonStageInfo,
    >,
    #[prost(message, repeated, tag = "2")]
    pub stage_list: ::prost::alloc::vec::Vec<ChannelerSlabChallengeStage>,
    #[prost(message, optional, tag = "3")]
    pub buff_info: ::core::option::Option<ChannelerSlabBuffInfo>,
    #[prost(uint32, tag = "4")]
    pub play_end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabStageActiveChallengeIndexNotify {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub active_camp_index: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabStageOneoffDungeonNotify {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(bool, tag = "2")]
    pub is_done: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8601)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabWearBuffReq {
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
    #[prost(bool, tag = "2")]
    pub is_mp: bool,
    #[prost(uint32, tag = "3")]
    pub buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8602)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabWearBuffRsp {
    #[prost(uint32, tag = "1")]
    pub buff_id: u32,
    #[prost(bool, tag = "2")]
    pub is_mp: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub slot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabTakeoffBuffReq {
    #[prost(uint32, tag = "1")]
    pub buff_id: u32,
    #[prost(uint32, tag = "2")]
    pub slot_id: u32,
    #[prost(bool, tag = "3")]
    pub is_mp: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabTakeoffBuffRsp {
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
    #[prost(bool, tag = "2")]
    pub is_mp: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8603)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabEnterLoopDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub dungeon_index: u32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabEnterLoopDungeonRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub dungeon_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonTakeFirstPassRewardReq {
    #[prost(uint32, tag = "1")]
    pub dungeon_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonTakeFirstPassRewardRsp {
    #[prost(uint32, tag = "1")]
    pub dungeon_index: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonTakeScoreRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonTakeScoreRewardRsp {
    #[prost(uint32, tag = "1")]
    pub reward_index: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8801)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonChallengeInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub scheme_buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub dungeon_index: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8502)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonSelectConditionReq {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub dungeon_index: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8104)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonSelectConditionRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub dungeon_index: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabLoopDungeonResultInfo {
    #[prost(uint32, tag = "1")]
    pub challenge_score: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_max_score: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_index: u32,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(bool, tag = "5")]
    pub is_in_time_limit: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabOneOffDungeonInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabOneOffDungeonInfoRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub scheme_buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8302)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabOneOffDungeonInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub scheme_buff_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8202)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabSaveAssistInfoReq {
    #[prost(message, repeated, tag = "1")]
    pub assist_info_list: ::prost::alloc::vec::Vec<ChannelerSlabAssistInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8105)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelerSlabSaveAssistInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub assist_info_list: ::prost::alloc::vec::Vec<ChannelerSlabAssistInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialBestAvatar {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub costume_id: u32,
    #[prost(enumeration = "AvatarType", tag = "3")]
    pub avatar_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MistTrialLevelData {
    #[prost(message, repeated, tag = "1")]
    pub best_avatar_list: ::prost::alloc::vec::Vec<MistTrialBestAvatar>,
    #[prost(message, optional, tag = "2")]
    pub best_hit_avatar: ::core::option::Option<MistTrialBestAvatar>,
    #[prost(uint32, tag = "3")]
    pub open_time: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
    #[prost(uint32, tag = "5")]
    pub first_pass_time: u32,
    #[prost(bool, tag = "6")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MistTrialActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub trial_level_data_list: ::prost::alloc::vec::Vec<MistTrialLevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8605)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MistTrialSelectAvatarAndEnterDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub select_avatar_index_list: ::prost::alloc::vec::Vec<SelectAvatarIndex>,
    #[prost(uint32, repeated, tag = "2")]
    pub select_trial_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub trial_id: u32,
    #[prost(uint32, tag = "4")]
    pub enter_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectAvatarIndex {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8606)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialSelectAvatarAndEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub trial_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialMissionInfo {
    #[prost(uint32, tag = "1")]
    pub param: u32,
    #[prost(uint32, tag = "2")]
    pub watcher_list_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialGetChallengeMissionReq {
    #[prost(uint32, tag = "1")]
    pub trial_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8607)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MistTrialGetChallengeMissionRsp {
    #[prost(message, repeated, tag = "1")]
    pub mission_info_list: ::prost::alloc::vec::Vec<MistTrialMissionInfo>,
    #[prost(uint32, tag = "2")]
    pub trial_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialDungeonFailNotify {
    #[prost(int32, tag = "1")]
    pub dungeon_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabCheckEnterLoopDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelerSlabCheckEnterLoopDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekMapInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub match_lock_reason_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub open_map_info_list: ::prost::alloc::vec::Vec<HideAndSeekMapInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub chosen_map_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub chosen_hider_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub unlock_map_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub chosen_hunter_skill_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekSelectSkillReq {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8106)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekSelectSkillRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8004)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityTakeScoreRewardReq {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub reward_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8107)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityTakeScoreRewardRsp {
    #[prost(uint32, tag = "1")]
    pub reward_config_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityTakeAllScoreRewardReq {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8304)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTakeAllScoreRewardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub reward_config_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8608)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekChooseMapReq {
    #[prost(uint32, repeated, tag = "1")]
    pub map_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8403)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekChooseMapRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub map_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FindHilichurlDayContentInfo {
    #[prost(uint32, tag = "1")]
    pub start_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindHilichurlDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub day_content_info_list: ::prost::alloc::vec::Vec<FindHilichurlDayContentInfo>,
    #[prost(uint32, tag = "2")]
    pub min_open_player_level: u32,
    #[prost(uint32, tag = "3")]
    pub day_index: u32,
    #[prost(bool, tag = "4")]
    pub is_content_closed: bool,
    #[prost(bool, tag = "5")]
    pub is_end_quest_accept: bool,
    #[prost(uint32, tag = "6")]
    pub content_close_time: u32,
    #[prost(uint32, tag = "7")]
    pub player_day_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8005)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonPlayerTipsNotify {
    #[prost(string, repeated, tag = "1")]
    pub text_map_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "2")]
    pub notify_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FindHilichurlFinishSecondQuestNotify {
    #[prost(uint32, tag = "1")]
    pub day_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FindHilichurlAcceptQuestNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummerTimeSprintBoatRecord {
    #[prost(uint32, repeated, tag = "1")]
    pub watcher_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub start_time: u32,
    #[prost(bool, tag = "3")]
    pub is_touched: bool,
    #[prost(uint32, tag = "4")]
    pub best_score: u32,
    #[prost(uint32, tag = "5")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummerTimeSprintBoatInfo {
    #[prost(message, repeated, tag = "1")]
    pub record_list: ::prost::alloc::vec::Vec<SummerTimeSprintBoatRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummerTimeDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub sprint_boat_info: ::core::option::Option<SummerTimeSprintBoatInfo>,
    #[prost(map = "uint32, message", tag = "2")]
    pub stage_map: ::std::collections::HashMap<u32, SummerTimeStageInfo>,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "4")]
    pub content_close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeStageInfo {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeFloatSignalPositionNotify {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(bool, tag = "2")]
    pub is_transfer_anchor: bool,
    #[prost(uint32, tag = "3")]
    pub float_signal_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeFloatSignalUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub float_signal_id: u32,
    #[prost(bool, tag = "3")]
    pub is_transfer_anchor: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeSprintBoatSettleNotify {
    #[prost(uint32, tag = "1")]
    pub medal_level: u32,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "5")]
    pub left_time: u32,
    #[prost(uint32, tag = "6")]
    pub collect_num: u32,
    #[prost(uint32, tag = "7")]
    pub group_id: u32,
    #[prost(uint32, tag = "8")]
    pub total_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8108)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeSprintBoatRestartReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8609)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeSprintBoatRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuoyantCombatDailyInfo {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
    #[prost(uint32, tag = "2")]
    pub start_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuoyantCombatDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub daily_info_list: ::prost::alloc::vec::Vec<BuoyantCombatDailyInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8305)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartBuoyantCombatGalleryReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartBuoyantCombatGalleryRsp {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_level: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuoyantCombatSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<BuoyantCombatGallerySettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuoyantCombatSettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<BuoyantCombatSettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetLimitOptimizationNotify {
    #[prost(bool, tag = "1")]
    pub is_active: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeDungeonInfo {
    #[prost(uint32, tag = "1")]
    pub total_shell_count: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "3")]
    pub total_chest_count: u32,
    #[prost(uint32, tag = "4")]
    pub taken_shell_count: u32,
    #[prost(uint32, tag = "5")]
    pub taken_chest_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EchoShellDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub shell_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub summer_time_dungeon_list: ::prost::alloc::vec::Vec<SummerTimeDungeonInfo>,
    #[prost(uint32, repeated, tag = "3")]
    pub taken_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub pass_dungeon_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EchoShellUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub shell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EchoShellTakeRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8610)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EchoShellTakeRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BounceConjuringChapterInfo {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(uint32, tag = "2")]
    pub chapter_id: u32,
    #[prost(uint32, tag = "3")]
    pub best_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BounceConjuringActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub chapter_info_list: ::prost::alloc::vec::Vec<BounceConjuringChapterInfo>,
    #[prost(bool, tag = "2")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "3")]
    pub content_close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8207)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BounceConjuringSettleNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub settle_info_map: ::std::collections::HashMap<
        u32,
        BounceConjuringGallerySettleInfo,
    >,
    #[prost(uint32, tag = "2")]
    pub chapter_id: u32,
    #[prost(uint32, tag = "3")]
    pub total_score: u32,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlitzRushStage {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParkourLevelInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub best_record: u32,
    #[prost(uint32, tag = "3")]
    pub open_time: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlitzRushActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_list: ::prost::alloc::vec::Vec<BlitzRushStage>,
    #[prost(message, repeated, tag = "2")]
    pub parkour_level_info_list: ::prost::alloc::vec::Vec<ParkourLevelInfo>,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "4")]
    pub content_close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlitzRushParkourRestartReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlitzRushParkourRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessActivityDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_map_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub content_close_time: u32,
    #[prost(uint32, tag = "4")]
    pub obtained_exp: u32,
    #[prost(uint32, tag = "5")]
    pub exp: u32,
    #[prost(bool, tag = "6")]
    pub is_content_closed: bool,
    #[prost(bool, tag = "7")]
    pub is_teach_dungeon_finished: bool,
    #[prost(uint32, tag = "8")]
    pub available_exp: u32,
    #[prost(uint32, tag = "9")]
    pub punish_over_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterChessDungeonReq {
    #[prost(uint32, tag = "1")]
    pub map_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterChessDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub map_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8006)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureMapHostInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub mp_challenge_region_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoActivityDetailInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub sumo_stage_map: ::std::collections::HashMap<u32, SumoStageData>,
    #[prost(uint32, tag = "2")]
    pub last_stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoAvatarInfo {
    #[prost(uint64, tag = "1")]
    pub avatar_id: u64,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoTeamData {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<SumoAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoStageData {
    #[prost(message, repeated, tag = "1")]
    pub team_list: ::prost::alloc::vec::Vec<SumoTeamData>,
    #[prost(uint32, tag = "2")]
    pub max_score: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
    #[prost(uint32, tag = "5")]
    pub open_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8904)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoSaveTeamReq {
    #[prost(message, repeated, tag = "1")]
    pub team_list: ::prost::alloc::vec::Vec<SumoTeamData>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8506)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoSaveTeamRsp {
    #[prost(message, repeated, tag = "1")]
    pub team_list: ::prost::alloc::vec::Vec<SumoTeamData>,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(uint32, tag = "5")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8308)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoSelectTeamAndEnterDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub team_list: ::prost::alloc::vec::Vec<SumoTeamData>,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "3")]
    pub activity_id: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8309)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoSelectTeamAndEnterDungeonRsp {
    #[prost(message, repeated, tag = "1")]
    pub team_list: ::prost::alloc::vec::Vec<SumoTeamData>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8611)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoDungeonSettleNotify {
    #[prost(uint32, tag = "1")]
    pub kill_monster_num: u32,
    #[prost(uint32, tag = "2")]
    pub final_score: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "5")]
    pub kill_elite_monster_num: u32,
    #[prost(uint32, tag = "6")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoDungeonAvatar {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_alive: bool,
    #[prost(bool, tag = "3")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoDungeonTeam {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_avatar_list: ::prost::alloc::vec::Vec<SumoDungeonAvatar>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8404)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoEnterDungeonNotify {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_team_list: ::prost::alloc::vec::Vec<SumoDungeonTeam>,
    #[prost(uint32, tag = "2")]
    pub next_valid_switch_time: u32,
    #[prost(uint32, tag = "3")]
    pub activity_id: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(uint32, tag = "5")]
    pub no_switch_punish_time: u32,
    #[prost(uint32, tag = "6")]
    pub cur_team_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8210)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoSwitchTeamReq {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8905)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoSwitchTeamRsp {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_team_list: ::prost::alloc::vec::Vec<SumoDungeonTeam>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(uint32, tag = "5")]
    pub cur_team_index: u32,
    #[prost(uint32, tag = "6")]
    pub next_valid_switch_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoLeaveDungeonNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8109)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SumoRestartDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8211)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityDisableTransferPointInteractionNotify {
    #[prost(message, optional, tag = "1")]
    pub scene_point_pair: ::core::option::Option<Uint32Pair>,
    #[prost(bool, tag = "2")]
    pub is_disable: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8405)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SumoSetNoSwitchPunishTimeNotify {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_team_list: ::prost::alloc::vec::Vec<SumoDungeonTeam>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub next_valid_switch_time: u32,
    #[prost(uint32, tag = "4")]
    pub no_switch_punish_time: u32,
    #[prost(uint32, tag = "5")]
    pub activity_id: u32,
    #[prost(uint32, tag = "6")]
    pub cur_team_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MoonfinTrialLevelInfo {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(uint32, tag = "2")]
    pub best_record: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoonfinTrialActivityDetailInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub level_info_map: ::std::collections::HashMap<u32, MoonfinTrialLevelInfo>,
    #[prost(uint32, tag = "2")]
    pub special_fish_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8212)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishingGallerySettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<FishingGallerySettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LunaRiteHintPoint {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(enumeration = "LunaRiteHintPointType", tag = "2")]
    pub r#type: i32,
    #[prost(uint32, tag = "3")]
    pub area_id: u32,
    #[prost(uint32, tag = "4")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunaRiteAreaInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub sacrifice_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub sacrifice_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub challenge_index: u32,
    #[prost(enumeration = "LunaRiteHintStatusType", tag = "4")]
    pub hint_status: i32,
    #[prost(uint32, tag = "5")]
    pub area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunaRiteDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub area_info_list: ::prost::alloc::vec::Vec<LunaRiteAreaInfo>,
    #[prost(message, repeated, tag = "2")]
    pub hint_point: ::prost::alloc::vec::Vec<LunaRiteHintPoint>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LunaRiteSacrificeReq {
    #[prost(uint32, tag = "1")]
    pub area_id: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8007)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunaRiteSacrificeRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub sacrifice_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub area_id: u32,
    #[prost(uint32, tag = "3")]
    pub index: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LunaRiteTakeSacrificeRewardReq {
    #[prost(uint32, tag = "1")]
    pub area_id: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8213)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunaRiteTakeSacrificeRewardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub sacrifice_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub sacrifice_reward_index: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub area_id: u32,
    #[prost(uint32, tag = "5")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LunaRiteHintPointReq {
    #[prost(uint32, tag = "1")]
    pub area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8804)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunaRiteHintPointRsp {
    #[prost(message, repeated, tag = "1")]
    pub hint_point: ::prost::alloc::vec::Vec<LunaRiteHintPoint>,
    #[prost(enumeration = "LunaRiteHintStatusType", tag = "2")]
    pub hint_status: i32,
    #[prost(uint32, tag = "3")]
    pub area_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8906)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunaRiteHintPointRemoveNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub hint_point_index: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LunaRiteGroupBundleRegisterNotify {
    #[prost(uint32, tag = "1")]
    pub group_link_bundle_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LunaRiteAreaFinishNotify {
    #[prost(uint32, tag = "1")]
    pub area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerActivityDetailInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub wish_flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub used_flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "3")]
    pub is_today_has_awarded: bool,
    #[prost(bool, tag = "4")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "5")]
    pub day_index: u32,
    #[prost(uint32, tag = "6")]
    pub today_seed_reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8214)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetSeedInfoReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetSeedInfoRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub seed_reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8706)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerTakeSeedRewardReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8215)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerTakeSeedRewardRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8008)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerSetFlowerWishReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8009)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerSetFlowerWishRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8312)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetFriendFlowerWishListReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerFriendFlowerWishData {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, optional, tag = "3")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8408)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetFriendFlowerWishListRsp {
    #[prost(message, repeated, tag = "1")]
    pub friend_flower_wish_list: ::prost::alloc::vec::Vec<
        PlantFlowerFriendFlowerWishData,
    >,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8110)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerGiveFriendFlowerReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8907)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerGiveFriendFlowerRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub limit_flower_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8313)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetRecvFlowerListReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerRecvFlowerData {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, optional, tag = "3")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8010)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetRecvFlowerListRsp {
    #[prost(message, repeated, tag = "1")]
    pub recv_flower_list: ::prost::alloc::vec::Vec<PlantFlowerRecvFlowerData>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerHaveRecvFlowerNotify {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerAcceptGiveFlowerReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerAcceptFlowerResultInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub unaccept_flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub accept_flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8508)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerAcceptGiveFlowerRsp {
    #[prost(message, optional, tag = "1")]
    pub accept_flower_result_info: ::core::option::Option<
        PlantFlowerAcceptFlowerResultInfo,
    >,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerAcceptAllGiveFlowerReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8806)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerAcceptAllGiveFlowerRsp {
    #[prost(message, repeated, tag = "1")]
    pub accept_flower_result_info_list: ::prost::alloc::vec::Vec<
        PlantFlowerAcceptFlowerResultInfo,
    >,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8410)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetCanGiveFriendFlowerReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8509)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerGetCanGiveFriendFlowerRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub flower_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8111)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlantFlowerEditFlowerCombinationReq {
    #[prost(message, optional, tag = "1")]
    pub flower_combination_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8216)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlantFlowerEditFlowerCombinationRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MusicGameRecord {
    #[prost(uint32, tag = "1")]
    pub max_combo: u32,
    #[prost(uint32, tag = "2")]
    pub max_score: u32,
    #[prost(bool, tag = "3")]
    pub is_unlock: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicGameActivityDetailInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub music_game_record_map: ::std::collections::HashMap<u32, MusicGameRecord>,
    #[prost(message, repeated, tag = "2")]
    pub ugc_search_list: ::prost::alloc::vec::Vec<UgcMusicBriefInfo>,
    #[prost(message, repeated, tag = "3")]
    pub ugc_record_list: ::prost::alloc::vec::Vec<UgcMusicBriefInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8314)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicGameSettleReq {
    #[prost(uint32, repeated, tag = "1")]
    pub note_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub button_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub music_basic_id: u32,
    #[prost(uint32, tag = "4")]
    pub score_rating: u32,
    #[prost(uint32, tag = "5")]
    pub is_full_combo: u32,
    #[prost(float, tag = "6")]
    pub speed: f32,
    #[prost(bool, tag = "7")]
    pub is_custom_delay: bool,
    #[prost(bool, tag = "8")]
    pub is_save_score: bool,
    #[prost(bool, tag = "9")]
    pub is_custom_speed: bool,
    #[prost(uint32, tag = "10")]
    pub max_combo: u32,
    #[prost(uint32, tag = "11")]
    pub score: u32,
    #[prost(uint32, tag = "12")]
    pub restart_times: u32,
    #[prost(uint32, tag = "13")]
    pub delay: u32,
    #[prost(uint32, tag = "14")]
    pub correct_hit: u32,
    #[prost(uint32, tag = "15")]
    pub star_rating: u32,
    #[prost(uint32, tag = "16")]
    pub combo: u32,
    #[prost(uint32, tag = "17")]
    pub volume: u32,
    #[prost(uint64, tag = "18")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8807)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MusicGameSettleRsp {
    #[prost(uint32, tag = "1")]
    pub music_basic_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_unlock_next_level: bool,
    #[prost(uint64, tag = "5")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8510)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MusicGameStartReq {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(uint32, tag = "2")]
    pub music_basic_id: u32,
    #[prost(bool, tag = "3")]
    pub is_save_score: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8217)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MusicGameStartRsp {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(uint32, tag = "2")]
    pub music_basic_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(bool, tag = "2")]
    pub is_alive: bool,
    #[prost(bool, tag = "3")]
    pub is_onstage: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueShowAvatarTeamInfo {
    #[prost(message, repeated, tag = "1")]
    pub avatar_list: ::prost::alloc::vec::Vec<RogueAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeShikigamiRecord {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueEffectRecord {
    #[prost(uint32, repeated, tag = "1")]
    pub extra_param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub count: u32,
    #[prost(uint32, tag = "3")]
    pub source_id: u32,
    #[prost(bool, tag = "4")]
    pub is_new: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeRuneRecord {
    #[prost(uint32, tag = "1")]
    pub max_count: u32,
    #[prost(uint32, tag = "2")]
    pub left_count: u32,
    #[prost(uint32, tag = "3")]
    pub rune_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueStageInfo {
    #[prost(message, optional, tag = "1")]
    pub avatar_team: ::core::option::Option<RogueShowAvatarTeamInfo>,
    #[prost(message, repeated, tag = "2")]
    pub rune_record_list: ::prost::alloc::vec::Vec<RoguelikeRuneRecord>,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub cached_coin_b_num: u32,
    #[prost(uint32, tag = "5")]
    pub coin_c_num: u32,
    #[prost(uint32, tag = "6")]
    pub cur_level: u32,
    #[prost(uint32, tag = "7")]
    pub revise_monster_level: u32,
    #[prost(uint32, tag = "8")]
    pub explore_cell_num: u32,
    #[prost(uint32, tag = "9")]
    pub cached_coin_c_num: u32,
    #[prost(bool, tag = "10")]
    pub is_passed: bool,
    #[prost(bool, tag = "11")]
    pub is_open: bool,
    #[prost(bool, tag = "12")]
    pub is_in_combat: bool,
    #[prost(bool, tag = "13")]
    pub is_explored: bool,
    #[prost(bool, tag = "14")]
    pub is_taken_reward: bool,
    #[prost(uint32, tag = "15")]
    pub max_passed_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeDungeonActivityDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub rune_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub shikigami_list: ::prost::alloc::vec::Vec<RoguelikeShikigamiRecord>,
    #[prost(uint32, repeated, tag = "3")]
    pub equipped_rune_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub stage_list: ::prost::alloc::vec::Vec<RogueStageInfo>,
    #[prost(bool, tag = "5")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "6")]
    pub content_close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8708)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoRoguelikeDungeonCardGachaReq {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "2")]
    pub cell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8511)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoRoguelikeDungeonCardGachaRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_can_refresh: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8808)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RefreshRoguelikeDungeonCardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8411)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshRoguelikeDungeonCardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub res_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8709)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectRoguelikeDungeonCardReq {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8612)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectRoguelikeDungeonCardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8112)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipRoguelikeRuneReq {
    #[prost(uint32, repeated, tag = "1")]
    pub rune_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8011)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipRoguelikeRuneRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub rune_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8613)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TriggerRoguelikeRuneReq {
    #[prost(uint32, tag = "1")]
    pub rune_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8218)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TriggerRoguelikeRuneRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub rune_id: u32,
    #[prost(uint32, tag = "3")]
    pub available_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8908)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerRoguelikeCurseNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub effect_param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_trigger_curse: bool,
    #[prost(uint32, tag = "3")]
    pub curse_level: u32,
    #[prost(uint32, tag = "4")]
    pub curse_group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8113)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpgradeRoguelikeShikigamiReq {
    #[prost(uint32, tag = "1")]
    pub shikigami_group_id: u32,
    #[prost(uint32, tag = "2")]
    pub upgrade_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpgradeRoguelikeShikigamiRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub cur_level: u32,
    #[prost(uint32, tag = "3")]
    pub shikigami_group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8219)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeSelectAvatarAndEnterDungeonReq {
    #[prost(uint64, repeated, tag = "1")]
    pub onstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, tag = "2")]
    pub backstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8413)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeSelectAvatarAndEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8614)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeGiveUpReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8315)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeGiveUpRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(oneof = "roguelike_give_up_rsp::Info", tags = "3")]
    pub info: ::core::option::Option<roguelike_give_up_rsp::Info>,
}
/// Nested message and enum types in `RoguelikeGiveUpRsp`.
pub mod roguelike_give_up_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Info {
        #[prost(message, tag = "3")]
        SettleInfo(super::RoguelikeDungeonSettleInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8220)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeTakeStageFirstPassRewardReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8512)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeTakeStageFirstPassRewardRsp {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8114)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GiveUpRoguelikeDungeonCardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8710)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GiveUpRoguelikeDungeonCardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueCellInfo {
    #[prost(uint32, tag = "1")]
    pub cell_type: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "3")]
    pub cell_id: u32,
    #[prost(uint32, tag = "4")]
    pub cell_config_id: u32,
    #[prost(enumeration = "RogueCellState", tag = "5")]
    pub state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8615)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterRoguelikeDungeonNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub onstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "2")]
    pub rune_record_list: ::prost::alloc::vec::Vec<RoguelikeRuneRecord>,
    #[prost(uint64, repeated, tag = "3")]
    pub backstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, tag = "4")]
    pub explored_cell_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, message", tag = "5")]
    pub cell_info_map: ::std::collections::HashMap<u32, RogueCellInfo>,
    #[prost(uint32, tag = "6")]
    pub cur_cell_id: u32,
    #[prost(bool, tag = "7")]
    pub is_first_enter: bool,
    #[prost(bool, tag = "8")]
    pub is_mist_clear: bool,
    #[prost(uint32, tag = "9")]
    pub refresh_cost_item_id: u32,
    #[prost(uint32, tag = "10")]
    pub refresh_cost_item_count: u32,
    #[prost(uint32, tag = "11")]
    pub dungeon_weight_config_id: u32,
    #[prost(uint32, tag = "12")]
    pub revise_monster_level: u32,
    #[prost(float, tag = "13")]
    pub bonus_resource_prop: f32,
    #[prost(uint32, tag = "14")]
    pub cur_level: u32,
    #[prost(uint32, tag = "15")]
    pub stage_id: u32,
    #[prost(uint32, tag = "16")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8513)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueEliteCellChallengeReq {
    #[prost(uint32, tag = "1")]
    pub cell_id: u32,
    #[prost(enumeration = "RogueEliteCellDifficultyType", tag = "2")]
    pub difficulty: i32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8514)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueEliteCellChallengeRsp {
    #[prost(uint32, tag = "1")]
    pub cell_id: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8221)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueNormalCellChallengeReq {
    #[prost(uint32, tag = "1")]
    pub cell_id: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8115)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueNormalCellChallengeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "3")]
    pub cell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8711)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueCellUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub cell_info: ::core::option::Option<RogueCellInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8414)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueDungeonPlayerCellChangeNotify {
    #[prost(uint32, tag = "1")]
    pub old_cell_id: u32,
    #[prost(uint32, tag = "2")]
    pub cell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8012)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueHealAvatarsReq {
    #[prost(uint32, tag = "1")]
    pub cell_id: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8013)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueHealAvatarsRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "3")]
    pub cell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8116)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueResumeDungeonReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8222)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueResumeDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8712)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearRoguelikeCurseNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub clear_curse_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "2")]
    pub is_curse_all_clear: bool,
    #[prost(bool, tag = "3")]
    pub is_clear_all: bool,
    #[prost(uint32, tag = "4")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8515)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeCardGachaNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_can_refresh: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8713)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueSwitchAvatarReq {
    #[prost(uint64, repeated, tag = "1")]
    pub onstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "2")]
    pub cell_id: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
    #[prost(uint64, tag = "4")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8714)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueSwitchAvatarRsp {
    #[prost(uint64, repeated, tag = "1")]
    pub onstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, tag = "2")]
    pub backstage_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "4")]
    pub cell_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint64, tag = "6")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8516)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableRoguelikeTrapNotify {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8616)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeRuneRecordUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub rune_record_list: ::prost::alloc::vec::Vec<RoguelikeRuneRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8715)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeMistClearNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8716)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeEffectDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<RogueEffectRecord>,
    #[prost(message, repeated, tag = "2")]
    pub curse_list: ::prost::alloc::vec::Vec<RogueEffectRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8117)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeEffectViewReq {
    #[prost(uint32, repeated, tag = "1")]
    pub view_curse_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub view_card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8717)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeEffectViewRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8718)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeResourceBonusPropUpdateNotify {
    #[prost(float, tag = "1")]
    pub bonus_resource_prop: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeSettleCoinInfo {
    #[prost(uint32, tag = "1")]
    pub coin_c: u32,
    #[prost(uint32, tag = "2")]
    pub coin_b: u32,
    #[prost(uint32, tag = "3")]
    pub cell_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoguelikeDungeonSettleInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub finished_challenge_cell_num_map: ::std::collections::HashMap<
        u32,
        RoguelikeSettleCoinInfo,
    >,
    #[prost(bool, tag = "2")]
    pub is_final_level: bool,
    #[prost(bool, tag = "3")]
    pub is_coin_c_reach_limit: bool,
    #[prost(uint32, tag = "4")]
    pub cur_level: u32,
    #[prost(uint32, tag = "5")]
    pub total_coin_b_num: u32,
    #[prost(uint32, tag = "6")]
    pub total_coin_c_num: u32,
    #[prost(uint32, tag = "7")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8809)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeRefreshCardCostUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub item_count: u32,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DigMarkPoint {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub bundle_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DigActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub dig_mark_point_list: ::prost::alloc::vec::Vec<DigMarkPoint>,
    #[prost(uint32, repeated, tag = "2")]
    pub stage_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8617)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DigActivityMarkPointChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub dig_mark_point_list: ::prost::alloc::vec::Vec<DigMarkPoint>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8415)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DigActivityChangeGadgetStateReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8618)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DigActivityChangeGadgetStateRsp {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HachiActivityDetailInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub stage_map: ::std::collections::HashMap<u32, HachiStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HachiStageInfo {
    #[prost(bool, tag = "1")]
    pub is_finished: bool,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub open_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampStageInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(uint32, tag = "3")]
    pub cur_progress: u32,
    #[prost(uint32, tag = "4")]
    pub total_progress: u32,
    #[prost(uint32, tag = "5")]
    pub id: u32,
    #[prost(bool, tag = "6")]
    pub is_finished: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampRaceStageInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub max_score: u32,
    #[prost(uint32, tag = "3")]
    pub id: u32,
    #[prost(uint32, tag = "4")]
    pub open_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub used_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, repeated, tag = "2")]
    pub battle_taken_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub wish_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub explore_taken_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "5")]
    pub battle_info: ::core::option::Option<WinterCampStageInfo>,
    #[prost(message, repeated, tag = "6")]
    pub race_info_list: ::prost::alloc::vec::Vec<WinterCampRaceStageInfo>,
    #[prost(message, optional, tag = "7")]
    pub explore_info: ::core::option::Option<WinterCampStageInfo>,
    #[prost(bool, tag = "8")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8416)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampStageInfoChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub explore_info: ::core::option::Option<WinterCampStageInfo>,
    #[prost(message, optional, tag = "2")]
    pub battle_info: ::core::option::Option<WinterCampStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8316)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampRaceScoreNotify {
    #[prost(uint32, tag = "1")]
    pub max_score: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8810)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampGiveFriendItemReq {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8719)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampGiveFriendItemRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub limit_item_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8317)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampSetWishListReq {
    #[prost(uint32, repeated, tag = "1")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8811)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampSetWishListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampFriendWishData {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "3")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8223)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampGetFriendWishListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8224)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampGetFriendWishListRsp {
    #[prost(message, repeated, tag = "1")]
    pub wish_data_list: ::prost::alloc::vec::Vec<WinterCampFriendWishData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8225)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampRecvItemNotify {
    #[prost(message, optional, tag = "1")]
    pub recv_item_data: ::core::option::Option<WinterCampRecvItemData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampAcceptItemResultInfo {
    #[prost(message, repeated, tag = "1")]
    pub unaccept_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub accept_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8619)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampAcceptGiveItemReq {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8720)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampAcceptGiveItemRsp {
    #[prost(message, optional, tag = "1")]
    pub accept_item_result_info: ::core::option::Option<WinterCampAcceptItemResultInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8014)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampAcceptAllGiveItemReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8318)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampAcceptAllGiveItemRsp {
    #[prost(message, repeated, tag = "1")]
    pub accept_item_result_info: ::prost::alloc::vec::Vec<
        WinterCampAcceptItemResultInfo,
    >,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8517)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampGetCanGiveFriendItemReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8417)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampGetCanGiveFriendItemRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampRecvItemData {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(message, repeated, tag = "3")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8319)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampGetRecvItemListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8812)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampGetRecvItemListRsp {
    #[prost(message, repeated, tag = "1")]
    pub recv_item_data_list: ::prost::alloc::vec::Vec<WinterCampRecvItemData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8226)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WinterCampEditSnowmanCombinationReq {
    #[prost(message, optional, tag = "1")]
    pub combination_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8320)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampEditSnowmanCombinationRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8813)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTriathlonSettleNotify {
    #[prost(uint32, tag = "1")]
    pub limited_coin: u32,
    #[prost(uint32, tag = "2")]
    pub remain_time: u32,
    #[prost(uint32, tag = "3")]
    pub race_id: u32,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(bool, tag = "5")]
    pub is_success: bool,
    #[prost(uint32, tag = "6")]
    pub score: u32,
    #[prost(uint32, tag = "7")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "8")]
    pub normal_coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8814)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTakeExploreRewardReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8518)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTakeExploreRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8815)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTakeBattleRewardReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8227)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTakeBattleRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8418)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTriathlonRestartReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8909)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WinterCampTriathlonRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8118)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MistTrialSettleNotify {
    #[prost(message, optional, tag = "1")]
    pub best_hit_avatar: ::core::option::Option<MistTrialBestAvatar>,
    #[prost(message, repeated, tag = "2")]
    pub best_avatar_list: ::prost::alloc::vec::Vec<MistTrialBestAvatar>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub exhibition_list_data_record_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub exhibition_list_data_result_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "5")]
    pub dungeon_scene_id: u32,
    #[prost(uint32, tag = "6")]
    pub first_pass_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8119)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialGetDungeonExhibitionDataReq {
    #[prost(uint32, tag = "1")]
    pub trial_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8321)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialGetDungeonExhibitionDataRsp {
    #[prost(uint32, tag = "1")]
    pub trial_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionLevelData {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(uint32, tag = "2")]
    pub difficulty_level: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub mode_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PotionStageData {
    #[prost(uint32, repeated, tag = "1")]
    pub cool_down_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub cool_down_buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub level_list: ::prost::alloc::vec::Vec<PotionLevelData>,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(bool, tag = "5")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PotionActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_list: ::prost::alloc::vec::Vec<PotionStageData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8228)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionResetChallengeReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8519)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PotionResetChallengeRsp {
    #[prost(message, optional, tag = "1")]
    pub stage_data: ::core::option::Option<PotionStageData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionAvatarInfo {
    #[prost(uint64, tag = "1")]
    pub avatar_id: u64,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8229)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PotionEnterDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<PotionAvatarInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub mode_id: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(uint32, tag = "5")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8721)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionDungeonAvatar {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8322)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PotionEnterDungeonNotify {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_avatar_list: ::prost::alloc::vec::Vec<PotionDungeonAvatar>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub mode_id: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_level: u32,
    #[prost(uint32, tag = "5")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8620)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionSaveDungeonResultReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8120)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionSaveDungeonResultRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8419)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8323)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PotionDungeonResultInfo {
    #[prost(uint32, tag = "1")]
    pub left_time: u32,
    #[prost(uint32, tag = "2")]
    pub difficulty_level: u32,
    #[prost(uint32, tag = "3")]
    pub mode_id: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
    #[prost(uint32, tag = "5")]
    pub stage_id: u32,
    #[prost(uint32, tag = "6")]
    pub final_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TanukiTravelLevelData {
    #[prost(uint32, tag = "1")]
    pub route_id: u32,
    #[prost(bool, tag = "2")]
    pub is_finish: bool,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TanukiTravelActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub tanuki_travel_level_data_list: ::prost::alloc::vec::Vec<TanukiTravelLevelData>,
    #[prost(uint32, tag = "2")]
    pub finished_level_index: u32,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8015)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TanukiTravelFinishGuideQuestNotify {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternProjectionLevelInfo {
    #[prost(uint32, tag = "1")]
    pub min_finish_time: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(bool, tag = "3")]
    pub is_finished: bool,
    #[prost(bool, tag = "4")]
    pub is_show_tips: bool,
    #[prost(bool, tag = "5")]
    pub is_can_start: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanternProjectionInfo {
    #[prost(enumeration = "ClientInputType", repeated, tag = "1")]
    pub view_input_tips_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "2")]
    pub open_stage_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "ClientInputType", repeated, tag = "3")]
    pub view_switch_tips_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "4")]
    pub level_list: ::prost::alloc::vec::Vec<LanternProjectionLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SalvageBundleChallengeInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_bundle_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvageScoreChallengeInfo {
    #[prost(uint32, tag = "1")]
    pub salvage_challenge_id: u32,
    #[prost(uint32, tag = "2")]
    pub max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SalvageChallengeInfo {
    #[prost(uint32, tag = "1")]
    pub challenge_type: u32,
    #[prost(bool, tag = "2")]
    pub is_unlock: bool,
    #[prost(oneof = "salvage_challenge_info::ChallengeDetail", tags = "3, 4, 5")]
    pub challenge_detail: ::core::option::Option<
        salvage_challenge_info::ChallengeDetail,
    >,
}
/// Nested message and enum types in `SalvageChallengeInfo`.
pub mod salvage_challenge_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ChallengeDetail {
        #[prost(message, tag = "3")]
        BundleInfo(super::SalvageBundleChallengeInfo),
        #[prost(message, tag = "4")]
        ScoreChallengeInfo(super::SalvageScoreChallengeInfo),
        #[prost(uint32, tag = "5")]
        BossChallengeId(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SalvageStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub challenge_info_list: ::prost::alloc::vec::Vec<SalvageChallengeInfo>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteFireworksChallengeInfo {
    #[prost(bool, tag = "1")]
    pub is_full_score: bool,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub best_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanternRiteFireworksStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub challenge_info_list: ::prost::alloc::vec::Vec<LanternRiteFireworksChallengeInfo>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanternRiteFireworksInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<LanternRiteFireworksStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanternRiteActivityDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub projection_info: ::core::option::Option<LanternProjectionInfo>,
    #[prost(message, optional, tag = "2")]
    pub fireworks_info: ::core::option::Option<LanternRiteFireworksInfo>,
    #[prost(message, repeated, tag = "3")]
    pub stage_info_list: ::prost::alloc::vec::Vec<SalvageStageInfo>,
    #[prost(bool, tag = "4")]
    pub is_taken_skin_reward: bool,
    #[prost(bool, tag = "5")]
    pub is_content_closed: bool,
    #[prost(bool, tag = "6")]
    pub is_mini_eldritch_dungeon_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8016)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinishLanternProjectionReq {
    #[prost(uint32, tag = "1")]
    pub finish_time: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8621)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinishLanternProjectionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8017)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewLanternProjectionTipsReq {
    #[prost(bool, tag = "1")]
    pub is_input_tips: bool,
    #[prost(enumeration = "ClientInputType", tag = "2")]
    pub input_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8520)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewLanternProjectionTipsRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8910)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewLanternProjectionLevelTipsReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8622)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewLanternProjectionLevelTipsRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvagePreventSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<SalvagePreventGallerySettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8324)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvagePreventSettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<SalvagePreventSettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvageEscortSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<SalvageEscortGallerySettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8623)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvageEscortSettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<SalvageEscortSettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8018)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteTakeSkinRewardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8722)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteTakeSkinRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8325)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvagePreventRestartReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8723)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvagePreventRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8121)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvageEscortRestartReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8122)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvageEscortRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8123)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteStartFireworksReformReq {
    #[prost(uint32, tag = "1")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteFireworksReformFactorInfo {
    #[prost(uint32, tag = "1")]
    pub factor_id: u32,
    #[prost(uint32, tag = "2")]
    pub factor_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteFireworksReformSkillInfo {
    #[prost(uint32, tag = "1")]
    pub unlock_challenge_id: u32,
    #[prost(bool, tag = "2")]
    pub is_unlock: bool,
    #[prost(uint32, tag = "3")]
    pub skill_id: u32,
    #[prost(uint32, tag = "4")]
    pub unlock_challenge_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8230)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanternRiteStartFireworksReformRsp {
    #[prost(message, repeated, tag = "1")]
    pub skill_info_list: ::prost::alloc::vec::Vec<LanternRiteFireworksReformSkillInfo>,
    #[prost(message, repeated, tag = "2")]
    pub factor_info_list: ::prost::alloc::vec::Vec<LanternRiteFireworksReformFactorInfo>,
    #[prost(uint32, tag = "3")]
    pub stamina_value: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "7")]
    pub fire_element_addition_ratio: u32,
    #[prost(uint32, tag = "8")]
    pub reform_score: u32,
    #[prost(uint32, tag = "9")]
    pub fire_element_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8124)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteDoFireworksReformReq {
    #[prost(uint32, tag = "1")]
    pub factor_id: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8231)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanternRiteDoFireworksReformRsp {
    #[prost(message, repeated, tag = "1")]
    pub factor_info_list: ::prost::alloc::vec::Vec<LanternRiteFireworksReformFactorInfo>,
    #[prost(bool, tag = "2")]
    pub is_lucky: bool,
    #[prost(uint32, tag = "3")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "4")]
    pub fire_element_value: u32,
    #[prost(uint32, tag = "5")]
    pub fire_element_addition_ratio: u32,
    #[prost(uint32, tag = "6")]
    pub stage_id: u32,
    #[prost(uint32, tag = "7")]
    pub reform_score: u32,
    #[prost(uint32, tag = "8")]
    pub stamina_value: u32,
    #[prost(int32, tag = "9")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8232)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteEndFireworksReformReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8326)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanternRiteEndFireworksReformRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub final_score: u32,
    #[prost(bool, tag = "4")]
    pub is_unlock_fireworks: bool,
    #[prost(bool, tag = "5")]
    pub is_new_record: bool,
    #[prost(bool, tag = "6")]
    pub is_unlock_new_skill: bool,
    #[prost(uint32, tag = "7")]
    pub challenge_id: u32,
    #[prost(bool, tag = "8")]
    pub is_full_score: bool,
    #[prost(bool, tag = "9")]
    pub is_stamina_up: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8233)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateSalvageBundleMarkReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8911)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateSalvageBundleMarkRsp {
    #[prost(uint32, tag = "1")]
    pub challenge_type: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriStage {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriChestPositionInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriChallengePositionInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub gadget_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriActivityDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub unlocked_crystal_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub challenge_pos_list: ::prost::alloc::vec::Vec<
        MichiaeMatsuriChallengePositionInfo,
    >,
    #[prost(message, repeated, tag = "3")]
    pub stage_list: ::prost::alloc::vec::Vec<MichiaeMatsuriStage>,
    #[prost(message, repeated, tag = "4")]
    pub chest_pos_list: ::prost::alloc::vec::Vec<MichiaeMatsuriChestPositionInfo>,
    #[prost(uint32, tag = "5")]
    pub gain_crystal_exp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8624)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriDarkPressureLevelUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub dark_pressure_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8724)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriInteractStatueReq {
    #[prost(uint32, tag = "1")]
    pub statue_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8625)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriInteractStatueRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8816)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriUnlockCrystalSkillReq {
    #[prost(uint32, tag = "1")]
    pub crystal_skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8817)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriUnlockCrystalSkillRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub crystal_skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8626)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriStartBossChallengeReq {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8725)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriStartBossChallengeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8818)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriStartDarkChallengeReq {
    #[prost(uint32, tag = "1")]
    pub worktop_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8912)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriStartDarkChallengeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8521)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriRemoveChestMarkNotify {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8819)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriRemoveChallengeMarkNotify {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8820)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MichiaeMatsuriGainCrystalExpUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub gain_crystal_exp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderTaskInfo {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(bool, tag = "2")]
    pub is_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderLevelInfo {
    #[prost(uint32, tag = "1")]
    pub max_score: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(bool, tag = "3")]
    pub is_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BartenderActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub unlock_task_list: ::prost::alloc::vec::Vec<BartenderTaskInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub unlock_formula_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub unlock_level_list: ::prost::alloc::vec::Vec<BartenderLevelInfo>,
    #[prost(uint32, repeated, tag = "4")]
    pub unlock_item_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "5")]
    pub is_develop_module_open: bool,
    #[prost(bool, tag = "6")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8125)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BartenderCompleteOrderReq {
    #[prost(uint32, repeated, tag = "1")]
    pub optional_order_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "3")]
    pub qte_count: u32,
    #[prost(uint32, tag = "4")]
    pub quest_id: u32,
    #[prost(bool, tag = "5")]
    pub is_view_formula: bool,
    #[prost(uint32, tag = "6")]
    pub cup_type: u32,
    #[prost(uint32, tag = "7")]
    pub retry_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8327)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BartenderCompleteOrderRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_new: bool,
    #[prost(uint32, tag = "3")]
    pub formula_id: u32,
    #[prost(uint32, tag = "4")]
    pub finish_order_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8126)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderCancelOrderReq {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8420)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderCancelOrderRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8328)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BartenderGetFormulaReq {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8019)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BartenderGetFormulaRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_new: bool,
    #[prost(uint32, tag = "4")]
    pub formula_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8127)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderStartLevelReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8020)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BartenderStartLevelRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub order_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub time: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8522)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderCancelLevelReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8913)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderCancelLevelRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8021)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderLevelProgressNotify {
    #[prost(bool, tag = "1")]
    pub is_finish: bool,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "3")]
    pub score: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8421)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderFinishLevelReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8914)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BartenderFinishLevelRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfficialCustomDungeon {
    #[prost(uint32, tag = "1")]
    pub win_times: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub official_custom_dungeon_list: ::prost::alloc::vec::Vec<OfficialCustomDungeon>,
    #[prost(uint32, tag = "2")]
    pub custom_dungeon_group_id: u32,
    #[prost(bool, tag = "3")]
    pub is_enable_ugc: bool,
    #[prost(bool, tag = "4")]
    pub is_ugc_feature_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrystalLinkActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<CrystalLinkLevelInfo>,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrystalLinkLevelInfo {
    #[prost(message, repeated, tag = "1")]
    pub team_info_list: ::prost::alloc::vec::Vec<CrystalLinkTeamInfo>,
    #[prost(uint32, tag = "2")]
    pub best_score: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrystalLinkTeamInfo {
    #[prost(message, repeated, tag = "1")]
    pub buff_info_list: ::prost::alloc::vec::Vec<CrystalLinkBuffInfo>,
    #[prost(message, repeated, tag = "2")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<CrystalLinkAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrystalLinkAvatarInfo {
    #[prost(uint64, tag = "1")]
    pub avatar_id: u64,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrystalLinkBuffInfo {
    #[prost(uint32, tag = "1")]
    pub effect_buff_id: u32,
    #[prost(uint32, tag = "2")]
    pub cond_buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8821)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrystalLinkEnterDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub team_info_list: ::prost::alloc::vec::Vec<CrystalLinkTeamInfo>,
    #[prost(uint32, tag = "2")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8627)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrystalLinkEnterDungeonRsp {
    #[prost(message, repeated, tag = "1")]
    pub team_info_list: ::prost::alloc::vec::Vec<CrystalLinkTeamInfo>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrystalLinkDungeonAvatarInfo {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8128)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrystalLinkDungeonInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_avatar_info_list: ::prost::alloc::vec::Vec<CrystalLinkDungeonAvatarInfo>,
    #[prost(message, repeated, tag = "2")]
    pub buff_info_list: ::prost::alloc::vec::Vec<CrystalLinkBuffInfo>,
    #[prost(uint32, tag = "3")]
    pub difficulty_id: u32,
    #[prost(bool, tag = "4")]
    pub is_upper_part: bool,
    #[prost(uint32, tag = "5")]
    pub level_id: u32,
    #[prost(uint32, tag = "6")]
    pub init_gallery_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8915)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrystalLinkRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8822)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrystalLinkRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8823)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuickOpenActivityReq {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8523)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuickOpenActivityRsp {
    #[prost(uint32, tag = "1")]
    pub activity_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessMapData {
    #[prost(message, optional, tag = "1")]
    pub entrance_detail_info: ::core::option::Option<IrodoriChessEntranceDetailInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub equipped_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub map_id: u32,
    #[prost(uint32, tag = "4")]
    pub best_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessLevelData {
    #[prost(message, optional, tag = "1")]
    pub normal_map_data: ::core::option::Option<IrodoriChessMapData>,
    #[prost(message, optional, tag = "2")]
    pub hard_map_data: ::core::option::Option<IrodoriChessMapData>,
    #[prost(uint32, tag = "3")]
    pub open_time: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessData {
    #[prost(message, repeated, tag = "1")]
    pub level_data_list: ::prost::alloc::vec::Vec<IrodoriChessLevelData>,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriFlowerData {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_theme_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub used_flower_list: ::prost::alloc::vec::Vec<ItemParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriPoetryThemeData {
    #[prost(uint32, repeated, tag = "1")]
    pub scanned_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub line_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub min_progress: u32,
    #[prost(uint32, tag = "4")]
    pub selected_line_id: u32,
    #[prost(uint32, tag = "5")]
    pub progress: u32,
    #[prost(uint32, tag = "6")]
    pub max_progress: u32,
    #[prost(uint32, tag = "7")]
    pub theme_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriPoetryData {
    #[prost(message, repeated, tag = "1")]
    pub theme_data_list: ::prost::alloc::vec::Vec<IrodoriPoetryThemeData>,
    #[prost(uint32, tag = "2")]
    pub cur_theme_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriMasterLevelDetailInfo {
    #[prost(bool, tag = "1")]
    pub is_have_try: bool,
    #[prost(bool, tag = "2")]
    pub is_finish: bool,
    #[prost(uint32, tag = "3")]
    pub min_finish_time: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriMasterLevelInfo {
    #[prost(message, repeated, tag = "1")]
    pub detail_info: ::prost::alloc::vec::Vec<IrodoriMasterLevelDetailInfo>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub master_level_list: ::prost::alloc::vec::Vec<IrodoriMasterLevelInfo>,
    #[prost(message, optional, tag = "2")]
    pub poetry_data: ::core::option::Option<IrodoriPoetryData>,
    #[prost(message, optional, tag = "3")]
    pub flower_data: ::core::option::Option<IrodoriFlowerData>,
    #[prost(message, optional, tag = "4")]
    pub chess_data: ::core::option::Option<IrodoriChessData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8628)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriEditFlowerCombinationReq {
    #[prost(message, optional, tag = "1")]
    pub combination_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8629)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriEditFlowerCombinationRsp {
    #[prost(bool, tag = "1")]
    pub is_already_finished: bool,
    #[prost(bool, tag = "2")]
    pub is_can_take_reward: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8234)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriScanEntityReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8916)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriScanEntityRsp {
    #[prost(message, optional, tag = "1")]
    pub theme_data: ::core::option::Option<IrodoriPoetryThemeData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_get_inspiration: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8726)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriFillPoetryReq {
    #[prost(uint32, tag = "1")]
    pub theme_id: u32,
    #[prost(uint32, tag = "2")]
    pub line_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8235)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriFillPoetryRsp {
    #[prost(message, optional, tag = "1")]
    pub theme_data: ::core::option::Option<IrodoriPoetryThemeData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8129)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessEquipCardReq {
    #[prost(bool, tag = "1")]
    pub is_hard_map: bool,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8022)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessEquipCardRsp {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_hard_map: bool,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8917)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessUnequippedCardReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
    #[prost(bool, tag = "3")]
    pub is_hard_map: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8630)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessUnequippedCardRsp {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(bool, tag = "4")]
    pub is_hard_map: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8524)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterIrodoriChessDungeonReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(bool, tag = "2")]
    pub is_hard_map: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8236)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterIrodoriChessDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_hard_map: bool,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8023)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriMasterStartGalleryReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8824)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriMasterStartGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8237)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriMasterGalleryCgEndNotify {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8024)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriMasterGallerySettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<IrodoriMasterGallerySettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhotoPosData {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_view: bool,
    #[prost(uint32, tag = "5")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhotoActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub photo_pos_data_list: ::prost::alloc::vec::Vec<PhotoPosData>,
    #[prost(bool, tag = "2")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8525)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhotoActivityFinishReq {
    #[prost(uint32, tag = "1")]
    pub check_root_id: u32,
    #[prost(bool, tag = "2")]
    pub is_succ: bool,
    #[prost(uint32, tag = "3")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8422)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhotoActivityFinishRsp {
    #[prost(uint32, tag = "1")]
    pub pos_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8631)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhotoActivityClientViewReq {
    #[prost(uint32, tag = "1")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8632)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhotoActivityClientViewRsp {
    #[prost(uint32, tag = "1")]
    pub pos_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpiceStageData {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub success_times: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpiceActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub spice_stage_data_list: ::prost::alloc::vec::Vec<SpiceStageData>,
    #[prost(uint32, tag = "2")]
    pub current_increase_avatar_fetter_times: u32,
    #[prost(uint32, tag = "3")]
    pub increase_avatar_fetter_limit_times: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8633)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpiceActivityFinishMakeSpiceReq {
    #[prost(uint32, repeated, tag = "1")]
    pub left_material_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub left_turns: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8130)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpiceActivityFinishMakeSpiceRsp {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8238)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpiceActivityProcessFoodReq {
    #[prost(message, repeated, tag = "1")]
    pub normal_food_list: ::prost::alloc::vec::Vec<ItemParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8131)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpiceActivityProcessFoodRsp {
    #[prost(message, repeated, tag = "1")]
    pub normal_food_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub special_food_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8634)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpiceActivityGivingRecordNotify {
    #[prost(uint32, tag = "1")]
    pub current_increase_avatar_fetter_times: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "3")]
    pub increase_avatar_fetter_limit_times: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaStageData {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub target_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaActivityDetailInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub have_reward_robot_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub have_get_robot_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub robot_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, repeated, tag = "4")]
    pub gacha_stage_data_list: ::prost::alloc::vec::Vec<GachaStageData>,
    #[prost(uint32, tag = "5")]
    pub tech_create_robot_id: u32,
    #[prost(uint32, tag = "6")]
    pub robot_finish_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8918)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaActivityPercentNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub target_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub percent: u32,
    #[prost(uint32, tag = "3")]
    pub sub_item_stage: u32,
    #[prost(uint32, tag = "4")]
    pub item_stage: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8526)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityUpdateElemNotify {
    #[prost(uint32, tag = "1")]
    pub elem_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8727)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityCreateRobotReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8635)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityCreateRobotRsp {
    #[prost(uint32, tag = "1")]
    pub robot_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8423)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaActivityTakeRewardReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub robot_num_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8527)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaActivityTakeRewardRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub robot_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8919)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityResetReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8025)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityResetRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8825)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityNextStageReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8132)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaActivityNextStageRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8424)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityGiveFriendGiftReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8425)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityGiveFriendGiftRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub limit_gift_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityRecvGiftData {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8728)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityGetRecvGiftListReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8239)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityGetRecvGiftListRsp {
    #[prost(message, repeated, tag = "1")]
    pub recv_gift_list: ::prost::alloc::vec::Vec<ActivityRecvGiftData>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8729)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityHaveRecvGiftNotify {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityAcceptGiftResultInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub unaccept_gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub accept_gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8329)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityAcceptGiveGiftReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8528)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityAcceptGiveGiftRsp {
    #[prost(message, optional, tag = "1")]
    pub accept_gift_result_info: ::core::option::Option<ActivityAcceptGiftResultInfo>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8529)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityAcceptAllGiveGiftReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8920)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityAcceptAllGiveGiftRsp {
    #[prost(message, repeated, tag = "1")]
    pub accept_gift_result_info_list: ::prost::alloc::vec::Vec<
        ActivityAcceptGiftResultInfo,
    >,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8133)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityGetCanGiveFriendGiftReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8730)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityGetCanGiveFriendGiftRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8530)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivitySetGiftWishReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8826)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivitySetGiftWishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityFriendGiftWishData {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub gift_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8134)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityGetFriendGiftWishListReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8636)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityGetFriendGiftWishListRsp {
    #[prost(message, repeated, tag = "1")]
    pub friend_gift_wish_list: ::prost::alloc::vec::Vec<ActivityFriendGiftWishData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LuminanceStoneChallengeActivityDetailInfo {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
    #[prost(bool, tag = "2")]
    pub is_final_gallery_complete: bool,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "4")]
    pub current_stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LuminanceStoneChallengeSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<LuminanceStoneChallengeGallerySettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8531)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LuminanceStoneChallengeSettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<LuminanceStoneChallengeSettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueDiaryDungeonRecord {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
    #[prost(bool, tag = "2")]
    pub is_finish: bool,
    #[prost(uint32, tag = "3")]
    pub finish_time: u32,
    #[prost(uint32, tag = "4")]
    pub max_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueDiaryStageInfo {
    #[prost(message, optional, tag = "1")]
    pub best_record: ::core::option::Option<RogueDiaryDungeonRecord>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_have_try: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryProgress {
    #[prost(uint32, repeated, tag = "1")]
    pub optional_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty: u32,
    #[prost(uint32, tag = "4")]
    pub cur_round: u32,
    #[prost(bool, tag = "5")]
    pub is_enter_dungeon: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryActivityDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub cur_progress: ::core::option::Option<RogueDiaryProgress>,
    #[prost(message, repeated, tag = "2")]
    pub stage_list: ::prost::alloc::vec::Vec<RogueDiaryStageInfo>,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
    #[prost(bool, tag = "4")]
    pub is_have_progress: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryAvatar {
    #[prost(message, optional, tag = "1")]
    pub avatar: ::core::option::Option<ActivityDungeonAvatar>,
    #[prost(enumeration = "RogueDiaryAvatarDisableStatus", repeated, tag = "2")]
    pub disable_status_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "3")]
    pub tired_round: u32,
    #[prost(uint32, tag = "4")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryRoomInfo {
    #[prost(message, repeated, tag = "1")]
    pub monster_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(bool, tag = "3")]
    pub is_boss: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8240)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueDiaryPlayReq {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8426)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartRogueDiaryPlayRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub rand_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub trial_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(message, repeated, tag = "3")]
    pub avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8427)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetRogueDiaryPlayReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8428)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetRogueDiaryPlayRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8429)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterRogueDiaryDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub chosen_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub chosen_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8921)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterRogueDiaryDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8637)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResumeRogueDiaryDungeonReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8135)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResumeRogueDiaryDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8532)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryDungeonInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub round_monster_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub room_list: ::prost::alloc::vec::Vec<RogueDiaryRoomInfo>,
    #[prost(uint32, repeated, tag = "3")]
    pub round_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub cur_room: u32,
    #[prost(uint32, tag = "5")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "6")]
    pub difficulty: u32,
    #[prost(uint32, tag = "7")]
    pub time: u32,
    #[prost(uint32, tag = "8")]
    pub cur_round: u32,
    #[prost(uint32, tag = "9")]
    pub stage_id: u32,
    #[prost(uint32, tag = "10")]
    pub coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8731)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueDiaryDungeonSettleNotify {
    #[prost(bool, tag = "1")]
    pub is_finish: bool,
    #[prost(uint32, tag = "2")]
    pub explore_time: u32,
    #[prost(uint32, tag = "3")]
    pub cur_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8330)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueDiaryRoomReq {
    #[prost(bool, tag = "1")]
    pub is_select_hard: bool,
    #[prost(uint32, tag = "2")]
    pub room_difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8026)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartRogueDiaryRoomRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8241)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryTiredAvatarNotify {
    #[prost(message, repeated, tag = "1")]
    pub optional_tired_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(uint32, tag = "2")]
    pub reserve_avatar_num: u32,
    #[prost(bool, tag = "3")]
    pub is_need_show: bool,
    #[prost(uint32, tag = "4")]
    pub tired_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8136)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReserveRogueDiaryAvatarReq {
    #[prost(message, repeated, tag = "1")]
    pub reserve_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8137)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReserveRogueDiaryAvatarRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8430)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRogueDairyRepairInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8431)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRogueDairyRepairInfoRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8331)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshRogueDiaryCardReq {
    #[prost(uint32, repeated, tag = "1")]
    pub refresh_card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8922)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshRogueDiaryCardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub rand_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8242)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueFinishRepairReq {
    #[prost(message, repeated, tag = "1")]
    pub chosen_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(uint32, repeated, tag = "2")]
    pub chosen_card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8827)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueFinishRepairRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8923)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryInterruptRogueDiaryDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8243)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryInterruptRogueDiaryDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8828)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryRepairInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub select_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(uint32, repeated, tag = "2")]
    pub chosen_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub trial_avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(message, repeated, tag = "4")]
    pub avatar_list: ::prost::alloc::vec::Vec<RogueDiaryAvatar>,
    #[prost(uint32, repeated, tag = "5")]
    pub select_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "6")]
    pub room_list: ::prost::alloc::vec::Vec<RogueDiaryRoomInfo>,
    #[prost(uint32, repeated, tag = "7")]
    pub rand_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "8")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8027)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryCurRogueDiaryDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8332)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryCurRogueDiaryDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8829)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RogueDiaryReviveAvatarReq {
    #[prost(message, optional, tag = "1")]
    pub revive_avatar: ::core::option::Option<RogueDiaryAvatar>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8138)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueDiaryReviveAvatarRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8533)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryEnterNextRogueDiaryDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8333)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryEnterNextRogueDiaryDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8432)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RogueDiaryCoinAddNotify {
    #[prost(uint32, tag = "1")]
    pub num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummerTimeV2DetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_stage_info_list: ::prost::alloc::vec::Vec<SummerTimeV2DungeonStageInfo>,
    #[prost(message, repeated, tag = "2")]
    pub boat_stage_info_list: ::prost::alloc::vec::Vec<SummerTimeV2BoatStageInfo>,
    #[prost(bool, tag = "3")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "4")]
    pub taken_reward_count: u32,
    #[prost(uint32, tag = "5")]
    pub cur_dungeon_reward_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2DungeonStageInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(bool, tag = "2")]
    pub is_prev_dungeon_succeed: bool,
    #[prost(uint32, tag = "3")]
    pub open_time: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2BoatStageInfo {
    #[prost(uint32, tag = "1")]
    pub open_time: u32,
    #[prost(uint32, tag = "2")]
    pub best_score: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8830)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2BoatSettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<SummerTimeV2BoatGallerySettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityPushTipsData {
    #[prost(enumeration = "ActivityPushTipsState", tag = "1")]
    pub state: i32,
    #[prost(uint32, tag = "2")]
    pub activity_push_tips_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8732)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityPushTipsInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub activity_push_tips_data_list: ::prost::alloc::vec::Vec<ActivityPushTipsData>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8433)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityReadPushTipsReq {
    #[prost(uint32, repeated, tag = "1")]
    pub activity_push_tips_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8638)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityReadPushTipsRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8334)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2RestartBoatGalleryReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8139)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2RestartBoatGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8831)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2RestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8639)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2RestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IslandPartyStageData {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub best_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IslandPartyDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_data_list: ::prost::alloc::vec::Vec<IslandPartyStageData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24601)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IslandPartySettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(message, repeated, tag = "2")]
    pub settle_info_list: ::prost::alloc::vec::Vec<IslandPartyGallerySettleInfo>,
    #[prost(enumeration = "GalleryStopReason", tag = "3")]
    pub reason: i32,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "5")]
    pub time_remain: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearLevelData {
    #[prost(uint32, tag = "1")]
    pub last_duration: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_finished: bool,
    #[prost(uint32, tag = "5")]
    pub open_time: u32,
    #[prost(uint32, tag = "6")]
    pub shortest_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JigsawPictureData {
    #[prost(uint32, tag = "1")]
    pub last_duration: u32,
    #[prost(uint32, tag = "2")]
    pub shortest_time: u32,
    #[prost(bool, tag = "3")]
    pub is_finished: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GearActivityDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub jigsaw_picture_data: ::core::option::Option<JigsawPictureData>,
    #[prost(message, repeated, tag = "2")]
    pub gear_level_data_list: ::prost::alloc::vec::Vec<GearLevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityStartPlayGearReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20701)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityStartPlayGearRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearColumnInfo {
    #[prost(uint32, tag = "1")]
    pub gear_id: u32,
    #[prost(uint32, tag = "2")]
    pub gear_column_index: u32,
    #[prost(bool, tag = "3")]
    pub is_overturn: bool,
    #[prost(bool, tag = "4")]
    pub has_gear: bool,
    #[prost(uint32, tag = "5")]
    pub placement_layer: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GearActivityFinishPlayGearReq {
    #[prost(message, repeated, tag = "1")]
    pub gear_column_info_list: ::prost::alloc::vec::Vec<GearColumnInfo>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub use_clue: bool,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityFinishPlayGearRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23701)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityStartPlayPictureReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityStartPlayPictureRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityFinishPlayPictureReq {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GearActivityFinishPlayPictureRsp {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocencePhotoStageInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(bool, tag = "2")]
    pub is_finished: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocencePhotoObjectInfo {
    #[prost(uint32, tag = "1")]
    pub object_id: u32,
    #[prost(uint32, tag = "2")]
    pub param: u32,
    #[prost(uint32, tag = "3")]
    pub finish_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GravenInnocencePhotoInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<GravenInnocencePhotoStageInfo>,
    #[prost(message, repeated, tag = "2")]
    pub object_info_list: ::prost::alloc::vec::Vec<GravenInnocencePhotoObjectInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceCampStageInfo {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_finished: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GravenInnocenceCampInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<GravenInnocenceCampStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceRaceLevelInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GravenInnocenceRaceInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<GravenInnocenceRaceLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceCarveStageInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GravenInnocenceCarveInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub has_edit_config_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub stage_info_list: ::prost::alloc::vec::Vec<GravenInnocenceCarveStageInfo>,
    #[prost(uint32, tag = "3")]
    pub can_edit_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GravenInnocenceDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub photo_info: ::core::option::Option<GravenInnocencePhotoInfo>,
    #[prost(message, optional, tag = "2")]
    pub carve_info: ::core::option::Option<GravenInnocenceCarveInfo>,
    #[prost(message, optional, tag = "3")]
    pub race_info: ::core::option::Option<GravenInnocenceRaceInfo>,
    #[prost(message, optional, tag = "4")]
    pub camp_info: ::core::option::Option<GravenInnocenceCampInfo>,
    #[prost(bool, tag = "5")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceRaceSettleNotify {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(uint32, tag = "2")]
    pub remain_time: u32,
    #[prost(enumeration = "GalleryStopReason", tag = "3")]
    pub reason: i32,
    #[prost(uint32, tag = "4")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_progress: u32,
    #[prost(uint32, tag = "6")]
    pub coin_count: u32,
    #[prost(uint32, tag = "7")]
    pub level_id: u32,
    #[prost(bool, tag = "8")]
    pub is_new_record: bool,
    #[prost(bool, tag = "9")]
    pub is_success: bool,
    #[prost(uint32, tag = "10")]
    pub total_coin_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceRaceRestartReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceRaceRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GravenInnocenceEditCarveCombinationReq {
    #[prost(message, optional, tag = "1")]
    pub combination_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocenceEditCarveCombinationRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocencePhotoFinishReq {
    #[prost(uint32, tag = "1")]
    pub object_id: u32,
    #[prost(uint32, tag = "2")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocencePhotoFinishRsp {
    #[prost(uint32, tag = "1")]
    pub param: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub object_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22601)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GravenInnocencePhotoReminderNotify {
    #[prost(uint32, tag = "1")]
    pub group_bundle_id: u32,
    #[prost(uint32, tag = "2")]
    pub reminder_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayTeamInfo {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<InstableSprayAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub team_info_list: ::prost::alloc::vec::Vec<InstableSprayTeamInfo>,
    #[prost(bool, tag = "2")]
    pub is_finished: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
    #[prost(uint32, tag = "4")]
    pub max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<InstableSprayStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstableSprayAvatarInfo {
    #[prost(uint64, tag = "1")]
    pub avatar_id: u64,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22602)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayEnterDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<InstableSprayAvatarInfo>,
    #[prost(uint32, tag = "2")]
    pub difficulty: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstableSprayEnterDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSpraySwitchTeamReq {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<InstableSprayAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24701)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstableSpraySwitchTeamRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24901)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayLevelFinishNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub difficulty: u32,
    #[prost(uint32, tag = "3")]
    pub round: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
    #[prost(bool, tag = "5")]
    pub is_need_switch_team: bool,
    #[prost(bool, tag = "6")]
    pub is_skip_black_screen: bool,
    #[prost(uint32, tag = "7")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21001)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayRestartDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<InstableSprayAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstableSprayRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24501)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayRestartDungeonRoundReq {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<InstableSprayAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstableSprayRestartDungeonRoundRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionLevelData {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuqadasPotionActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub muqadas_potion_level_data_list: ::prost::alloc::vec::Vec<MuqadasPotionLevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23601)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionActivityEnterDungeonReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionActivityEnterDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionDungeonSettleNotify {
    #[prost(uint32, tag = "1")]
    pub capture_weakness_count: u32,
    #[prost(uint32, tag = "2")]
    pub final_score: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(uint32, tag = "5")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionCaptureWeaknessReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub capture_weakness_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionCaptureWeaknessRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionQueryTeamReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuqadasPotionTrialTeamInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub trial_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub team_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuqadasPotionQueryTeamRsp {
    #[prost(map = "uint32, message", tag = "1")]
    pub trial_team_info_map: ::std::collections::HashMap<
        u32,
        MuqadasPotionTrialTeamInfo,
    >,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21002)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuqadasPotionSaveTeamReq {
    #[prost(uint32, repeated, tag = "1")]
    pub trial_avatar_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MuqadasPotionSaveTeamRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureSeelieRegionData {
    #[prost(message, optional, tag = "1")]
    pub region_center_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub open_day: u32,
    #[prost(bool, tag = "3")]
    pub is_done: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
    #[prost(uint32, tag = "5")]
    pub total_chest_num: u32,
    #[prost(float, tag = "6")]
    pub region_radius: f32,
    #[prost(uint32, tag = "7")]
    pub region_id: u32,
    #[prost(uint32, tag = "8")]
    pub scene_id: u32,
    #[prost(uint32, tag = "9")]
    pub open_time: u32,
    #[prost(uint32, tag = "10")]
    pub opened_chest_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureSeelieActivityDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub region_data_list: ::prost::alloc::vec::Vec<TreasureSeelieRegionData>,
    #[prost(bool, tag = "2")]
    pub is_content_closed: bool,
    #[prost(uint32, tag = "3")]
    pub treasure_close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TreasureSeelieCollectOrbsNotify {
    #[prost(uint32, tag = "1")]
    pub total_num: u32,
    #[prost(uint32, tag = "2")]
    pub current_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RockBoardExploreStageData {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(bool, tag = "3")]
    pub is_finish: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RockBoardExploreDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_data_list: ::prost::alloc::vec::Vec<RockBoardExploreStageData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingStageData {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(uint32, tag = "3")]
    pub record_value: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
    #[prost(bool, tag = "5")]
    pub is_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintagePresentLevelData {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(bool, tag = "2")]
    pub is_finish: bool,
    #[prost(uint32, tag = "3")]
    pub present_id: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintagePresentStageData {
    #[prost(map = "uint32, message", tag = "1")]
    pub present_level_map: ::std::collections::HashMap<u32, VintagePresentLevelData>,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_finish: bool,
    #[prost(uint32, tag = "5")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageBoothUsedItemData {
    #[prost(uint32, tag = "1")]
    pub gadget_id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageCampChallengeLevelData {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_finish: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageCampChallengeStageData {
    #[prost(map = "uint32, message", tag = "1")]
    pub camp_level_map: ::std::collections::HashMap<u32, VintageCampChallengeLevelData>,
    #[prost(uint32, tag = "2")]
    pub max_finished_level: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_finish: bool,
    #[prost(uint32, tag = "5")]
    pub open_time: u32,
    #[prost(uint32, tag = "6")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketTraderInfo {
    #[prost(message, repeated, tag = "1")]
    pub available_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub trader_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketDealInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub trader_item_info_map: ::std::collections::HashMap<u32, VintageMarketTraderInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_attr_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub next_aim_attr_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub slot_count: u32,
    #[prost(uint32, tag = "5")]
    pub store_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreOpInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub add_attr_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub store_id: u32,
    #[prost(uint32, tag = "4")]
    pub help_skill_id: u32,
    #[prost(uint32, tag = "5")]
    pub help_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_env_event_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub store_round_income_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub viewed_strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub cur_npc_event_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "5")]
    pub open_store_list: ::prost::alloc::vec::Vec<VintageMarketStoreInfo>,
    #[prost(uint32, repeated, tag = "6")]
    pub unlock_strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "7")]
    pub deal_info: ::core::option::Option<VintageMarketDealInfo>,
    #[prost(map = "uint32, bool", tag = "8")]
    pub bargain_info_map: ::std::collections::HashMap<u32, bool>,
    #[prost(bool, tag = "9")]
    pub is_strategy_module_open: bool,
    #[prost(bool, tag = "10")]
    pub is_market_content_finish: bool,
    #[prost(bool, tag = "11")]
    pub is_market_content_open: bool,
    #[prost(bool, tag = "12")]
    pub is_round_tips_view: bool,
    #[prost(uint32, tag = "13")]
    pub dividend_reward_count: u32,
    #[prost(uint32, tag = "14")]
    pub help_skill_id: u32,
    #[prost(bool, tag = "15")]
    pub is_store_content_finish: bool,
    #[prost(bool, tag = "16")]
    pub is_store_content_interrupt: bool,
    #[prost(bool, tag = "17")]
    pub is_help_in_cd: bool,
    #[prost(bool, tag = "18")]
    pub is_help_module_open: bool,
    #[prost(uint32, tag = "19")]
    pub prev_coin_b_num: u32,
    #[prost(uint32, tag = "20")]
    pub store_round: u32,
    #[prost(uint32, tag = "21")]
    pub prev_coin_c_num: u32,
    #[prost(uint32, tag = "22")]
    pub next_can_use_help_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageActivityDetailInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub camp_stage_map: ::std::collections::HashMap<u32, VintageCampChallengeStageData>,
    #[prost(message, optional, tag = "2")]
    pub market_info: ::core::option::Option<VintageMarketInfo>,
    #[prost(map = "uint32, message", tag = "3")]
    pub present_stage_map: ::std::collections::HashMap<u32, VintagePresentStageData>,
    #[prost(map = "uint32, message", tag = "4")]
    pub hunting_stage_map: ::std::collections::HashMap<u32, VintageHuntingStageData>,
    #[prost(message, optional, tag = "5")]
    pub booth_data: ::core::option::Option<VintageBoothUsedItemData>,
    #[prost(bool, tag = "6")]
    pub is_content_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23501)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketDeliverItemReq {
    #[prost(message, repeated, tag = "1")]
    pub deliver_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub trader_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageMarketDeliverItemRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub trader_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingFirstStageSettleInfo {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(uint32, tag = "2")]
    pub elite_cnt: u32,
    #[prost(uint32, tag = "3")]
    pub timid_cnt: u32,
    #[prost(uint32, tag = "4")]
    pub brutal_cnt: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageHuntingSecondStageSettleInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub animal_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub capture_animal_num: u32,
    #[prost(uint32, tag = "3")]
    pub total_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingThirdStageSettleInfo {
    #[prost(uint32, tag = "1")]
    pub left_time: u32,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24203)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryVintageHuntingSettleNotify {
    #[prost(uint32, tag = "1")]
    pub finished_watcher_num: u32,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(bool, tag = "3")]
    pub has_new_watcher: bool,
    #[prost(uint32, tag = "4")]
    pub total_watcher_num: u32,
    #[prost(uint32, tag = "5")]
    pub stage_id: u32,
    #[prost(
        oneof = "scene_gallery_vintage_hunting_settle_notify::Info",
        tags = "6, 7, 8"
    )]
    pub info: ::core::option::Option<scene_gallery_vintage_hunting_settle_notify::Info>,
}
/// Nested message and enum types in `SceneGalleryVintageHuntingSettleNotify`.
pub mod scene_gallery_vintage_hunting_settle_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Info {
        #[prost(message, tag = "6")]
        FirstStageInfo(super::VintageHuntingFirstStageSettleInfo),
        #[prost(message, tag = "7")]
        SecondStageInfo(super::VintageHuntingSecondStageSettleInfo),
        #[prost(message, tag = "8")]
        ThirdStageInfo(super::VintageHuntingThirdStageSettleInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintagePresentFinishNoify {
    #[prost(uint32, tag = "1")]
    pub present_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24302)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageDecorateBoothReq {
    #[prost(message, optional, tag = "1")]
    pub combination_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageDecorateBoothRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingStartGalleryReq {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingStartGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageCampGroupBundleRegisterNotify {
    #[prost(uint32, tag = "1")]
    pub group_bundle_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22701)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageCampStageFinishNotify {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageMarketStartStorePlayReq {
    #[prost(uint32, tag = "1")]
    pub store_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageMarketStartStorePlayRsp {
    #[prost(uint32, tag = "1")]
    pub store_round: u32,
    #[prost(uint32, tag = "2")]
    pub prev_round_coin_c: u32,
    #[prost(uint32, tag = "3")]
    pub prev_round_coin_b: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketFinishStorePlayReq {
    #[prost(message, repeated, tag = "1")]
    pub store_op_list: ::prost::alloc::vec::Vec<VintageMarketStoreOpInfo>,
    #[prost(uint32, tag = "2")]
    pub store_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketFinishStorePlayRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub trigger_env_event_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub store_income_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub trigger_npc_event_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub low_attr_store_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub round_total_income: u32,
    #[prost(uint32, tag = "7")]
    pub display_return_coin_b: u32,
    #[prost(uint32, tag = "8")]
    pub store_round: u32,
    #[prost(uint32, tag = "9")]
    pub round_coin_b_income: u32,
    #[prost(uint32, tag = "10")]
    pub round_delta_coin_c: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintagePresentFinishNotify {
    #[prost(uint32, tag = "1")]
    pub present_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21702)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreUnlockSlotReq {
    #[prost(uint32, tag = "1")]
    pub store_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreUnlockSlotRsp {
    #[prost(uint32, tag = "1")]
    pub store_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub slot_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24204)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreChooseStrategyReq {
    #[prost(uint32, repeated, tag = "1")]
    pub strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub store_op_list: ::prost::alloc::vec::Vec<VintageMarketStoreOpInfo>,
    #[prost(uint32, tag = "3")]
    pub store_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22603)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreChooseStrategyRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub store_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21506)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreViewStrategyReq {
    #[prost(uint32, repeated, tag = "1")]
    pub strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub strategy_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24403)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketStoreViewStrategyRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub strategy_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageMarketDividendFinishNotify {
    #[prost(uint32, tag = "1")]
    pub coin_c: u32,
    #[prost(uint32, tag = "2")]
    pub coin_a: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24902)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VintageMarketNpcEventFinishNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_strategy_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub coin_c: u32,
    #[prost(uint32, tag = "3")]
    pub coin_a: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindFieldDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<WindFieldStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindFieldStageInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindFieldRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindFieldRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusDetail {
    #[prost(bool, tag = "1")]
    pub is_cultivate: bool,
    #[prost(uint32, tag = "2")]
    pub name_id: u32,
    #[prost(uint32, tag = "3")]
    pub fungus_id: u32,
    #[prost(uint32, tag = "4")]
    pub capture_order: u32,
    #[prost(uint32, tag = "5")]
    pub min_cultivate_step: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusPlotStageDetail {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusTrainingDungeonDetail {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterMonsterDetail {
    #[prost(bool, tag = "1")]
    pub is_alive: bool,
    #[prost(uint32, tag = "2")]
    pub fungus_id: u32,
    #[prost(float, tag = "3")]
    pub cur_hp_percentage: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusTrainingMonsterPreviewDetail {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub monster_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusTrainingPoolPreviewDetail {
    #[prost(message, repeated, tag = "1")]
    pub monster_preview_detail_list: ::prost::alloc::vec::Vec<
        FungusTrainingMonsterPreviewDetail,
    >,
    #[prost(uint32, tag = "2")]
    pub pool_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusTrainingProgressDetail {
    #[prost(message, repeated, tag = "1")]
    pub monster_detail_list: ::prost::alloc::vec::Vec<FungusFighterMonsterDetail>,
    #[prost(uint32, repeated, tag = "2")]
    pub chosen_monster_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub backup_monster_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub monster_pool_preview_list: ::prost::alloc::vec::Vec<
        FungusTrainingPoolPreviewDetail,
    >,
    #[prost(uint32, tag = "5")]
    pub total_used_time: u32,
    #[prost(uint32, tag = "6")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "7")]
    pub cur_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub training_dungeon_progress_detail_list: ::prost::alloc::vec::Vec<
        FungusTrainingProgressDetail,
    >,
    #[prost(message, repeated, tag = "2")]
    pub plot_stage_detail_list: ::prost::alloc::vec::Vec<FungusPlotStageDetail>,
    #[prost(uint32, repeated, tag = "3")]
    pub finish_camp_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub training_dungeon_detail_list: ::prost::alloc::vec::Vec<
        FungusTrainingDungeonDetail,
    >,
    #[prost(uint32, repeated, tag = "5")]
    pub unlock_cultivate_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "6")]
    pub unlock_camp_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "7")]
    pub fungus_detail_list: ::prost::alloc::vec::Vec<FungusDetail>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20601)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterFungusFighterPlotDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub fungus_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22901)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterFungusFighterPlotDungeonRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub fungus_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21202)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterPlotInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub fungus_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24404)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusCultivateReq {
    #[prost(uint32, tag = "1")]
    pub time: u32,
    #[prost(uint32, tag = "2")]
    pub undo_step: u32,
    #[prost(uint32, tag = "3")]
    pub copy_step: u32,
    #[prost(uint32, tag = "4")]
    pub rotate_step: u32,
    #[prost(uint32, tag = "5")]
    pub place_step: u32,
    #[prost(uint32, tag = "6")]
    pub cultivate_id: u32,
    #[prost(uint32, tag = "7")]
    pub exchange_step: u32,
    #[prost(uint32, tag = "8")]
    pub cultivate_step: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusCultivateRsp {
    #[prost(uint32, tag = "1")]
    pub cultivate_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusRenameReq {
    #[prost(uint32, tag = "1")]
    pub fungus_id: u32,
    #[prost(uint32, tag = "2")]
    pub name_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusRenameRsp {
    #[prost(uint32, tag = "1")]
    pub fungus_id: u32,
    #[prost(uint32, tag = "2")]
    pub name_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterFungusFighterTrainingDungeonReq {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterFungusFighterTrainingDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20201)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterRuntimeDataNotify {
    #[prost(message, optional, tag = "1")]
    pub progress_detail: ::core::option::Option<FungusTrainingProgressDetail>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22303)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterTrainingSelectFungusReq {
    #[prost(uint32, repeated, tag = "1")]
    pub fight_fungus_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub backup_fungus_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterTrainingSelectFungusRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterTrainingGallerySettleNotify {
    #[prost(uint32, tag = "1")]
    pub dead_fungus_num: u32,
    #[prost(uint32, tag = "2")]
    pub total_used_time: u32,
    #[prost(enumeration = "GalleryStopReason", tag = "3")]
    pub reason: i32,
    #[prost(uint32, tag = "4")]
    pub settle_round: u32,
    #[prost(bool, tag = "5")]
    pub is_final_settle: bool,
    #[prost(bool, tag = "6")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "7")]
    pub final_score: u32,
    #[prost(uint32, tag = "8")]
    pub gadget_life_percentage: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterClearTrainingRuntimeDataReq {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterClearTrainingRuntimeDataRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24602)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterUseBackupFungusReq {
    #[prost(uint32, repeated, tag = "1")]
    pub backup_fungus_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21403)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterUseBackupFungusRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20004)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterRestartTrainingDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21601)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterRestartTrainingDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CharAmusementStageData {
    #[prost(uint32, tag = "1")]
    pub finish_time: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharAmusementDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_data_list: ::prost::alloc::vec::Vec<CharAmusementStageData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24603)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CharAmusementSettleNotify {
    #[prost(uint32, tag = "1")]
    pub finish_time: u32,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(bool, tag = "3")]
    pub is_succ: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2LevelData {
    #[prost(uint32, tag = "1")]
    pub challenge_mode_difficulty_pass: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_mode_last_choose_skill_no: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_mode_difficulty_open: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
    #[prost(bool, tag = "5")]
    pub is_level_open: bool,
    #[prost(uint32, tag = "6")]
    pub best_cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2DetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_data_list: ::prost::alloc::vec::Vec<EffigyChallengeV2LevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2EnterDungeonReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_mode_skill_no: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_mode_difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2EnterDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub challenge_mode_skill_no: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub challenge_mode_difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2RestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2RestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2ChooseSkillReq {
    #[prost(uint32, tag = "1")]
    pub challenge_mode_skill_no: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2ChooseSkillRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_mode_skill_no: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2DungeonInfoNotify {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub skill_no: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_mode_difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCollectTeamInfoData {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_lv_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub avatar_costume_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub player_uid: u32,
    #[prost(uint32, tag = "5")]
    pub choose_skill_no: u32,
    #[prost(bool, tag = "6")]
    pub is_host: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCollectLevelData {
    #[prost(message, repeated, tag = "1")]
    pub double_best_team_info_list: ::prost::alloc::vec::Vec<CoinCollectTeamInfoData>,
    #[prost(message, optional, tag = "2")]
    pub single_best_team_info: ::core::option::Option<CoinCollectTeamInfoData>,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub last_choose_skill_no: u32,
    #[prost(uint32, tag = "5")]
    pub single_best_pass_time_ms: u32,
    #[prost(uint32, tag = "6")]
    pub single_best_collect_num: u32,
    #[prost(bool, tag = "7")]
    pub is_have_play_double_level: bool,
    #[prost(bool, tag = "8")]
    pub is_level_open: bool,
    #[prost(bool, tag = "9")]
    pub is_have_watched_cutscene: bool,
    #[prost(bool, tag = "10")]
    pub is_have_play_single_level: bool,
    #[prost(uint32, tag = "11")]
    pub double_best_pass_time_ms: u32,
    #[prost(uint32, tag = "12")]
    pub double_best_collect_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCollectDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_data_list: ::prost::alloc::vec::Vec<CoinCollectLevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectChooseSkillReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub choose_skill_no: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectChooseSkillRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub choose_skill_no: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22702)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartCoinCollectPlaySingleModeReq {
    #[prost(uint32, tag = "1")]
    pub multistage_play_index: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartCoinCollectPlaySingleModeRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndCoinCollectPlaySingleModeReq {
    #[prost(uint32, tag = "1")]
    pub multistage_play_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21602)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndCoinCollectPlaySingleModeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectPrepareReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectPrepareRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectInterruptPlayReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectInterruptPlayRsp {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21603)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectCheckDoubleStartPlayReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectCheckDoubleStartPlayRsp {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerLevelInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub chosen_avatar_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub chosen_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub max_score: u32,
    #[prost(bool, tag = "5")]
    pub is_finish: bool,
    #[prost(bool, tag = "6")]
    pub is_can_start: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerActivityStageInfo {
    #[prost(bool, tag = "1")]
    pub is_world_level_unlock: bool,
    #[prost(bool, tag = "2")]
    pub is_dungeon_level_unlock: bool,
    #[prost(uint32, tag = "3")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<BrickBreakerActivityStageInfo>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub skill_info_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, repeated, tag = "3")]
    pub dungeon_level_info_list: ::prost::alloc::vec::Vec<BrickBreakerLevelInfo>,
    #[prost(message, repeated, tag = "4")]
    pub world_level_info_list: ::prost::alloc::vec::Vec<BrickBreakerLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleStartBrickBreakerReq {
    #[prost(uint32, repeated, tag = "1")]
    pub chosen_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub chosen_avatar_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_dungeon: bool,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SingleStartBrickBreakerRsp {
    #[prost(bool, tag = "1")]
    pub is_dungeon: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21404)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SingleRestartBrickBreakerReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(bool, tag = "2")]
    pub is_dungeon: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SingleRestartBrickBreakerRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_dungeon: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerSettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub update_skill_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub combo: u32,
    #[prost(uint32, tag = "4")]
    pub gallery_id: u32,
    #[prost(bool, tag = "5")]
    pub is_dungeon: bool,
    #[prost(bool, tag = "6")]
    pub is_single_mode: bool,
    #[prost(bool, tag = "7")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "8")]
    pub time: u32,
    #[prost(enumeration = "BrickBreakerSettleReason", tag = "9")]
    pub reason: i32,
    #[prost(uint32, tag = "10")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23602)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerTwiceStartReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerTwiceStartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24405)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerQuitReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20005)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerQuitRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampV3RaceLevelInfo {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub max_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampV3RaceInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<SeaLampV3RaceLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampV3ShadowLevelInfo {
    #[prost(uint32, tag = "1")]
    pub min_finish_time: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampV3ShadowStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<SeaLampV3ShadowLevelInfo>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampV3ShadowInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<SeaLampV3ShadowStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeaLampV3CampStageInfo {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(bool, tag = "3")]
    pub is_finished: bool,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampV3CampInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<SeaLampV3CampStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeaLampV3DetailInfo {
    #[prost(message, optional, tag = "1")]
    pub shadow_info: ::core::option::Option<SeaLampV3ShadowInfo>,
    #[prost(message, optional, tag = "2")]
    pub race_info: ::core::option::Option<SeaLampV3RaceInfo>,
    #[prost(message, optional, tag = "3")]
    pub camp_info: ::core::option::Option<SeaLampV3CampInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatGameStartSingleReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24702)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatGameStartSingleRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatGameTransferFinishNotify {
    #[prost(bool, tag = "1")]
    pub is_reenter: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3RaceSettleNotify {
    #[prost(uint32, tag = "1")]
    pub total_coin_count: u32,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(uint32, tag = "5")]
    pub coin_count: u32,
    #[prost(uint32, tag = "6")]
    pub level_id: u32,
    #[prost(uint32, tag = "7")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "8")]
    pub remain_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3RaceRestartReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3RaceRestartRsp {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatInterruptSettleStageReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23603)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatInterruptSettleStageRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3ShadowFinishLevelReq {
    #[prost(uint32, tag = "1")]
    pub finish_time: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3ShadowFinishLevelRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartLevelDifficultyInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub difficulty: u32,
    #[prost(uint32, tag = "3")]
    pub cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DuelHeartLevelInfo {
    #[prost(message, repeated, tag = "1")]
    pub difficulty_info_list: ::prost::alloc::vec::Vec<DuelHeartLevelDifficultyInfo>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_cg_viewed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DuelHeartDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<DuelHeartLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartEnterDungeonReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22606)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartSelectDifficultyReq {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartSelectDifficultyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartSettleNotify {
    #[prost(uint32, tag = "1")]
    pub cost_time: u32,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(bool, tag = "3")]
    pub is_succ: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartCgEndNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DuelHeartLevelInfoNotify {
    #[prost(bool, tag = "1")]
    pub is_need_play_cg: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainStageData {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_data_list: ::prost::alloc::vec::Vec<TeamChainStageData>,
    #[prost(bool, tag = "2")]
    pub is_token_costume_reward: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainChooseAvatarInfo {
    #[prost(bool, tag = "1")]
    pub is_trial_avatar: bool,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainChooseTeamInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_no_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<TeamChainChooseAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24703)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainEnterDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub team_info_list: ::prost::alloc::vec::Vec<TeamChainChooseTeamInfo>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24304)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainRestartDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub team_info_list: ::prost::alloc::vec::Vec<TeamChainChooseTeamInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21103)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainDungeonInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_no_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainTakeCostumeRewardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainTakeCostumeRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24606)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainReorganizeTeamReq {
    #[prost(uint64, repeated, tag = "1")]
    pub new_team_guid_list: ::prost::alloc::vec::Vec<u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TeamChainReorganizeTeamRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23106)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerNormalLuaShellNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub luashell: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23403)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerSecurityLuaShellNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub luashell: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24904)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerShellCodeLuaShellNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub luashell: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ElectroherculesBattleLevelInfo {
    #[prost(bool, tag = "1")]
    pub is_finish: bool,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub min_finish_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElectroherculesBattleStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<ElectroherculesBattleLevelInfo>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_stage_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElectroherculesBattleDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<ElectroherculesBattleStageInfo>,
    #[prost(bool, tag = "2")]
    pub is_pass_all_stage: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20006)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ElectroherculesBattleSelectDifficultyReq {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ElectroherculesBattleSelectDifficultyRsp {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub difficulty: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ElectroherculesBattleSettleNotify {
    #[prost(bool, tag = "1")]
    pub is_succ: bool,
    #[prost(bool, tag = "2")]
    pub is_activity_finish: bool,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(uint32, tag = "5")]
    pub finish_time: u32,
    #[prost(uint32, tag = "6")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "7")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgFestivalDetailInfo {
    #[prost(bool, tag = "1")]
    pub is_gcg_festival_mode_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairV2DetailInfo {
    #[prost(message, optional, tag = "1")]
    pub photo_info: ::core::option::Option<FleurFairV2PhotoInfo>,
    #[prost(message, optional, tag = "2")]
    pub music_game_info: ::core::option::Option<FleurFairV2MusicGameInfo>,
    #[prost(message, optional, tag = "3")]
    pub pacman_info: ::core::option::Option<FleurFairV2PacmanInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PhotoPosData {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub open_time: u32,
    #[prost(bool, tag = "3")]
    pub is_view: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
    #[prost(uint32, tag = "5")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairV2PhotoInfo {
    #[prost(message, repeated, tag = "1")]
    pub photo_pos_data_list: ::prost::alloc::vec::Vec<FleurFairV2PhotoPosData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PhotoActivityFinishReq {
    #[prost(uint32, tag = "1")]
    pub check_root_id: u32,
    #[prost(bool, tag = "2")]
    pub is_succ: bool,
    #[prost(uint32, tag = "3")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PhotoActivityFinishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PhotoActivityClientViewReq {
    #[prost(uint32, tag = "1")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PhotoActivityClientViewRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub pos_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairV2MusicGameInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub music_game_record_map: ::std::collections::HashMap<u32, MusicGameRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20007)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairV2MusicGameSettleReq {
    #[prost(uint32, repeated, tag = "1")]
    pub note_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub button_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub correct_hit: u32,
    #[prost(float, tag = "4")]
    pub speed: f32,
    #[prost(uint32, tag = "5")]
    pub score: u32,
    #[prost(bool, tag = "6")]
    pub is_custom_speed: bool,
    #[prost(bool, tag = "7")]
    pub is_save_score: bool,
    #[prost(bool, tag = "8")]
    pub is_custom_delay: bool,
    #[prost(uint32, tag = "9")]
    pub max_combo: u32,
    #[prost(uint32, tag = "10")]
    pub volume: u32,
    #[prost(uint32, tag = "11")]
    pub score_rating: u32,
    #[prost(uint32, tag = "12")]
    pub is_full_combo: u32,
    #[prost(uint32, tag = "13")]
    pub delay: u32,
    #[prost(uint32, tag = "14")]
    pub combo: u32,
    #[prost(uint32, tag = "15")]
    pub music_basic_id: u32,
    #[prost(uint32, tag = "16")]
    pub restart_times: u32,
    #[prost(uint32, tag = "17")]
    pub star_rating: u32,
    #[prost(uint64, tag = "18")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2MusicGameSettleRsp {
    #[prost(bool, tag = "1")]
    pub is_new_record: bool,
    #[prost(bool, tag = "2")]
    pub is_unlock_next_level: bool,
    #[prost(uint32, tag = "3")]
    pub music_basic_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint64, tag = "5")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2MusicGameStartReq {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_save_score: bool,
    #[prost(uint32, tag = "3")]
    pub music_basic_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2MusicGameStartRsp {
    #[prost(uint32, tag = "1")]
    pub music_basic_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairV2PacmanInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_data_list: ::prost::alloc::vec::Vec<PacmanStageData>,
    #[prost(uint32, tag = "2")]
    pub map_rotate_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PacmanStageData {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub best_score: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PacmanRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PacmanRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PacmanSetMapRotateTypeReq {
    #[prost(uint32, tag = "1")]
    pub map_rotate_type: u32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PacmanSetMapRotateTypeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2LevelData {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub best_cost_time: u32,
    #[prost(bool, tag = "3")]
    pub is_level_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterV2DetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_data_list: ::prost::alloc::vec::Vec<FungusFighterV2LevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24503)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungusFighterV2EnterDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub choose_fungus_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23107)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2EnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20008)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2RestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24706)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2RestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2StartGalleryReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2StartGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesArchitectLevelInfo {
    #[prost(uint32, tag = "1")]
    pub min_finish_cost: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
    #[prost(bool, tag = "4")]
    pub is_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesArchitectInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<AkaFesArchitectLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesArchaeologyStageInfo {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesArchaeologyInfo {
    #[prost(message, repeated, tag = "1")]
    pub stage_info_list: ::prost::alloc::vec::Vec<AkaFesArchaeologyStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmLevelInfo {
    #[prost(uint32, tag = "1")]
    pub best_score: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_finish: bool,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<AkaFesRhythmLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesReasoningLevelInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub unlocked_keyword_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub asked_question_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub asked_times: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesReasoningInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<AkaFesReasoningLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesAstrolabeLevelInfo {
    #[prost(uint32, tag = "1")]
    pub min_finish_time: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesAstrolabeInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<AkaFesAstrolabeLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesPotionLevelInfo {
    #[prost(uint32, tag = "1")]
    pub min_finish_time: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub max_difficulty_level: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesPotionInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<AkaFesPotionLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub potion_info: ::core::option::Option<AkaFesPotionInfo>,
    #[prost(message, optional, tag = "2")]
    pub rhythm_info: ::core::option::Option<AkaFesRhythmInfo>,
    #[prost(message, optional, tag = "3")]
    pub archaeology_info: ::core::option::Option<AkaFesArchaeologyInfo>,
    #[prost(message, optional, tag = "4")]
    pub architect_info: ::core::option::Option<AkaFesArchitectInfo>,
    #[prost(message, optional, tag = "5")]
    pub astrolabe_info: ::core::option::Option<AkaFesAstrolabeInfo>,
    #[prost(message, optional, tag = "6")]
    pub reasoning_info: ::core::option::Option<AkaFesReasoningInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesArchitectDungeonBlockInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub block_id: u32,
    #[prost(uint32, tag = "4")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21508)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterAkaFesArchitectDungeonReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterAkaFesArchitectDungeonRsp {
    #[prost(message, repeated, tag = "1")]
    pub block_info_list: ::prost::alloc::vec::Vec<AkaFesArchitectDungeonBlockInfo>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21105)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveAkaFesArchitectDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub block_info_list: ::prost::alloc::vec::Vec<AkaFesArchitectDungeonBlockInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SaveAkaFesArchitectDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20403)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryAkaFesArchitectDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryAkaFesArchitectDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitAkaFesArchitectDungeonTryReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitAkaFesArchitectDungeonTryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutStuckAkaFesArchitectDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutStuckAkaFesArchitectDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20304)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesArchitectDungeonRecoverNotify {
    #[prost(message, repeated, tag = "1")]
    pub block_info_list: ::prost::alloc::vec::Vec<AkaFesArchitectDungeonBlockInfo>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_in_play: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesArchitectSuccNotify {
    #[prost(bool, tag = "1")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "2")]
    pub cost: u32,
    #[prost(uint32, tag = "3")]
    pub target_check_point_count: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
    #[prost(uint32, tag = "5")]
    pub pass_check_point_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23108)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmStartPlayReq {
    #[prost(bool, tag = "1")]
    pub is_adjust: bool,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21106)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmStartPlayRsp {
    #[prost(string, tag = "1")]
    pub transaction: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20602)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmFinishPlayReq {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmFinishPlayRsp {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22607)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmEnterDungeonReq {
    #[prost(bool, tag = "1")]
    pub is_adjust: bool,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23404)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmDungeonRestartReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23405)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesRhythmDungeonRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesReasoningChooseQuestionReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub question_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20404)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesReasoningChooseQuestionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesReasoningFinishLevelReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20603)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesReasoningFinishLevelRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesAstrolabeFinishLevelReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub finish_time_cost: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesAstrolabeFinishLevelRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22004)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterAkaFesPotionDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub negative_factor_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub positive_factor_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub difficulty_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterAkaFesPotionDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartAkaFesPotionDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartAkaFesPotionDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AkaFesPotionDungeonInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub positive_factor_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub negative_factor_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AkaFesPotionDungeonSettleNotify {
    #[prost(uint32, tag = "1")]
    pub cost_time: u32,
    #[prost(uint32, tag = "2")]
    pub difficulty_level: u32,
    #[prost(bool, tag = "3")]
    pub is_succ: bool,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "5")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SandwormCannonLevelData {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(enumeration = "SandwormLevelStateType", tag = "2")]
    pub level_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandwormCannonDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub sandworm_cannon_info: ::prost::alloc::vec::Vec<SandwormCannonLevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21509)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SandwormCannonStartGalleryReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SandwormCannonStartGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SandwormCannonActivitySettleNotify {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(int32, tag = "2")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ljihgbompmi {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24906)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Jeapgnohboi {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SorushTrialDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_photo_match_level_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub unlock_race_level_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub unlock_hitman_level_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub kmflcegigcl: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24607)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialStartGalleryReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialStartGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(int32, tag = "2")]
    pub gallery_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialQuitGalleryReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialQuitGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23109)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialFinishPhotoMatchGalleryReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialFinishPhotoMatchGalleryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4LevelDataInfo {
    #[prost(uint32, tag = "1")]
    pub cost_time: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub max_score: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4DetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_data_info_list: ::prost::alloc::vec::Vec<EffigyChallengeV4LevelDataInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4LevelInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub condition_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21604)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4SelectDifficultyReq {
    #[prost(message, optional, tag = "1")]
    pub level_info: ::core::option::Option<EffigyChallengeV4LevelInfo>,
    #[prost(bool, tag = "2")]
    pub is_single_start: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23004)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4SelectDifficultyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4AvatarInfo {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(uint32, tag = "2")]
    pub costume_id: u32,
    #[prost(uint32, tag = "3")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4PlayerInfo {
    #[prost(message, repeated, tag = "1")]
    pub backup_avatar_info: ::prost::alloc::vec::Vec<EffigyChallengeV4AvatarInfo>,
    #[prost(message, repeated, tag = "2")]
    pub selected_avatar_info: ::prost::alloc::vec::Vec<EffigyChallengeV4AvatarInfo>,
    #[prost(enumeration = "EffigyChallengeV4PrepareState", tag = "3")]
    pub prepare_state: i32,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21802)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4PrepareNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<EffigyChallengeV4PlayerInfo>,
    #[prost(message, optional, tag = "2")]
    pub level_info: ::core::option::Option<EffigyChallengeV4LevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21510)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4SyncPrepareStateReq {
    #[prost(enumeration = "EffigyChallengeV4PrepareState", tag = "1")]
    pub new_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24305)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4SyncPrepareStateRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21004)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4SelectAvatarReq {
    #[prost(uint64, repeated, tag = "1")]
    pub backup_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, tag = "2")]
    pub selected_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23606)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4SelectAvatarRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4EnterDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23305)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4EnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4CancelPrepareReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20706)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4CancelPrepareRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4PrepareEndNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24907)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4DungeonInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub level_info: ::core::option::Option<EffigyChallengeV4LevelInfo>,
    #[prost(uint32, tag = "2")]
    pub round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24104)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4ChangingAvatarNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<EffigyChallengeV4PlayerInfo>,
    #[prost(message, optional, tag = "2")]
    pub level_info: ::core::option::Option<EffigyChallengeV4LevelInfo>,
    #[prost(uint32, tag = "3")]
    pub round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4ChangeAvatarFinishReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4ChangeAvatarFinishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4DungeonSettleNotify {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub cost_time: u32,
    #[prost(uint32, tag = "3")]
    pub score: u32,
    #[prost(bool, tag = "4")]
    pub is_succ: bool,
    #[prost(bool, tag = "5")]
    pub is_new_record: bool,
    #[prost(bool, tag = "6")]
    pub is_new_time_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4RestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4RestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24608)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4InviteRestartDungeonNotify {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21511)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4ReplyInviteRestartDungeonReq {
    #[prost(bool, tag = "1")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20009)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4ReplyInviteRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4RestartDungeonEndNotify {
    #[prost(enumeration = "EffigyChallengeV4RestartDungeonEndReason", tag = "1")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24908)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV4ChangeAvatarFinishNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyDiceDungeonLevelInfo {
    #[prost(uint64, repeated, tag = "1")]
    pub last_team_info_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub max_score: u32,
    #[prost(uint32, tag = "4")]
    pub last_difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyDiceDungeonInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<JourneyDiceDungeonLevelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneySealInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub finish_seal_challenge_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub finish_seal_seek_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub unlock_seal_stage_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyGearLevelData {
    #[prost(bool, tag = "1")]
    pub is_finish: bool,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub shortest_time: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyGearInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_info_list: ::prost::alloc::vec::Vec<JourneyGearLevelData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyPickInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub invited_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyDetailInfo {
    #[prost(message, optional, tag = "1")]
    pub journey_dice_dungeon_info: ::core::option::Option<JourneyDiceDungeonInfo>,
    #[prost(message, optional, tag = "2")]
    pub journey_gear_info: ::core::option::Option<JourneyGearInfo>,
    #[prost(message, optional, tag = "3")]
    pub journey_gcg_info: ::core::option::Option<JourneyPickInfo>,
    #[prost(message, optional, tag = "4")]
    pub journey_seal_info: ::core::option::Option<JourneySealInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20205)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyDiceEnterDungeonReq {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "2")]
    pub difficulty: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyDiceEnterDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21906)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyDiceDungeonUseBuffNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub buff_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyDiceDungeonSettleNotify {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "3")]
    pub score: u32,
    #[prost(uint32, tag = "4")]
    pub kill_normal_monster_num: u32,
    #[prost(uint32, tag = "5")]
    pub difficulty: u32,
    #[prost(uint32, tag = "6")]
    pub kill_elite_monster_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneySealSeekFinishReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub seal_seek_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneySealSeekFinishRsp {
    #[prost(uint32, tag = "1")]
    pub seal_seek_id: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyShaftState {
    #[prost(bool, tag = "1")]
    pub is_has_gear: bool,
    #[prost(uint32, tag = "2")]
    pub template_id: u32,
    #[prost(uint32, tag = "3")]
    pub shaft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyBaseplateState {
    #[prost(float, tag = "1")]
    pub y_pos: f32,
    #[prost(uint32, tag = "2")]
    pub baseplate_id: u32,
    #[prost(float, tag = "3")]
    pub x_pos: f32,
    #[prost(uint32, tag = "4")]
    pub rot: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24909)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyFinishPlayGearReq {
    #[prost(message, repeated, tag = "1")]
    pub baseplate_state: ::prost::alloc::vec::Vec<JourneyBaseplateState>,
    #[prost(message, repeated, tag = "2")]
    pub shaft_state: ::prost::alloc::vec::Vec<JourneyShaftState>,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub reset_num: u32,
    #[prost(uint32, tag = "5")]
    pub baseplate_hint_num: u32,
    #[prost(uint32, tag = "6")]
    pub gear_hint_num: u32,
    #[prost(bool, tag = "7")]
    pub is_success: bool,
    #[prost(uint32, tag = "8")]
    pub cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyFinishPlayGearRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub cost_time: u32,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23307)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JourneyStartPickGameReq {
    #[prost(uint32, repeated, tag = "1")]
    pub pick_group_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20506)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyStartPickGameRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyDiceRestartDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20708)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyDiceRestartDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24609)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyInvitePickGameReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21804)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyInvitePickGameRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgpveLevelDataInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub max_score: u32,
    #[prost(uint32, tag = "3")]
    pub game_id: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgpveDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub level_data_list: ::prost::alloc::vec::Vec<GcgpveLevelDataInfo>,
    #[prost(bool, tag = "2")]
    pub is_gcg_pve_mode_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22505)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgpveStartGameReq {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub game_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgpveStartGameRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcV2OfficialLevelData {
    #[prost(uint64, tag = "1")]
    pub level_guid: u64,
    #[prost(uint32, tag = "2")]
    pub best_score: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(bool, tag = "4")]
    pub is_level_open: bool,
    #[prost(bool, tag = "5")]
    pub is_finished: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcV2DetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub official_level_data_list: ::prost::alloc::vec::Vec<UgcV2OfficialLevelData>,
    #[prost(bool, tag = "2")]
    pub is_custom_edit_open: bool,
    #[prost(bool, tag = "3")]
    pub is_template_import_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AranaraCollectionSuite {
    #[prost(map = "uint32, enumeration(AranaraCollectionState)", tag = "1")]
    pub collection_id_state_map: ::std::collections::HashMap<u32, i32>,
    #[prost(uint32, tag = "2")]
    pub collection_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AranaraCollectionDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub collection_suite_list: ::prost::alloc::vec::Vec<AranaraCollectionSuite>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddAranaraCollectionNotify {
    #[prost(enumeration = "AranaraCollectionState", tag = "1")]
    pub from_state: i32,
    #[prost(uint32, tag = "2")]
    pub collection_type: u32,
    #[prost(uint32, tag = "3")]
    pub collection_id: u32,
    #[prost(enumeration = "AranaraCollectionState", tag = "4")]
    pub target_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CataLogGlobalWatcherFinishedData {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_global_watcher_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub catalog_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6303)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CataLogFinishedGlobalWatcherAllDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub finished_global_watcher_data_list: ::prost::alloc::vec::Vec<
        CataLogGlobalWatcherFinishedData,
    >,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6304)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CataLogNewFinishedGlobalWatcherNotify {
    #[prost(message, repeated, tag = "1")]
    pub new_finished_global_watcher_data_list: ::prost::alloc::vec::Vec<
        CataLogGlobalWatcherFinishedData,
    >,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarAddNotify {
    #[prost(message, optional, tag = "1")]
    pub avatar: ::core::option::Option<AvatarInfo>,
    #[prost(bool, tag = "2")]
    pub is_in_team: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarDelNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarTeam {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, tag = "2")]
    pub team_name: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1601)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUpAvatarTeamReq {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
    #[prost(uint32, tag = "3")]
    pub team_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1602)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUpAvatarTeamRsp {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub team_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChooseCurAvatarTeamReq {
    #[prost(uint32, tag = "1")]
    pub team_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1603)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChooseCurAvatarTeamRsp {
    #[prost(uint32, tag = "1")]
    pub cur_team_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeAvatarReq {
    #[prost(message, optional, tag = "1")]
    pub move_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
    #[prost(bool, tag = "3")]
    pub is_move: bool,
    #[prost(uint64, tag = "4")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeAvatarRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
    #[prost(uint64, tag = "3")]
    pub cur_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarPromoteReq {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarPromoteRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1706)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpringUseReq {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpringUseRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1708)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RefreshBackgroundAvatarReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1606)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshBackgroundAvatarRsp {
    #[prost(map = "uint64, uint32", tag = "1")]
    pub hp_full_time_map: ::std::collections::HashMap<u64, u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1607)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarTeamUpdateNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub avatar_team_map: ::std::collections::HashMap<u32, AvatarTeam>,
    #[prost(uint64, repeated, tag = "2")]
    pub temp_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1709)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub owned_costume_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, repeated, tag = "2")]
    pub temp_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "3")]
    pub avatar_list: ::prost::alloc::vec::Vec<AvatarInfo>,
    #[prost(uint32, repeated, tag = "4")]
    pub owned_flycloak_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub backup_avatar_team_order_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "6")]
    pub avatar_rename_list: ::prost::alloc::vec::Vec<AvatarRenameInfo>,
    #[prost(map = "uint32, message", tag = "7")]
    pub avatar_team_map: ::std::collections::HashMap<u32, AvatarTeam>,
    #[prost(uint32, tag = "8")]
    pub cur_avatar_team_id: u32,
    #[prost(uint64, tag = "9")]
    pub choose_avatar_guid: u64,
    #[prost(uint32, repeated, tag = "10")]
    pub owned_trace_effect_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1608)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarUpgradeReq {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1609)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarUpgradeRsp {
    #[prost(map = "uint32, float", tag = "1")]
    pub cur_fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(map = "uint32, float", tag = "2")]
    pub old_fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "4")]
    pub cur_level: u32,
    #[prost(uint32, tag = "5")]
    pub old_level: u32,
    #[prost(int32, tag = "6")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1610)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarDieAnimationEndReq {
    #[prost(message, optional, tag = "1")]
    pub reborn_pos: ::core::option::Option<Vector>,
    #[prost(uint64, tag = "2")]
    pub die_guid: u64,
    #[prost(uint32, tag = "3")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1611)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarDieAnimationEndRsp {
    #[prost(uint64, tag = "1")]
    pub die_guid: u64,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1612)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeElementTypeReq {
    #[prost(uint32, tag = "1")]
    pub area_id: u32,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1710)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeElementTypeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1711)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarFetterDataNotify {
    #[prost(map = "uint64, message", tag = "1")]
    pub fetter_info_map: ::std::collections::HashMap<u64, AvatarFetterInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1613)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionDataNotify {
    #[prost(map = "uint64, message", tag = "1")]
    pub expedition_info_map: ::std::collections::HashMap<u64, AvatarExpeditionInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1614)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionAllDataReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1712)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionAllDataRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub open_expedition_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint64, message", tag = "2")]
    pub expedition_info_map: ::std::collections::HashMap<u64, AvatarExpeditionInfo>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub expedition_count_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1615)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionStartReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub exp_id: u32,
    #[prost(uint32, tag = "3")]
    pub hour_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1616)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionStartRsp {
    #[prost(map = "uint64, message", tag = "1")]
    pub expedition_info_map: ::std::collections::HashMap<u64, AvatarExpeditionInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1713)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionCallBackReq {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid: ::prost::alloc::vec::Vec<u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1714)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionCallBackRsp {
    #[prost(map = "uint64, message", tag = "1")]
    pub expedition_info_map: ::std::collections::HashMap<u64, AvatarExpeditionInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1617)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionGetRewardReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1715)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionGetRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub extra_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(map = "uint64, message", tag = "2")]
    pub expedition_info_map: ::std::collections::HashMap<u64, AvatarExpeditionInfo>,
    #[prost(message, repeated, tag = "3")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1618)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeMpTeamAvatarReq {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1619)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeMpTeamAvatarRsp {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1620)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeTeamNameReq {
    #[prost(string, tag = "1")]
    pub team_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub team_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1621)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeTeamNameRsp {
    #[prost(string, tag = "1")]
    pub team_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub team_id: i32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneTeamAvatar {
    #[prost(message, optional, tag = "1")]
    pub scene_avatar_info: ::core::option::Option<SceneAvatarInfo>,
    #[prost(message, optional, tag = "2")]
    pub ability_control_block: ::core::option::Option<AbilityControlBlock>,
    #[prost(message, optional, tag = "3")]
    pub avatar_info: ::core::option::Option<AvatarInfo>,
    #[prost(message, optional, tag = "4")]
    pub weapon_ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(message, optional, tag = "5")]
    pub scene_entity_info: ::core::option::Option<SceneEntityInfo>,
    #[prost(message, repeated, tag = "6")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(message, optional, tag = "7")]
    pub avatar_ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(uint64, tag = "8")]
    pub weapon_guid: u64,
    #[prost(uint32, tag = "9")]
    pub scene_id: u32,
    #[prost(uint32, tag = "10")]
    pub weapon_entity_id: u32,
    #[prost(uint32, tag = "11")]
    pub player_uid: u32,
    #[prost(uint32, tag = "12")]
    pub entity_id: u32,
    #[prost(uint64, tag = "13")]
    pub avatar_guid: u64,
    #[prost(bool, tag = "14")]
    pub is_on_scene: bool,
    #[prost(bool, tag = "15")]
    pub is_reconnect: bool,
    #[prost(bool, tag = "16")]
    pub is_player_cur_avatar: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1622)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneTeamUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub scene_team_avatar_list: ::prost::alloc::vec::Vec<SceneTeamAvatar>,
    #[prost(bool, tag = "2")]
    pub is_in_mp: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1623)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FocusAvatarReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_focus: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1716)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FocusAvatarRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_focus: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarSatiationData {
    #[prost(float, tag = "1")]
    pub penalty_finish_time: f32,
    #[prost(float, tag = "2")]
    pub finish_time: f32,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1717)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarSatiationDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub satiation_data_list: ::prost::alloc::vec::Vec<AvatarSatiationData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1718)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarWearFlycloakReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub flycloak_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1719)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarWearFlycloakRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub flycloak_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1624)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarFlycloakChangeNotify {
    #[prost(uint32, tag = "1")]
    pub flycloak_id: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1625)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarGainFlycloakNotify {
    #[prost(uint32, tag = "1")]
    pub flycloak_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1626)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarEquipAffixStartNotify {
    #[prost(message, optional, tag = "1")]
    pub equip_affix_info: ::core::option::Option<AvatarEquipAffixInfo>,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1627)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarFetterLevelRewardReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub fetter_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1720)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarFetterLevelRewardRsp {
    #[prost(uint32, tag = "1")]
    pub reward_id: u32,
    #[prost(uint32, tag = "2")]
    pub fetter_level: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint64, tag = "4")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddNoGachaAvatarCardTransferItem {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(bool, tag = "2")]
    pub is_new: bool,
    #[prost(uint32, tag = "3")]
    pub item_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1721)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddNoGachaAvatarCardNotify {
    #[prost(message, repeated, tag = "1")]
    pub transfer_item_list: ::prost::alloc::vec::Vec<AddNoGachaAvatarCardTransferItem>,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "3")]
    pub initial_promote_level: u32,
    #[prost(bool, tag = "4")]
    pub is_transfer_to_item: bool,
    #[prost(uint32, tag = "5")]
    pub reason: u32,
    #[prost(uint32, tag = "6")]
    pub item_id: u32,
    #[prost(uint32, tag = "7")]
    pub initial_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1628)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarPromoteGetRewardReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub promote_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1722)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarPromoteGetRewardRsp {
    #[prost(uint32, tag = "1")]
    pub promote_level: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "3")]
    pub reward_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1629)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeCostumeReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1630)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeCostumeRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1723)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarChangeCostumeNotify {
    #[prost(message, optional, tag = "1")]
    pub entity_info: ::core::option::Option<SceneEntityInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1631)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarGainCostumeNotify {
    #[prost(uint32, tag = "1")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1724)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeAnimHashReq {
    #[prost(uint32, tag = "1")]
    pub anim_hash: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1725)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeAnimHashRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub anim_hash: u32,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1632)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentDungeonSwitchAvatarReq {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1633)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentDungeonSwitchAvatarRsp {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1634)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddBackupAvatarTeamReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1635)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddBackupAvatarTeamRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1636)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelBackupAvatarTeamReq {
    #[prost(uint32, tag = "1")]
    pub backup_avatar_team_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1726)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelBackupAvatarTeamRsp {
    #[prost(uint32, tag = "1")]
    pub backup_avatar_team_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1727)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarTeamAllDataNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub temp_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, tag = "2")]
    pub backup_avatar_team_order_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, message", tag = "3")]
    pub avatar_team_map: ::std::collections::HashMap<u32, AvatarTeam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarRenameInfo {
    #[prost(string, tag = "1")]
    pub avatar_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1728)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarRenameInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub avatar_rename_list: ::prost::alloc::vec::Vec<AvatarRenameInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1637)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemRenameAvatarReq {
    #[prost(string, tag = "1")]
    pub avatar_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub rename_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1729)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ItemRenameAvatarRsp {
    #[prost(uint32, tag = "1")]
    pub cd_time: u32,
    #[prost(uint32, tag = "2")]
    pub rename_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1730)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Kjeieehcgeb {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1731)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Emdobldmbpf {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1732)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MirrorAvatarDataUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub avatar_list: ::prost::alloc::vec::Vec<AvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1733)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarChangeTraceEffectNotify {
    #[prost(message, optional, tag = "1")]
    pub entity_info: ::core::option::Option<SceneEntityInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1734)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeTraceEffectReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub trace_effect_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1735)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarChangeTraceEffectRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "3")]
    pub trace_effect_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BattlePassCycle {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
    #[prost(uint32, tag = "2")]
    pub cycle_idx: u32,
    #[prost(uint32, tag = "3")]
    pub begin_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BattlePassMission {
    #[prost(uint32, tag = "1")]
    pub mission_type: u32,
    #[prost(uint32, tag = "2")]
    pub total_progress: u32,
    #[prost(uint32, tag = "3")]
    pub cur_progress: u32,
    #[prost(uint32, tag = "4")]
    pub reward_battle_pass_point: u32,
    #[prost(uint32, tag = "5")]
    pub mission_id: u32,
    #[prost(enumeration = "MissionStatus", tag = "6")]
    pub mission_status: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BattlePassRewardTag {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
    #[prost(enumeration = "BattlePassUnlockStatus", tag = "3")]
    pub unlock_status: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassProduct {
    #[prost(string, tag = "1")]
    pub extra_product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub normal_product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub upgrade_product_id: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassSchedule {
    #[prost(message, optional, tag = "1")]
    pub product_info: ::core::option::Option<BattlePassProduct>,
    #[prost(message, repeated, tag = "2")]
    pub reward_taken_list: ::prost::alloc::vec::Vec<BattlePassRewardTag>,
    #[prost(message, optional, tag = "3")]
    pub cur_cycle: ::core::option::Option<BattlePassCycle>,
    #[prost(uint32, tag = "4")]
    pub begin_time: u32,
    #[prost(uint32, tag = "5")]
    pub paid_platform_flags: u32,
    #[prost(uint32, tag = "6")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "7")]
    pub point: u32,
    #[prost(uint32, tag = "8")]
    pub end_time: u32,
    #[prost(bool, tag = "9")]
    pub is_viewed: bool,
    #[prost(bool, tag = "10")]
    pub is_extra_paid_reward_taken: bool,
    #[prost(uint32, tag = "11")]
    pub level: u32,
    #[prost(uint32, tag = "12")]
    pub cur_cycle_points: u32,
    #[prost(enumeration = "BattlePassUnlockStatus", tag = "13")]
    pub unlock_status: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2607)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassAllDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub mission_list: ::prost::alloc::vec::Vec<BattlePassMission>,
    #[prost(message, optional, tag = "2")]
    pub cur_schedule: ::core::option::Option<BattlePassSchedule>,
    #[prost(bool, tag = "3")]
    pub have_cur_schedule: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2608)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassMissionUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub mission_list: ::prost::alloc::vec::Vec<BattlePassMission>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2609)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassMissionDelNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub del_mission_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2610)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassCurScheduleUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub cur_schedule: ::core::option::Option<BattlePassSchedule>,
    #[prost(bool, tag = "2")]
    pub have_cur_schedule: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BattlePassRewardTakeOption {
    #[prost(message, optional, tag = "1")]
    pub tag: ::core::option::Option<BattlePassRewardTag>,
    #[prost(uint32, tag = "2")]
    pub option_idx: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2611)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeBattlePassRewardReq {
    #[prost(message, repeated, tag = "1")]
    pub take_option_list: ::prost::alloc::vec::Vec<BattlePassRewardTakeOption>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2612)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeBattlePassRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub take_option_list: ::prost::alloc::vec::Vec<BattlePassRewardTakeOption>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2613)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeBattlePassMissionPointReq {
    #[prost(uint32, repeated, tag = "1")]
    pub mission_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2614)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeBattlePassMissionPointRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub mission_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2615)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBattlePassProductReq {
    #[prost(uint32, tag = "1")]
    pub battle_pass_product_play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2616)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBattlePassProductRsp {
    #[prost(string, tag = "1")]
    pub price_tier: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub cur_schedule_id: u32,
    #[prost(uint32, tag = "5")]
    pub battle_pass_product_play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2617)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetBattlePassViewedReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2618)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetBattlePassViewedRsp {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2619)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassBuySuccNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "3")]
    pub add_point: u32,
    #[prost(uint32, tag = "4")]
    pub product_play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2620)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuyBattlePassLevelReq {
    #[prost(uint32, tag = "1")]
    pub buy_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2621)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuyBattlePassLevelRsp {
    #[prost(uint32, tag = "1")]
    pub buy_level: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlossomBriefInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
    #[prost(uint32, tag = "3")]
    pub reward_id: u32,
    #[prost(uint32, tag = "4")]
    pub monster_level: u32,
    #[prost(uint32, tag = "5")]
    pub state: u32,
    #[prost(uint32, tag = "6")]
    pub refresh_id: u32,
    #[prost(uint32, tag = "7")]
    pub circle_camp_id: u32,
    #[prost(uint32, tag = "8")]
    pub scene_id: u32,
    #[prost(bool, tag = "9")]
    pub is_guide_opened: bool,
    #[prost(uint32, tag = "10")]
    pub resin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlossomBriefInfoListReq {
    #[prost(uint32, repeated, tag = "1")]
    pub city_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlossomBriefInfoListRsp {
    #[prost(message, repeated, tag = "1")]
    pub brief_info_list: ::prost::alloc::vec::Vec<BlossomBriefInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2703)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlossomBriefInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub brief_info_list: ::prost::alloc::vec::Vec<BlossomBriefInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2704)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldOwnerBlossomBriefInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub brief_info_list: ::prost::alloc::vec::Vec<BlossomBriefInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlossomScheduleInfo {
    #[prost(uint32, tag = "1")]
    pub progress: u32,
    #[prost(uint32, tag = "2")]
    pub finish_progress: u32,
    #[prost(uint32, tag = "3")]
    pub circle_camp_id: u32,
    #[prost(uint32, tag = "4")]
    pub round: u32,
    #[prost(uint32, tag = "5")]
    pub state: u32,
    #[prost(uint32, tag = "6")]
    pub refresh_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldOwnerBlossomScheduleInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub schedule_info: ::core::option::Option<BlossomScheduleInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2706)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlossomChestCreateNotify {
    #[prost(uint32, tag = "1")]
    pub circle_camp_id: u32,
    #[prost(uint32, tag = "2")]
    pub refresh_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2707)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenBlossomCircleCampGuideNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub circle_camp_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub refresh_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5001)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateChatReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(oneof = "private_chat_req::Content", tags = "2, 3")]
    pub content: ::core::option::Option<private_chat_req::Content>,
}
/// Nested message and enum types in `PrivateChatReq`.
pub mod private_chat_req {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
        #[prost(uint32, tag = "3")]
        Icon(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrivateChatRsp {
    #[prost(uint32, tag = "1")]
    pub chat_forbidden_endtime: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4901)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateChatNotify {
    #[prost(message, optional, tag = "1")]
    pub chat_info: ::core::option::Option<ChatInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PullPrivateChatReq {
    #[prost(uint32, tag = "1")]
    pub from_sequence: u32,
    #[prost(uint32, tag = "2")]
    pub pull_num: u32,
    #[prost(uint32, tag = "3")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5003)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullPrivateChatRsp {
    #[prost(message, repeated, tag = "1")]
    pub chat_info: ::prost::alloc::vec::Vec<ChatInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PullRecentChatReq {
    #[prost(uint32, tag = "1")]
    pub pull_num: u32,
    #[prost(uint32, tag = "2")]
    pub begin_sequence: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5004)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRecentChatRsp {
    #[prost(message, repeated, tag = "1")]
    pub chat_info: ::prost::alloc::vec::Vec<ChatInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadPrivateChatReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5005)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadPrivateChatRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5006)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChatChannelUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub channel_info: ::core::option::Option<ChatChannelInfo>,
    #[prost(bool, tag = "2")]
    pub is_create: bool,
    #[prost(uint32, tag = "3")]
    pub channel_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChatChannelInfo {
    #[prost(bool, tag = "1")]
    pub is_shield: bool,
    #[prost(uint32, tag = "2")]
    pub channel_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4905)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatChannelDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub channel_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub channel_info_list: ::prost::alloc::vec::Vec<ChatChannelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4906)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChatChannelShieldNotify {
    #[prost(uint32, tag = "1")]
    pub channel_id: u32,
    #[prost(bool, tag = "2")]
    pub is_shield: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5007)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChatChannelInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub channel_info: ::core::option::Option<ChatChannelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodexTypeData {
    #[prost(bool, repeated, tag = "1")]
    pub have_viewed_list: ::prost::alloc::vec::Vec<bool>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub weapon_max_promote_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub codex_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "CodexType", tag = "4")]
    pub r#type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4201)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodexDataFullNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub recent_viewed_pushtips_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub type_data_list: ::prost::alloc::vec::Vec<CodexTypeData>,
    #[prost(uint32, tag = "3")]
    pub last_read_pushtips_codex_id: u32,
    #[prost(uint32, tag = "4")]
    pub last_read_pushtips_type_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CodexDataUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub weapon_max_promote_level: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(enumeration = "CodexType", tag = "3")]
    pub r#type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4203)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCodexMonsterBeKilledNumReq {
    #[prost(uint32, repeated, tag = "1")]
    pub codex_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4204)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCodexMonsterBeKilledNumRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub be_killed_num_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub be_captured_num_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub codex_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4205)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewCodexReq {
    #[prost(message, repeated, tag = "1")]
    pub type_data_list: ::prost::alloc::vec::Vec<CodexTypeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4206)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewCodexRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub push_tips_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub type_data_list: ::prost::alloc::vec::Vec<CodexTypeData>,
    #[prost(uint32, repeated, tag = "3")]
    pub push_tips_read_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub recent_viewed_pushtips_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCodexPushtipsReadReq {
    #[prost(uint32, tag = "1")]
    pub type_id: u32,
    #[prost(uint32, tag = "2")]
    pub codex_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCodexPushtipsReadRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub type_id: u32,
    #[prost(uint32, tag = "3")]
    pub codex_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainCoop {
    #[prost(uint32, repeated, tag = "1")]
    pub save_point_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, int32", tag = "2")]
    pub normal_var_map: ::std::collections::HashMap<u32, i32>,
    #[prost(map = "uint32, int32", tag = "3")]
    pub temp_var_map: ::std::collections::HashMap<u32, i32>,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub seen_ending_map: ::std::collections::HashMap<u32, u32>,
    #[prost(enumeration = "MainCoopStatus", tag = "5")]
    pub status: i32,
    #[prost(uint32, tag = "6")]
    pub self_confidence: u32,
    #[prost(uint32, tag = "7")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1901)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllCoopInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub main_coop_list: ::prost::alloc::vec::Vec<MainCoop>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1902)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainCoopUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub main_coop_list: ::prost::alloc::vec::Vec<MainCoop>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1903)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveMainCoopReq {
    #[prost(map = "uint32, int32", tag = "1")]
    pub normal_var_map: ::std::collections::HashMap<u32, i32>,
    #[prost(map = "uint32, int32", tag = "2")]
    pub temp_var_map: ::std::collections::HashMap<u32, i32>,
    #[prost(uint32, tag = "3")]
    pub save_point_id: u32,
    #[prost(uint32, tag = "4")]
    pub id: u32,
    #[prost(uint32, tag = "5")]
    pub self_confidence: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1904)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveMainCoopRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub save_point_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinishMainCoopReq {
    #[prost(uint32, tag = "1")]
    pub ending_save_point_id: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1906)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinishMainCoopRsp {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub ending_save_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoopPoint {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub self_confidence: u32,
    #[prost(enumeration = "CoopPointState", tag = "3")]
    pub state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoopReward {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(enumeration = "CoopRewardState", tag = "2")]
    pub state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoopCg {
    #[prost(bool, tag = "1")]
    pub is_unlock: bool,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoopChapter {
    #[prost(uint32, repeated, tag = "1")]
    pub finish_dialog_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub coop_cg_list: ::prost::alloc::vec::Vec<CoopCg>,
    #[prost(message, repeated, tag = "3")]
    pub coop_reward_list: ::prost::alloc::vec::Vec<CoopReward>,
    #[prost(message, repeated, tag = "4")]
    pub coop_point_list: ::prost::alloc::vec::Vec<CoopPoint>,
    #[prost(map = "uint32, uint32", tag = "5")]
    pub seen_ending_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "6")]
    pub lock_reason_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "7")]
    pub id: u32,
    #[prost(enumeration = "CoopChapterState", tag = "8")]
    pub state: i32,
    #[prost(uint32, tag = "9")]
    pub total_end_count: u32,
    #[prost(uint32, tag = "10")]
    pub finished_end_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1907)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoopDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub chapter_list: ::prost::alloc::vec::Vec<CoopChapter>,
    #[prost(uint32, repeated, tag = "2")]
    pub viewed_chapter_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub cur_coop_point: u32,
    #[prost(bool, tag = "4")]
    pub is_have_progress: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1908)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoopChapterUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub chapter_list: ::prost::alloc::vec::Vec<CoopChapter>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1909)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoopCgUpdateNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub cg_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1910)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoopRewardUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub reward_list: ::prost::alloc::vec::Vec<CoopReward>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1911)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockCoopChapterReq {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1912)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockCoopChapterRsp {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1913)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoopPointUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub coop_point: ::core::option::Option<CoopPoint>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1914)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartCoopPointReq {
    #[prost(uint32, tag = "1")]
    pub coop_point: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1915)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartCoopPointRsp {
    #[prost(message, optional, tag = "1")]
    pub start_main_coop: ::core::option::Option<MainCoop>,
    #[prost(uint32, tag = "2")]
    pub coop_point: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(bool, tag = "4")]
    pub is_start: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1916)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelCoopTaskReq {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1917)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelCoopTaskRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1918)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeCoopRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1919)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeCoopRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub reward_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1920)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoopProgressUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub cur_coop_point: u32,
    #[prost(bool, tag = "2")]
    pub is_have_progress: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1921)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SaveCoopDialogReq {
    #[prost(uint32, tag = "1")]
    pub dialog_id: u32,
    #[prost(uint32, tag = "2")]
    pub main_coop_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1922)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SaveCoopDialogRsp {
    #[prost(uint32, tag = "1")]
    pub main_coop_id: u32,
    #[prost(uint32, tag = "2")]
    pub dialog_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1923)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoopCgShowNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub cg_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1924)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCoopChapterViewedReq {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1925)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCoopChapterViewedRsp {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1926)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainCoopFailNotify {
    #[prost(string, tag = "1")]
    pub textmap_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub chapter_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomDungeonBlock {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub block_id: u32,
    #[prost(uint32, tag = "4")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonRoom {
    #[prost(message, repeated, tag = "1")]
    pub block_list: ::prost::alloc::vec::Vec<CustomDungeonBlock>,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonSetting {
    #[prost(uint32, repeated, tag = "1")]
    pub open_room_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub start_room_id: u32,
    #[prost(uint32, tag = "3")]
    pub life_num: u32,
    #[prost(uint32, tag = "4")]
    pub coin_limit: u32,
    #[prost(bool, tag = "5")]
    pub is_forbid_skill: bool,
    #[prost(bool, tag = "6")]
    pub is_arrive_finish: bool,
    #[prost(uint32, tag = "7")]
    pub time_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeon {
    #[prost(message, repeated, tag = "1")]
    pub room_list: ::prost::alloc::vec::Vec<CustomDungeonRoom>,
    #[prost(message, optional, tag = "2")]
    pub setting: ::core::option::Option<CustomDungeonSetting>,
    #[prost(uint64, tag = "3")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterCustomDungeonReq {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(enumeration = "EnterCustomDungeonType", tag = "3")]
    pub enter_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6202)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterCustomDungeonRsp {
    #[prost(message, optional, tag = "1")]
    pub custom_dungeon: ::core::option::Option<CustomDungeon>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub room_cost_map: ::std::collections::HashMap<u32, u32>,
    #[prost(enumeration = "EnterCustomDungeonType", tag = "3")]
    pub enter_type: i32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6203)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveCustomDungeonRoomReq {
    #[prost(message, optional, tag = "1")]
    pub setting: ::core::option::Option<CustomDungeonSetting>,
    #[prost(message, optional, tag = "2")]
    pub custom_dungeon_room: ::core::option::Option<CustomDungeonRoom>,
    #[prost(bool, tag = "3")]
    pub is_update_setting: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6204)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveCustomDungeonRoomRsp {
    #[prost(message, repeated, tag = "1")]
    pub error_block_list: ::prost::alloc::vec::Vec<CustomDungeonBlock>,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonAbstract {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub brick_statistics_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub total_coin_num: u32,
    #[prost(uint32, tag = "3")]
    pub first_publish_time: u32,
    #[prost(uint32, tag = "4")]
    pub last_publish_time: u32,
    #[prost(uint32, tag = "5")]
    pub finish_room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomDungeonSocial {
    #[prost(uint32, tag = "1")]
    pub like_num: u32,
    #[prost(uint32, tag = "2")]
    pub win_num: u32,
    #[prost(uint32, tag = "3")]
    pub store_num: u32,
    #[prost(uint32, tag = "4")]
    pub play_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonBrief {
    #[prost(uint32, repeated, tag = "1")]
    pub tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub setting: ::core::option::Option<CustomDungeonSetting>,
    #[prost(message, optional, tag = "3")]
    pub r#abstract: ::core::option::Option<CustomDungeonAbstract>,
    #[prost(message, optional, tag = "4")]
    pub social: ::core::option::Option<CustomDungeonSocial>,
    #[prost(uint32, tag = "5")]
    pub dungeon_id: u32,
    #[prost(enumeration = "CustomDungeonState", tag = "6")]
    pub state: i32,
    #[prost(bool, tag = "7")]
    pub is_psn_platform: bool,
    #[prost(uint32, tag = "8")]
    pub battle_min_cost_time: u32,
    #[prost(uint32, tag = "9")]
    pub last_save_time: u32,
    #[prost(uint64, tag = "10")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtherCustomDungeonBrief {
    #[prost(message, optional, tag = "1")]
    pub setting: ::core::option::Option<CustomDungeonSetting>,
    #[prost(message, optional, tag = "2")]
    pub creator_detail: ::core::option::Option<SocialDetail>,
    #[prost(message, optional, tag = "3")]
    pub r#abstract: ::core::option::Option<CustomDungeonAbstract>,
    #[prost(uint32, repeated, tag = "4")]
    pub tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "5")]
    pub social: ::core::option::Option<CustomDungeonSocial>,
    #[prost(uint32, tag = "6")]
    pub dungeon_id: u32,
    #[prost(bool, tag = "7")]
    pub is_psn_platform: bool,
    #[prost(bool, tag = "8")]
    pub is_stored: bool,
    #[prost(bool, tag = "9")]
    pub is_adventure_dungeon: bool,
    #[prost(uint64, tag = "10")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "11")]
    pub battle_min_cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomDungeonBanInfo {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "2")]
    pub expire_time: u32,
    #[prost(enumeration = "CustomDungeonBanType", tag = "3")]
    pub ban_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeCustomDungeonRoomReq {
    #[prost(uint32, tag = "1")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeCustomDungeonRoomRsp {
    #[prost(uint32, tag = "1")]
    pub room_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveCustomDungeonReq {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveCustomDungeonRsp {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryCustomDungeonReq {
    #[prost(uint32, tag = "1")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6210)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryCustomDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub room_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6211)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishCustomDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, tag = "2")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6212)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishCustomDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6213)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitCustomDungeonTryReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6214)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitCustomDungeonTryRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6215)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub dungeon_brief: ::core::option::Option<CustomDungeonBrief>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6216)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRecommendCustomDungeonReq {
    #[prost(bool, tag = "1")]
    pub is_refresh: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6217)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRecommendCustomDungeonRsp {
    #[prost(message, repeated, tag = "1")]
    pub custom_dungeon_list: ::prost::alloc::vec::Vec<OtherCustomDungeonBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6218)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStoreCustomDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6219)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoreCustomDungeonRsp {
    #[prost(message, repeated, tag = "1")]
    pub custom_dungeon_list: ::prost::alloc::vec::Vec<OtherCustomDungeonBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6220)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCustomDungeonReq {
    #[prost(string, tag = "1")]
    pub dungeon_code: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6221)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCustomDungeonRsp {
    #[prost(message, optional, tag = "1")]
    pub custom_dungeon_brief: ::core::option::Option<OtherCustomDungeonBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6222)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StoreCustomDungeonReq {
    #[prost(bool, tag = "1")]
    pub is_cancel_store: bool,
    #[prost(uint64, tag = "2")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6223)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StoreCustomDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6224)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LikeCustomDungeonReq {
    #[prost(bool, tag = "1")]
    pub is_cancel_like: bool,
    #[prost(uint64, tag = "2")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6225)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LikeCustomDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6226)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCustomDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6227)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomDungeonRsp {
    #[prost(message, optional, tag = "1")]
    pub ban_info: ::core::option::Option<CustomDungeonBanInfo>,
    #[prost(message, repeated, tag = "2")]
    pub brief_list: ::prost::alloc::vec::Vec<CustomDungeonBrief>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6228)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonRecoverNotify {
    #[prost(message, optional, tag = "1")]
    pub custom_dungeon: ::core::option::Option<CustomDungeon>,
    #[prost(uint32, repeated, tag = "2")]
    pub official_black_coin_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "EnterCustomDungeonType", tag = "3")]
    pub enter_type: i32,
    #[prost(enumeration = "TryCustomDungeonType", tag = "4")]
    pub try_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6229)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackPlayCustomDungeonOfficialReq {
    #[prost(uint32, tag = "1")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6230)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackPlayCustomDungeonOfficialRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6231)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonOfficialNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub official_black_coin_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "TryCustomDungeonType", tag = "2")]
    pub try_type: i32,
    #[prost(enumeration = "EnterCustomDungeonType", tag = "3")]
    pub enter_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6232)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReplayCustomDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6233)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReplayCustomDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6234)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomDungeonBattleRecordNotify {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "2")]
    pub min_cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6235)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutStuckCustomDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6236)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutStuckCustomDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftOwnerStartInviteReq {
    #[prost(uint32, tag = "1")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftInviteFailInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(enumeration = "DraftInviteFailReason", tag = "2")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DraftOwnerStartInviteRsp {
    #[prost(message, repeated, tag = "1")]
    pub invite_fail_info_list: ::prost::alloc::vec::Vec<DraftInviteFailInfo>,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub wrong_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5403)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftOwnerInviteNotify {
    #[prost(uint32, tag = "1")]
    pub invite_deadline_time: u32,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5404)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftGuestReplyInviteReq {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5405)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftGuestReplyInviteRsp {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftGuestReplyInviteNotify {
    #[prost(uint32, tag = "1")]
    pub guest_uid: u32,
    #[prost(bool, tag = "2")]
    pub is_agree: bool,
    #[prost(uint32, tag = "3")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftInviteResultNotify {
    #[prost(bool, tag = "1")]
    pub is_all_agree: bool,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5408)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftOwnerTwiceConfirmNotify {
    #[prost(uint32, tag = "1")]
    pub twice_confirm_deadline_time: u32,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftGuestReplyTwiceConfirmReq {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5410)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftGuestReplyTwiceConfirmRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_agree: bool,
    #[prost(uint32, tag = "3")]
    pub draft_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5411)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftTwiceConfirmResultNotify {
    #[prost(uint32, tag = "1")]
    pub draft_id: u32,
    #[prost(bool, tag = "2")]
    pub is_all_agree: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DraftGuestReplyTwiceConfirmNotify {
    #[prost(uint32, tag = "1")]
    pub guest_uid: u32,
    #[prost(uint32, tag = "2")]
    pub draft_id: u32,
    #[prost(bool, tag = "3")]
    pub is_agree: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(901)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonEntryInfoReq {
    #[prost(message, repeated, tag = "1")]
    pub scene_point_id_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonEntryInfo {
    #[prost(message, optional, tag = "1")]
    pub weekly_boss_resin_discount_info: ::core::option::Option<
        WeeklyBossResinDiscountInfo,
    >,
    #[prost(uint32, tag = "2")]
    pub left_times: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "4")]
    pub end_time: u32,
    #[prost(uint32, tag = "5")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "6")]
    pub start_time: u32,
    #[prost(uint32, tag = "7")]
    pub boss_chest_num: u32,
    #[prost(uint32, tag = "8")]
    pub max_boss_chest_num: u32,
    #[prost(bool, tag = "9")]
    pub is_passed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonEntryPointInfo {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_entry_list: ::prost::alloc::vec::Vec<DungeonEntryInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
    #[prost(uint32, tag = "4")]
    pub recommend_dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(902)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonEntryInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_entry_list: ::prost::alloc::vec::Vec<DungeonEntryInfo>,
    #[prost(message, repeated, tag = "2")]
    pub dungeon_entry_point_list: ::prost::alloc::vec::Vec<DungeonEntryPointInfo>,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
    #[prost(uint32, tag = "4")]
    pub recommend_dungeon_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonEnterPosInfo {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerEnterDungeonReq {
    #[prost(message, optional, tag = "1")]
    pub enter_pos_info: ::core::option::Option<DungeonEnterPosInfo>,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerEnterDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerQuitDungeonReq {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(bool, tag = "2")]
    pub is_quit_immediately: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(906)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerQuitDungeonRsp {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(907)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonWayPointNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub active_way_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_add: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(908)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonWayPointActivateReq {
    #[prost(uint32, tag = "1")]
    pub way_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(909)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonWayPointActivateRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub way_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StrengthenPointData {
    #[prost(uint32, tag = "1")]
    pub base_point: u32,
    #[prost(uint32, tag = "2")]
    pub cur_point: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonSettleExhibitionInfo {
    #[prost(message, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(message, optional, tag = "2")]
    pub player_info: ::core::option::Option<OnlinePlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CrystalLinkDungeonSettleInfo {
    #[prost(uint32, tag = "1")]
    pub kill_normal_monster_num: u32,
    #[prost(uint32, tag = "2")]
    pub final_score: u32,
    #[prost(bool, tag = "3")]
    pub apilnlmnbca: bool,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "5")]
    pub kill_elite_monster_num: u32,
    #[prost(uint32, tag = "6")]
    pub difficulty_id: u32,
    #[prost(uint32, tag = "7")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2DungeonSettleInfo {
    #[prost(uint32, tag = "1")]
    pub taken_reward_count: u32,
    #[prost(uint32, tag = "2")]
    pub cur_dungeon_reward_limit: u32,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstableSprayDungeonSettleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "4")]
    pub difficulty: u32,
    #[prost(uint32, tag = "5")]
    pub level_id: u32,
    #[prost(uint32, tag = "6")]
    pub round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindFieldDungeonSettleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub after_watcher_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub before_watcher_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "WindFieldDungeonFailReason", tag = "3")]
    pub fail_reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffigyChallengeV2SettleInfo {
    #[prost(bool, tag = "1")]
    pub is_new_record_time: bool,
    #[prost(bool, tag = "2")]
    pub is_challenge_highest_difficulty: bool,
    #[prost(uint32, tag = "3")]
    pub create_dungeon_player_uid: u32,
    #[prost(uint32, tag = "4")]
    pub first_time_finish_difficulty: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_mode_difficulty: u32,
    #[prost(uint32, tag = "6")]
    pub record_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamChainSettleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub stage_id: u32,
    #[prost(uint32, tag = "3")]
    pub difficulty: u32,
    #[prost(bool, tag = "4")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "5")]
    pub total_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PacmanSettleInfo {
    #[prost(enumeration = "PacmanDungeonStopReason", tag = "1")]
    pub reason: i32,
    #[prost(uint32, tag = "2")]
    pub final_score: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "4")]
    pub killed_monster_num: u32,
    #[prost(uint32, tag = "5")]
    pub coin_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterV2SettleInfo {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "3")]
    pub died_monster_count: u32,
    #[prost(uint32, tag = "4")]
    pub total_tower_count: u32,
    #[prost(uint32, tag = "5")]
    pub defeated_tower_count: u32,
    #[prost(uint32, tag = "6")]
    pub cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(910)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonSettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub exhibition_info_list: ::prost::alloc::vec::Vec<DungeonSettleExhibitionInfo>,
    #[prost(map = "uint32, message", tag = "2")]
    pub strengthen_point_data_map: ::std::collections::HashMap<u32, StrengthenPointData>,
    #[prost(map = "uint32, message", tag = "3")]
    pub settle_show: ::std::collections::HashMap<u32, ParamList>,
    #[prost(uint32, repeated, tag = "4")]
    pub fail_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "6")]
    pub create_player_uid: u32,
    #[prost(uint32, tag = "7")]
    pub use_time: u32,
    #[prost(bool, tag = "8")]
    pub is_success: bool,
    #[prost(uint32, tag = "9")]
    pub result: u32,
    #[prost(uint32, tag = "10")]
    pub close_time: u32,
    #[prost(
        oneof = "dungeon_settle_notify::Detail",
        tags = "11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23"
    )]
    pub detail: ::core::option::Option<dungeon_settle_notify::Detail>,
}
/// Nested message and enum types in `DungeonSettleNotify`.
pub mod dungeon_settle_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "11")]
        TowerLevelEndNotify(super::TowerLevelEndNotify),
        #[prost(message, tag = "12")]
        TrialAvatarFirstPassDungeonNotify(super::TrialAvatarFirstPassDungeonNotify),
        #[prost(message, tag = "13")]
        ChannelerSlabLoopDungeonResultInfo(super::ChannelerSlabLoopDungeonResultInfo),
        #[prost(message, tag = "14")]
        EffigyChallengeDungeonResultInfo(super::EffigyChallengeDungeonResultInfo),
        #[prost(message, tag = "15")]
        RoguelikeDungeonSettleInfo(super::RoguelikeDungeonSettleInfo),
        #[prost(message, tag = "16")]
        CrystalLinkSettleInfo(super::CrystalLinkDungeonSettleInfo),
        #[prost(message, tag = "17")]
        SummerTimeV2DungeonSettleInfo(super::SummerTimeV2DungeonSettleInfo),
        #[prost(message, tag = "18")]
        InstableSpraySettleInfo(super::InstableSprayDungeonSettleInfo),
        #[prost(message, tag = "19")]
        WindFieldDungeonSettleInfo(super::WindFieldDungeonSettleInfo),
        #[prost(message, tag = "20")]
        EffigyChallengeV2SettleInfo(super::EffigyChallengeV2SettleInfo),
        #[prost(message, tag = "21")]
        TeamChainSettleInfo(super::TeamChainSettleInfo),
        #[prost(message, tag = "22")]
        PacmanSettleInfo(super::PacmanSettleInfo),
        #[prost(message, tag = "23")]
        FungusFighterV2SettleInfo(super::FungusFighterV2SettleInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(911)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonPlayerDieNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub strengthen_point_data_map: ::std::collections::HashMap<u32, StrengthenPointData>,
    #[prost(uint32, tag = "2")]
    pub revive_count: u32,
    #[prost(uint32, tag = "3")]
    pub wait_time: u32,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
    #[prost(enumeration = "PlayerDieType", tag = "5")]
    pub die_type: i32,
    #[prost(uint32, tag = "6")]
    pub murderer_entity_id: u32,
    #[prost(oneof = "dungeon_player_die_notify::Entity", tags = "7, 8")]
    pub entity: ::core::option::Option<dungeon_player_die_notify::Entity>,
}
/// Nested message and enum types in `DungeonPlayerDieNotify`.
pub mod dungeon_player_die_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Entity {
        #[prost(uint32, tag = "7")]
        MonsterId(u32),
        #[prost(uint32, tag = "8")]
        GadgetId(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(912)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonDieOptionReq {
    #[prost(enumeration = "PlayerDieOption", tag = "1")]
    pub die_option: i32,
    #[prost(bool, tag = "2")]
    pub is_quit_immediately: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(913)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonDieOptionRsp {
    #[prost(uint32, tag = "1")]
    pub revive_count: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "PlayerDieOption", tag = "3")]
    pub die_option: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(914)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonShowReminderNotify {
    #[prost(uint32, tag = "1")]
    pub reminder_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(915)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonPlayerDieReq {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(enumeration = "PlayerDieType", tag = "2")]
    pub die_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(916)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonPlayerDieRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(917)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonDataNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub dungeon_data_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(918)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonChallengeBeginNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub father_index: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_index: u32,
    #[prost(uint32, tag = "6")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChallengeBrief {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(uint32, tag = "2")]
    pub challenge_index: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "4")]
    pub cur_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDungeonResultInfo {
    #[prost(message, repeated, tag = "1")]
    pub child_challenge_list: ::prost::alloc::vec::Vec<ChallengeBrief>,
    #[prost(uint32, tag = "2")]
    pub got_coin_num: u32,
    #[prost(bool, tag = "3")]
    pub is_stored: bool,
    #[prost(bool, tag = "4")]
    pub is_liked: bool,
    #[prost(bool, tag = "5")]
    pub is_arrive_finish: bool,
    #[prost(uint32, tag = "6")]
    pub time_cost: u32,
    #[prost(enumeration = "CustomDungeonFinishType", tag = "7")]
    pub finish_type: i32,
    #[prost(uint64, tag = "8")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(919)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonChallengeFinishNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub strengthen_point_data_map: ::std::collections::HashMap<u32, StrengthenPointData>,
    #[prost(uint32, tag = "2")]
    pub challenge_index: u32,
    #[prost(enumeration = "ChallengeFinishType", tag = "3")]
    pub finish_type: i32,
    #[prost(uint32, tag = "4")]
    pub current_value: u32,
    #[prost(bool, tag = "5")]
    pub is_new_record: bool,
    #[prost(bool, tag = "6")]
    pub is_success: bool,
    #[prost(uint32, tag = "7")]
    pub time_cost: u32,
    #[prost(uint32, tag = "8")]
    pub challenge_record_type: u32,
    #[prost(oneof = "dungeon_challenge_finish_notify::Detail", tags = "9, 10, 11, 12")]
    pub detail: ::core::option::Option<dungeon_challenge_finish_notify::Detail>,
}
/// Nested message and enum types in `DungeonChallengeFinishNotify`.
pub mod dungeon_challenge_finish_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "9")]
        ChannelerSlabLoopDungeonResultInfo(super::ChannelerSlabLoopDungeonResultInfo),
        #[prost(message, tag = "10")]
        EffigyChallengeDungeonResultInfo(super::EffigyChallengeDungeonResultInfo),
        #[prost(message, tag = "11")]
        PotionDungeonResultInfo(super::PotionDungeonResultInfo),
        #[prost(message, tag = "12")]
        CustomDungeonResultInfo(super::CustomDungeonResultInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(920)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChallengeDataNotify {
    #[prost(uint32, tag = "1")]
    pub challenge_index: u32,
    #[prost(uint32, tag = "2")]
    pub value: u32,
    #[prost(uint32, tag = "3")]
    pub param_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(921)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonFollowNotify {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(922)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonGetStatueDropReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(923)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonGetStatueDropRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChallengeRecord {
    #[prost(uint32, tag = "1")]
    pub challenge_record_type: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_index: u32,
    #[prost(uint32, tag = "3")]
    pub best_value: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(924)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChallengeRecordNotify {
    #[prost(message, repeated, tag = "1")]
    pub challenge_record_list: ::prost::alloc::vec::Vec<ChallengeRecord>,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamAvatar {
    #[prost(message, optional, tag = "1")]
    pub avatar_info: ::core::option::Option<AvatarInfo>,
    #[prost(uint32, tag = "2")]
    pub player_uid: u32,
    #[prost(oneof = "dungeon_candidate_team_avatar::Detail", tags = "3")]
    pub detail: ::core::option::Option<dungeon_candidate_team_avatar::Detail>,
}
/// Nested message and enum types in `DungeonCandidateTeamAvatar`.
pub mod dungeon_candidate_team_avatar {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "3")]
        UgcAvatarInfo(super::UgcDungeonCandidateTeamAvatarInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonCandidateTeamInfo {
    #[prost(message, optional, tag = "1")]
    pub ugc_brief_data: ::core::option::Option<UgcDungeonBrief>,
    #[prost(enumeration = "EnterUgcDungeonType", tag = "2")]
    pub enter_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(925)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamInfoNotify {
    #[prost(map = "uint32, enumeration(DungeonCandidateTeamPlayerState)", tag = "1")]
    pub player_state_map: ::std::collections::HashMap<u32, i32>,
    #[prost(uint32, repeated, tag = "2")]
    pub ready_player_uid: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub avatar_list: ::prost::alloc::vec::Vec<DungeonCandidateTeamAvatar>,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "5")]
    pub match_type: u32,
    #[prost(oneof = "dungeon_candidate_team_info_notify::Detail", tags = "6")]
    pub detail: ::core::option::Option<dungeon_candidate_team_info_notify::Detail>,
}
/// Nested message and enum types in `DungeonCandidateTeamInfoNotify`.
pub mod dungeon_candidate_team_info_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "6")]
        UgcTeamInfo(super::UgcDungeonCandidateTeamInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(926)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamInviteNotify {
    #[prost(uint32, tag = "1")]
    pub player_uid: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "3")]
    pub valid_deadline_time_sec: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(927)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamRefuseNotify {
    #[prost(uint32, tag = "1")]
    pub player_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(928)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamPlayerLeaveNotify {
    #[prost(enumeration = "DungeonCandidateTeamPlayerLeaveReason", tag = "1")]
    pub reason: i32,
    #[prost(uint32, tag = "2")]
    pub player_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(929)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamDismissNotify {
    #[prost(enumeration = "DungeonCandidateTeamDismissReason", tag = "1")]
    pub reason: i32,
    #[prost(uint32, tag = "2")]
    pub player_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(930)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamCreateReq {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(931)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamCreateRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(932)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamInviteReq {
    #[prost(uint32, repeated, tag = "1")]
    pub player_uids: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(933)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamInviteRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub invalid_player_uids: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(934)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamKickReq {
    #[prost(uint32, tag = "1")]
    pub player_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(935)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamKickRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(936)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamLeaveReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(937)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamLeaveRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(938)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamReplyInviteReq {
    #[prost(bool, tag = "1")]
    pub is_accept: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(939)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamReplyInviteRsp {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_trans_point: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(940)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamSetReadyReq {
    #[prost(bool, tag = "1")]
    pub is_ready: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(941)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamSetReadyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(942)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamChangeAvatarReq {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(943)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamChangeAvatarRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyDungeonEntryInfo {
    #[prost(message, optional, tag = "1")]
    pub recommend_dungeon_entry_info: ::core::option::Option<DungeonEntryInfo>,
    #[prost(uint32, tag = "2")]
    pub dungeon_entry_config_id: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_entry_id: u32,
    #[prost(uint32, tag = "4")]
    pub recommend_dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(944)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDailyDungeonEntryInfoReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(945)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDailyDungeonEntryInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub daily_dungeon_info_list: ::prost::alloc::vec::Vec<DailyDungeonEntryInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(946)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonSlipRevivePointActivateReq {
    #[prost(uint32, tag = "1")]
    pub slip_revive_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(947)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonSlipRevivePointActivateRsp {
    #[prost(uint32, tag = "1")]
    pub slip_revive_point_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(948)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonInterruptChallengeReq {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_index: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(949)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonInterruptChallengeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(950)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractDailyDungeonInfoNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(951)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(952)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(953)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartInviteNotify {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub cd: u32,
    #[prost(uint32, tag = "3")]
    pub player_uid: u32,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(954)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartInviteReplyReq {
    #[prost(bool, tag = "1")]
    pub is_accept: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(955)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartInviteReplyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_accept: bool,
    #[prost(bool, tag = "3")]
    pub is_trans_point: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(956)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartInviteReplyNotify {
    #[prost(bool, tag = "1")]
    pub is_accept: bool,
    #[prost(uint32, tag = "2")]
    pub player_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(957)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonRestartResultNotify {
    #[prost(bool, tag = "1")]
    pub is_add_accept: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(958)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamSetChangingAvatarReq {
    #[prost(bool, tag = "1")]
    pub is_changing_avatar: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(959)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonCandidateTeamSetChangingAvatarRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(960)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MistTrialFloorLevelNotify {
    #[prost(uint32, tag = "1")]
    pub dungeon_scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub floor_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(961)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonReviseLevelNotify {
    #[prost(uint32, tag = "1")]
    pub revise_level: u32,
    #[prost(uint32, tag = "2")]
    pub scene_level: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(962)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonPreloadMonsterNotify {
    #[prost(enumeration = "PlatformType", repeated, tag = "1")]
    pub platform_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "2")]
    pub monster_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(963)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonBatchPreloadMonsterNotify {
    #[prost(message, repeated, tag = "1")]
    pub preload_data_list: ::prost::alloc::vec::Vec<PreloadData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreloadData {
    #[prost(uint32, repeated, tag = "1")]
    pub monster_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "2")]
    pub batch_name: ::prost::alloc::string::String,
    #[prost(enumeration = "PlatformType", repeated, tag = "3")]
    pub platform_list: ::prost::alloc::vec::Vec<i32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HitCollision {
    #[prost(message, optional, tag = "1")]
    pub hit_dir: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub hit_point: ::core::option::Option<Vector>,
    #[prost(enumeration = "HitColliderType", tag = "3")]
    pub hit_collider_type: i32,
    #[prost(int32, tag = "4")]
    pub hit_box_index: i32,
    #[prost(float, tag = "5")]
    pub attackee_hit_entity_angle: f32,
    #[prost(float, tag = "6")]
    pub attackee_hit_force_angle: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttackHitEffectResult {
    #[prost(float, tag = "1")]
    pub retreat_strength: f32,
    #[prost(uint32, tag = "2")]
    pub original_hit_eff_level: u32,
    #[prost(float, tag = "3")]
    pub air_strength: f32,
    #[prost(uint32, tag = "4")]
    pub hit_eff_level: u32,
    #[prost(float, tag = "5")]
    pub hit_halt_time_scale: f32,
    #[prost(float, tag = "6")]
    pub hit_halt_time: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityIdentifier {
    #[prost(uint32, tag = "1")]
    pub ability_caster_id: u32,
    #[prost(uint32, tag = "2")]
    pub instanced_modifier_id: u32,
    #[prost(bool, tag = "3")]
    pub is_serverbuff_modifier: bool,
    #[prost(int32, tag = "4")]
    pub local_id: i32,
    #[prost(uint32, tag = "5")]
    pub instanced_ability_id: u32,
    #[prost(uint32, tag = "6")]
    pub modifier_owner_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttackResult {
    #[prost(message, optional, tag = "1")]
    pub resolved_dir: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub hit_collision: ::core::option::Option<HitCollision>,
    #[prost(message, optional, tag = "3")]
    pub hit_eff_result: ::core::option::Option<AttackHitEffectResult>,
    #[prost(message, optional, tag = "4")]
    pub ability_identifier: ::core::option::Option<AbilityIdentifier>,
    #[prost(string, tag = "5")]
    pub anim_event_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub hashed_anim_event_id: u32,
    #[prost(uint32, tag = "7")]
    pub bullet_fly_time_ms: u32,
    #[prost(uint32, tag = "8")]
    pub endure_break: u32,
    #[prost(uint32, tag = "9")]
    pub attack_timestamp_ms: u32,
    #[prost(uint32, tag = "10")]
    pub amplify_reaction_type: u32,
    #[prost(float, tag = "11")]
    pub element_amplify_rate: f32,
    #[prost(uint32, tag = "12")]
    pub gadget_damage_action_idx: u32,
    #[prost(bool, tag = "13")]
    pub is_resist_text: bool,
    #[prost(bool, tag = "14")]
    pub is_crit: bool,
    #[prost(bool, tag = "15")]
    pub mute_element_hurt: bool,
    #[prost(bool, tag = "16")]
    pub use_gadget_damage_action: bool,
    #[prost(uint32, tag = "17")]
    pub attack_count: u32,
    #[prost(float, tag = "18")]
    pub element_durability_attenuation: f32,
    #[prost(uint32, tag = "19")]
    pub target_type: u32,
    #[prost(float, tag = "20")]
    pub damage: f32,
    #[prost(float, tag = "21")]
    pub damage_shield: f32,
    #[prost(float, tag = "22")]
    pub endure_delta: f32,
    #[prost(uint32, tag = "23")]
    pub defense_id: u32,
    #[prost(uint32, tag = "24")]
    pub addhurt_reaction_type: u32,
    #[prost(uint32, tag = "25")]
    pub critical_rand: u32,
    #[prost(uint32, tag = "26")]
    pub create_count_sync_to_server: u32,
    #[prost(uint32, tag = "27")]
    pub attacker_id: u32,
    #[prost(int32, tag = "28")]
    pub hit_retreat_angle_compat: i32,
    #[prost(uint32, tag = "29")]
    pub element_type: u32,
    #[prost(uint32, tag = "30")]
    pub hit_pos_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtBeingHitInfo {
    #[prost(message, optional, tag = "1")]
    pub attack_result: ::core::option::Option<AttackResult>,
    #[prost(uint32, tag = "2")]
    pub peer_id: u32,
    #[prost(uint32, tag = "3")]
    pub frame_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtBeingHitNotify {
    #[prost(message, optional, tag = "1")]
    pub being_hit_info: ::core::option::Option<EvtBeingHitInfo>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAnimatorParameterInfo {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<AnimatorParameterValueInfo>,
    #[prost(int32, tag = "2")]
    pub name_id: i32,
    #[prost(bool, tag = "3")]
    pub is_server_cache: bool,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAnimatorParameterNotify {
    #[prost(message, optional, tag = "1")]
    pub animator_param_info: ::core::option::Option<EvtAnimatorParameterInfo>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HostPlayerNotify {
    #[prost(uint32, tag = "1")]
    pub host_uid: u32,
    #[prost(uint32, tag = "2")]
    pub host_peer_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtDoSkillSuccNotify {
    #[prost(message, optional, tag = "1")]
    pub forward: ::core::option::Option<Vector>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
    #[prost(uint32, tag = "3")]
    pub skill_id: u32,
    #[prost(uint32, tag = "4")]
    pub caster_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(305)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtCreateGadgetNotify {
    #[prost(message, optional, tag = "1")]
    pub init_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub init_euler_angles: ::core::option::Option<Vector>,
    #[prost(uint32, repeated, tag = "3")]
    pub target_lock_point_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub target_entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub owner_entity_id: u32,
    #[prost(uint32, tag = "6")]
    pub prop_owner_entity_id: u32,
    #[prost(uint32, tag = "7")]
    pub config_id: u32,
    #[prost(uint64, tag = "8")]
    pub guid: u64,
    #[prost(uint32, tag = "9")]
    pub entity_id: u32,
    #[prost(bool, tag = "10")]
    pub sight_group_with_owner: bool,
    #[prost(bool, tag = "11")]
    pub is_true_life_time_by_owner: bool,
    #[prost(bool, tag = "12")]
    pub is_async_load: bool,
    #[prost(bool, tag = "13")]
    pub is_peer_id_from_player: bool,
    #[prost(enumeration = "ForwardType", tag = "14")]
    pub forward_type: i32,
    #[prost(uint32, tag = "15")]
    pub room_id: u32,
    #[prost(uint32, tag = "16")]
    pub camp_type: u32,
    #[prost(uint32, tag = "17")]
    pub target_lock_point_index: u32,
    #[prost(uint32, tag = "18")]
    pub target_entity_id: u32,
    #[prost(uint32, tag = "19")]
    pub camp_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtDestroyGadgetNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtFaceToEntityNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub face_entity_id: u32,
    #[prost(enumeration = "ForwardType", tag = "3")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtFaceToDirInfo {
    #[prost(message, optional, tag = "1")]
    pub face_dir: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(308)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtFaceToDirNotify {
    #[prost(message, optional, tag = "1")]
    pub evt_face_to_dir_info: ::core::option::Option<EvtFaceToDirInfo>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(309)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtCostStaminaNotify {
    #[prost(uint32, tag = "1")]
    pub skill_id: u32,
    #[prost(float, tag = "2")]
    pub cost_stamina: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtSetAttackTargetInfo {
    #[prost(uint32, tag = "1")]
    pub select_point_index: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub attack_target_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtSetAttackTargetNotify {
    #[prost(message, optional, tag = "1")]
    pub evt_set_attack_target_info: ::core::option::Option<EvtSetAttackTargetInfo>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAnimatorStateChangedInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(float, tag = "2")]
    pub fade_duration: f32,
    #[prost(uint32, tag = "3")]
    pub normalized_time_compact: u32,
    #[prost(bool, tag = "4")]
    pub handle_animator_state_immediately: bool,
    #[prost(bool, tag = "5")]
    pub force_sync: bool,
    #[prost(uint32, tag = "6")]
    pub entity_id: u32,
    #[prost(uint32, tag = "7")]
    pub to_state_hash: u32,
    #[prost(int32, tag = "8")]
    pub face_angle_compact: i32,
    #[prost(uint32, tag = "9")]
    pub layer: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtCompensatePosDiffInfo {
    #[prost(message, optional, tag = "1")]
    pub cur_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub cur_hash: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(int32, tag = "4")]
    pub face_angle_compact: i32,
    #[prost(uint32, tag = "5")]
    pub normalized_time_compact: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtMonsterDoBlink {
    #[prost(message, optional, tag = "1")]
    pub target_rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub target_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtFixedRushMove {
    #[prost(uint32, repeated, tag = "1")]
    pub animator_state_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub target_pos: ::core::option::Option<Vector>,
    #[prost(string, tag = "3")]
    pub override_collider: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
    #[prost(float, tag = "5")]
    pub speed: f32,
    #[prost(bool, tag = "6")]
    pub need_set_is_in_air: bool,
    #[prost(bool, tag = "7")]
    pub check_animator_state_on_exit_only: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtSyncTransform {
    #[prost(message, optional, tag = "1")]
    pub entity_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub entity_rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtLightCoreMove {
    #[prost(message, optional, tag = "1")]
    pub target_pos: ::core::option::Option<Vector>,
    #[prost(float, tag = "2")]
    pub accelerate: f32,
    #[prost(float, tag = "3")]
    pub max_absorb_time: f32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
    #[prost(float, tag = "5")]
    pub speed: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtGrapplingHookMove {
    #[prost(string, tag = "1")]
    pub override_collider: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub target_pos: ::core::option::Option<Vector>,
    #[prost(uint32, repeated, tag = "3")]
    pub animator_state_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, tag = "4")]
    pub max_speed: f32,
    #[prost(float, tag = "5")]
    pub acceleration: f32,
    #[prost(float, tag = "6")]
    pub speed: f32,
    #[prost(uint32, tag = "7")]
    pub entity_id: u32,
    #[prost(bool, tag = "8")]
    pub need_set_is_in_air: bool,
    #[prost(bool, tag = "9")]
    pub check_animator_state_on_exit_only: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAnimatorStateChangedNotify {
    #[prost(message, optional, tag = "1")]
    pub evt_animator_state_changed_info: ::core::option::Option<
        EvtAnimatorStateChangedInfo,
    >,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtRushMoveInfo {
    #[prost(message, optional, tag = "1")]
    pub velocity: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rush_attack_target_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "4")]
    pub rush_to_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "5")]
    pub entity_id: u32,
    #[prost(float, tag = "6")]
    pub time_range: f32,
    #[prost(int32, tag = "7")]
    pub state_name_hash: i32,
    #[prost(int32, tag = "8")]
    pub face_angle_compact: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtCombatSteerMotionInfo {
    #[prost(message, optional, tag = "1")]
    pub velocity: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub face_dir: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtCombatForceSetPosInfo {
    #[prost(message, optional, tag = "1")]
    pub target_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub collider_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub ice_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtSyncEntityPositionInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(int32, tag = "2")]
    pub face_angle_compact: i32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub normalized_time_compact: u32,
    #[prost(uint32, tag = "5")]
    pub state_hash: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(312)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtRushMoveNotify {
    #[prost(message, optional, tag = "1")]
    pub evt_rush_move_info: ::core::option::Option<EvtRushMoveInfo>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(313)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtBulletHitNotify {
    #[prost(message, optional, tag = "1")]
    pub hit_normal: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub hit_point: ::core::option::Option<Vector>,
    #[prost(enumeration = "ForwardType", tag = "3")]
    pub forward_type: i32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
    #[prost(int32, tag = "5")]
    pub hit_box_index: i32,
    #[prost(uint32, tag = "6")]
    pub forward_peer: u32,
    #[prost(uint32, tag = "7")]
    pub single_bullet_id: u32,
    #[prost(uint32, tag = "8")]
    pub hit_entity_id: u32,
    #[prost(enumeration = "HitColliderType", tag = "9")]
    pub hit_collider_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(314)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtBulletDeactiveNotify {
    #[prost(message, optional, tag = "1")]
    pub disappear_pos: ::core::option::Option<Vector>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(315)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtEntityStartDieEndNotify {
    #[prost(bool, tag = "1")]
    pub immediately: bool,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(enumeration = "ForwardType", tag = "3")]
    pub forward_type: i32,
    #[prost(uint32, tag = "4")]
    pub die_state_flag: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(316)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtBulletMoveNotify {
    #[prost(message, optional, tag = "1")]
    pub cur_pos: ::core::option::Option<Vector>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(317)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarEnterFocusNotify {
    #[prost(message, optional, tag = "1")]
    pub focus_forward: ::core::option::Option<Vector>,
    #[prost(bool, tag = "2")]
    pub use_auto_focus: bool,
    #[prost(bool, tag = "3")]
    pub use_focus_sticky: bool,
    #[prost(bool, tag = "4")]
    pub fast_focus: bool,
    #[prost(bool, tag = "5")]
    pub enter_holding_focus_shoot: bool,
    #[prost(enumeration = "ForwardType", tag = "6")]
    pub forward_type: i32,
    #[prost(uint32, tag = "7")]
    pub entity_id: u32,
    #[prost(bool, tag = "8")]
    pub use_gyro: bool,
    #[prost(bool, tag = "9")]
    pub disable_aim_layer: bool,
    #[prost(bool, tag = "10")]
    pub disable_anim: bool,
    #[prost(bool, tag = "11")]
    pub can_move: bool,
    #[prost(bool, tag = "12")]
    pub enter_normal_focus_shoot: bool,
    #[prost(bool, tag = "13")]
    pub show_cross_hair: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(318)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarExitFocusNotify {
    #[prost(message, optional, tag = "1")]
    pub finish_forward: ::core::option::Option<Vector>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(319)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarUpdateFocusNotify {
    #[prost(message, optional, tag = "1")]
    pub focus_forward: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(enumeration = "ForwardType", tag = "3")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorityChange {
    #[prost(message, optional, tag = "1")]
    pub entity_authority_info: ::core::option::Option<EntityAuthorityInfo>,
    #[prost(uint32, tag = "2")]
    pub authority_peer_id: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(320)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityAuthorityChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub authority_change_list: ::prost::alloc::vec::Vec<AuthorityChange>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(321)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarBuffAddNotify {
    #[prost(uint32, tag = "1")]
    pub buff_id: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(322)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarBuffDelNotify {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(323)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterAlertChangeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub monster_entity_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub is_alert: u32,
    #[prost(uint32, tag = "3")]
    pub avatar_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(324)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MonsterForceAlertNotify {
    #[prost(uint32, tag = "1")]
    pub monster_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(325)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarEnterElementViewNotify {
    #[prost(bool, tag = "1")]
    pub is_triggered: bool,
    #[prost(uint32, tag = "2")]
    pub avatar_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(326)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerCreateGadgetToEquipPartNotify {
    #[prost(string, tag = "1")]
    pub equip_part: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(327)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtEntityRenderersChangedNotify {
    #[prost(message, optional, tag = "1")]
    pub renderer_changed_info: ::core::option::Option<EntityRendererChangedInfo>,
    #[prost(bool, tag = "2")]
    pub is_server_cache: bool,
    #[prost(enumeration = "ForwardType", tag = "3")]
    pub forward_type: i32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(328)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimatorForceSetAirMoveNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
    #[prost(bool, tag = "3")]
    pub in_air_move: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiSkillCdInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub skill_group_cd_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub skill_cd_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(329)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtAiSyncSkillCdNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub ai_cd_map: ::std::collections::HashMap<u32, AiSkillCdInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(330)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtBeingHitsCombineNotify {
    #[prost(message, repeated, tag = "1")]
    pub evt_being_hit_info_list: ::prost::alloc::vec::Vec<EvtBeingHitInfo>,
    #[prost(enumeration = "ForwardType", tag = "2")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(331)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarSitDownNotify {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint64, tag = "2")]
    pub chair_id: u64,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(332)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarStandUpNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint64, tag = "2")]
    pub chair_id: u64,
    #[prost(int32, tag = "3")]
    pub perform_id: i32,
    #[prost(int32, tag = "4")]
    pub direction: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(333)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMassiveEntityReq {
    #[prost(message, repeated, tag = "1")]
    pub massive_entity_list: ::prost::alloc::vec::Vec<ClientMassiveEntity>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(334)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateMassiveEntityRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(335)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMassiveEntityNotify {
    #[prost(message, repeated, tag = "1")]
    pub massive_entity_list: ::prost::alloc::vec::Vec<ServerMassiveEntity>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(336)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestroyMassiveEntityNotify {
    #[prost(message, repeated, tag = "1")]
    pub massive_entity_list: ::prost::alloc::vec::Vec<ClientMassiveEntity>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(337)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MassiveEntityStateChangedNotify {
    #[prost(message, repeated, tag = "1")]
    pub massive_entity_state_list: ::prost::alloc::vec::Vec<MassiveEntityState>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamEntityInfo {
    #[prost(message, optional, tag = "1")]
    pub team_ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(uint32, tag = "2")]
    pub team_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub authority_peer_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(338)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncTeamEntityNotify {
    #[prost(message, repeated, tag = "1")]
    pub team_entity_info_list: ::prost::alloc::vec::Vec<TeamEntityInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(339)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelTeamEntityNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub del_entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtSyncSkillAnchorPosition {
    #[prost(message, optional, tag = "1")]
    pub skill_anchor_position: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CombatInvokeEntry {
    #[prost(bytes = "vec", tag = "1")]
    pub combat_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "CombatTypeArgument", tag = "2")]
    pub argument_type: i32,
    #[prost(enumeration = "ForwardType", tag = "3")]
    pub forward_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(340)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CombatInvocationsNotify {
    #[prost(message, repeated, tag = "1")]
    pub invoke_list: ::prost::alloc::vec::Vec<CombatInvokeEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(341)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerBuffChangeNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, tag = "2")]
    pub entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(bool, tag = "4")]
    pub is_creature_buff: bool,
    #[prost(enumeration = "ServerBuffChangeType", tag = "5")]
    pub server_buff_change_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiThreatInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub ai_threat_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(342)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvtAiSyncCombatThreatInfoNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub combat_threat_info_map: ::std::collections::HashMap<u32, AiThreatInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(343)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MassiveEntityElementOpBatchNotify {
    #[prost(int32, tag = "1")]
    pub entity_type: i32,
    #[prost(int32, tag = "2")]
    pub source_element_type: i32,
    #[prost(uint32, tag = "3")]
    pub user_id: u32,
    #[prost(float, tag = "4")]
    pub attack_element_durability: f32,
    #[prost(uint32, tag = "5")]
    pub op_idx: u32,
    #[prost(int32, tag = "6")]
    pub reaction_source_type: i32,
    #[prost(uint32, tag = "7")]
    pub attacker_id: u32,
    #[prost(oneof = "massive_entity_element_op_batch_notify::CheckShape", tags = "8, 9")]
    pub check_shape: ::core::option::Option<
        massive_entity_element_op_batch_notify::CheckShape,
    >,
}
/// Nested message and enum types in `MassiveEntityElementOpBatchNotify`.
pub mod massive_entity_element_op_batch_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum CheckShape {
        #[prost(message, tag = "8")]
        ShapeSphere(super::ShapeSphere),
        #[prost(message, tag = "9")]
        ShapeBox(super::ShapeBox),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiSyncInfo {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(bool, tag = "2")]
    pub is_self_killing: bool,
    #[prost(bool, tag = "3")]
    pub has_path_to_target: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(344)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityAiSyncNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub local_avatar_alerted_monster_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub info_list: ::prost::alloc::vec::Vec<AiSyncInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(345)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LuaSetOptionNotify {
    #[prost(string, tag = "1")]
    pub lua_set_param: ::prost::alloc::string::String,
    #[prost(enumeration = "LuaOptionType", tag = "2")]
    pub option_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(346)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtDestroyServerGadgetNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(347)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityAiKillSelfNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(348)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarLockChairReq {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint64, tag = "2")]
    pub chair_id: u64,
    #[prost(int32, tag = "3")]
    pub direction: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(349)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtAvatarLockChairRsp {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint64, tag = "2")]
    pub chair_id: u64,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
    #[prost(int32, tag = "5")]
    pub direction: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(350)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportFightAntiCheatNotify {
    #[prost(uint32, tag = "1")]
    pub cheat_type: u32,
    #[prost(uint32, tag = "2")]
    pub cheat_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(351)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtBeingHealedNotify {
    #[prost(float, tag = "1")]
    pub real_heal_amount: f32,
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
    #[prost(float, tag = "3")]
    pub heal_amount: f32,
    #[prost(uint32, tag = "4")]
    pub source_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(352)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EvtLocalGadgetOwnerLeaveSceneNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterFishingReq {
    #[prost(uint32, tag = "1")]
    pub fish_pool_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterFishingRsp {
    #[prost(uint32, tag = "1")]
    pub fish_pool_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartFishingReq {
    #[prost(uint32, tag = "1")]
    pub rod_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub fish_pool_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5804)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartFishingRsp {
    #[prost(uint32, tag = "1")]
    pub fish_pool_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishCastRodReq {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub bait_id: u32,
    #[prost(uint32, tag = "3")]
    pub rod_id: u32,
    #[prost(uint32, tag = "4")]
    pub rod_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5806)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishCastRodRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5807)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishChosenNotify {
    #[prost(uint32, tag = "1")]
    pub fish_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5808)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishEscapeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub fish_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
    #[prost(enumeration = "FishEscapeReason", tag = "4")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5809)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishBiteReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5810)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishBiteRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5811)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishBattleBeginReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5812)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishBattleBeginRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5813)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishBattleEndReq {
    #[prost(enumeration = "FishBattleResult", tag = "1")]
    pub battle_result: i32,
    #[prost(uint32, tag = "2")]
    pub max_bonus_time: u32,
    #[prost(bool, tag = "3")]
    pub is_always_bonus: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5814)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishBattleEndRsp {
    #[prost(message, repeated, tag = "1")]
    pub reward_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub drop_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "3")]
    pub talent_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(enumeration = "FishNoRewardReason", tag = "5")]
    pub no_reward_reason: i32,
    #[prost(bool, tag = "6")]
    pub is_got_reward: bool,
    #[prost(enumeration = "FishBattleResult", tag = "7")]
    pub battle_result: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5815)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitFishingReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5816)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitFishingRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5817)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishAttractNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub fish_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5818)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishBaitGoneNotify {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5819)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerFishingDataNotify {
    #[prost(uint32, tag = "1")]
    pub last_fish_rod_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5820)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishPoolDataNotify {
    #[prost(uint32, tag = "1")]
    pub today_fish_num: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGachaInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaUpInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub item_parent_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaInfo {
    #[prost(string, tag = "1")]
    pub gacha_record_url_oversea: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gacha_prob_url_oversea: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub gacha_up_info_list: ::prost::alloc::vec::Vec<GachaUpInfo>,
    #[prost(uint32, repeated, tag = "4")]
    pub display_up4_item_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "5")]
    pub gacha_prob_url: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "6")]
    pub display_up5_item_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "7")]
    pub gacha_prefab_path: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub gacha_preview_prefab_path: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub gacha_record_url: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub title_textmap: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub is_new_wish: bool,
    #[prost(uint32, tag = "12")]
    pub begin_time: u32,
    #[prost(uint32, tag = "13")]
    pub wish_item_id: u32,
    #[prost(uint32, tag = "14")]
    pub end_time: u32,
    #[prost(uint32, tag = "15")]
    pub cost_item_id: u32,
    #[prost(uint32, tag = "16")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "17")]
    pub wish_max_progress: u32,
    #[prost(uint32, tag = "18")]
    pub gacha_type: u32,
    #[prost(uint32, tag = "19")]
    pub wish_progress: u32,
    #[prost(uint32, tag = "20")]
    pub ten_cost_item_id: u32,
    #[prost(uint32, tag = "21")]
    pub gacha_times_limit: u32,
    #[prost(uint32, tag = "22")]
    pub cur_schedule_daily_gacha_times: u32,
    #[prost(uint32, tag = "23")]
    pub left_gacha_times: u32,
    #[prost(uint32, tag = "24")]
    pub cost_item_num: u32,
    #[prost(uint32, tag = "25")]
    pub ten_cost_item_num: u32,
    #[prost(uint32, tag = "26")]
    pub gacha_sort_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1502)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGachaInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub gacha_info_list: ::prost::alloc::vec::Vec<GachaInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub daily_gacha_times: u32,
    #[prost(bool, tag = "4")]
    pub is_under_general_restrict: bool,
    #[prost(bool, tag = "5")]
    pub is_under_minors_restrict: bool,
    #[prost(uint32, tag = "6")]
    pub gacha_random: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1503)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoGachaReq {
    #[prost(string, tag = "1")]
    pub gacha_tag: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub gacha_times: u32,
    #[prost(uint32, tag = "3")]
    pub gacha_type: u32,
    #[prost(uint32, tag = "4")]
    pub gacha_random: u32,
    #[prost(uint32, tag = "5")]
    pub gacha_schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaTransferItem {
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<ItemParam>,
    #[prost(bool, tag = "2")]
    pub is_transfer_item_new: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GachaItem {
    #[prost(message, optional, tag = "1")]
    pub gacha_item: ::core::option::Option<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub transfer_items: ::prost::alloc::vec::Vec<GachaTransferItem>,
    #[prost(message, repeated, tag = "3")]
    pub token_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(bool, tag = "4")]
    pub is_flash_card: bool,
    #[prost(bool, tag = "5")]
    pub is_gacha_item_new: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1504)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoGachaRsp {
    #[prost(message, repeated, tag = "1")]
    pub gacha_item_list: ::prost::alloc::vec::Vec<GachaItem>,
    #[prost(uint32, tag = "2")]
    pub cur_schedule_daily_gacha_times: u32,
    #[prost(uint32, tag = "3")]
    pub new_gacha_random: u32,
    #[prost(uint32, tag = "4")]
    pub wish_progress: u32,
    #[prost(uint32, tag = "5")]
    pub gacha_times: u32,
    #[prost(uint32, tag = "6")]
    pub wish_item_id: u32,
    #[prost(uint32, tag = "7")]
    pub gacha_type: u32,
    #[prost(uint32, tag = "8")]
    pub cost_item_id: u32,
    #[prost(uint32, tag = "9")]
    pub gacha_times_limit: u32,
    #[prost(int32, tag = "10")]
    pub retcode: i32,
    #[prost(uint32, tag = "11")]
    pub ten_cost_item_num: u32,
    #[prost(bool, tag = "12")]
    pub is_under_general_restrict: bool,
    #[prost(bool, tag = "13")]
    pub is_under_minors_restrict: bool,
    #[prost(uint32, tag = "14")]
    pub cost_item_num: u32,
    #[prost(uint32, tag = "15")]
    pub ten_cost_item_id: u32,
    #[prost(uint32, tag = "16")]
    pub wish_max_progress: u32,
    #[prost(uint32, tag = "17")]
    pub gacha_schedule_id: u32,
    #[prost(uint32, tag = "18")]
    pub daily_gacha_times: u32,
    #[prost(uint32, tag = "19")]
    pub left_gacha_times: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaWishReq {
    #[prost(uint32, tag = "1")]
    pub gacha_schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
    #[prost(uint32, tag = "3")]
    pub gacha_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1506)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaWishRsp {
    #[prost(uint32, tag = "1")]
    pub wish_item_id: u32,
    #[prost(uint32, tag = "2")]
    pub wish_max_progress: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub wish_progress: u32,
    #[prost(uint32, tag = "5")]
    pub gacha_type: u32,
    #[prost(uint32, tag = "6")]
    pub gacha_schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaOpenWishNotify {
    #[prost(uint32, tag = "1")]
    pub gacha_type: u32,
    #[prost(uint32, tag = "2")]
    pub gacha_schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1508)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GachaSimpleInfoNotify {
    #[prost(bool, tag = "1")]
    pub is_new: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1509)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjustGachaTimesNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub gacha_times_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetInteractReq {
    #[prost(uint32, tag = "1")]
    pub gadget_id: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
    #[prost(bool, tag = "3")]
    pub is_use_condense_resin: bool,
    #[prost(enumeration = "InterOpType", tag = "4")]
    pub op_type: i32,
    #[prost(enumeration = "ResinCostType", tag = "5")]
    pub resin_cost_type: i32,
    #[prost(uint32, tag = "6")]
    pub ui_interact_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetInteractRsp {
    #[prost(uint32, tag = "1")]
    pub gadget_entity_id: u32,
    #[prost(enumeration = "InteractType", tag = "2")]
    pub interact_type: i32,
    #[prost(uint32, tag = "3")]
    pub gadget_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(enumeration = "InterOpType", tag = "5")]
    pub op_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetStateNotify {
    #[prost(bool, tag = "1")]
    pub is_enable_interact: bool,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(804)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorktopOptionNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub option_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectWorktopOptionReq {
    #[prost(uint32, tag = "1")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub option_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(806)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelectWorktopOptionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub option_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(807)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BossChestActivateNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub qualify_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(808)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlossomChestInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub blossom_chest_info: ::core::option::Option<BlossomChestInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(809)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetPlayStartNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub start_time: u32,
    #[prost(uint32, tag = "3")]
    pub play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetPlayUidInfo {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub score: u32,
    #[prost(uint32, tag = "5")]
    pub icon: u32,
    #[prost(uint32, tag = "6")]
    pub battle_watcher_id: u32,
    #[prost(uint32, tag = "7")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(810)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetPlayStopNotify {
    #[prost(message, repeated, tag = "1")]
    pub uid_info_list: ::prost::alloc::vec::Vec<GadgetPlayUidInfo>,
    #[prost(uint32, tag = "2")]
    pub play_type: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(bool, tag = "4")]
    pub is_win: bool,
    #[prost(uint32, tag = "5")]
    pub cost_time: u32,
    #[prost(uint32, tag = "6")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(811)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetPlayDataNotify {
    #[prost(uint32, tag = "1")]
    pub progress: u32,
    #[prost(uint32, tag = "2")]
    pub play_type: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(812)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetPlayUidOpNotify {
    #[prost(string, tag = "1")]
    pub param_str: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "2")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub op: u32,
    #[prost(uint32, tag = "5")]
    pub entity_id: u32,
    #[prost(uint32, tag = "6")]
    pub play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(813)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetGeneralRewardInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub general_reward_info: ::core::option::Option<GadgetGeneralRewardInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(814)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetAutoPickDropInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<Item>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(815)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateAbilityCreatedMovingPlatformNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(enumeration = "OpType", tag = "2")]
    pub op_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(816)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FoundationReq {
    #[prost(enumeration = "FoundationOpType", tag = "1")]
    pub op_type: i32,
    #[prost(uint32, tag = "2")]
    pub building_id: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub point_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(817)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FoundationRsp {
    #[prost(uint32, tag = "1")]
    pub building_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_config_id: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(enumeration = "FoundationOpType", tag = "5")]
    pub op_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(818)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FoundationNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<FoundationInfo>,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(819)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetTalkChangeNotify {
    #[prost(uint32, tag = "1")]
    pub cur_gadget_talk_state: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(820)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetChainLevelUpdateNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gadget_chain_level_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(821)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetChainLevelChangeNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gadget_chain_level_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(822)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VehicleInteractReq {
    #[prost(bool, tag = "1")]
    pub is_need_destroy: bool,
    #[prost(uint32, tag = "2")]
    pub pos: u32,
    #[prost(enumeration = "VehicleInteractType", tag = "3")]
    pub interact_type: i32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(823)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VehicleInteractRsp {
    #[prost(message, optional, tag = "1")]
    pub enter_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub member: ::core::option::Option<VehicleMember>,
    #[prost(message, optional, tag = "3")]
    pub enter_rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub gadget_id: u32,
    #[prost(uint32, tag = "5")]
    pub entity_id: u32,
    #[prost(uint32, tag = "6")]
    pub vehicle_type: u32,
    #[prost(enumeration = "VehicleInteractType", tag = "7")]
    pub interact_type: i32,
    #[prost(int32, tag = "8")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(824)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateVehicleReq {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub scene_point_id: u32,
    #[prost(uint32, tag = "4")]
    pub vehicle_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(825)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateVehicleRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub vehicle_id: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(826)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestLiveInfoReq {
    #[prost(uint32, tag = "1")]
    pub live_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(827)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestLiveInfoRsp {
    #[prost(string, tag = "1")]
    pub spare_live_url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub live_url: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub live_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(828)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LiveStartNotify {
    #[prost(uint32, tag = "1")]
    pub live_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(829)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProjectorOptionReq {
    #[prost(uint32, tag = "1")]
    pub op_type: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(830)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProjectorOptionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub op_type: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(831)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LiveEndNotify {
    #[prost(uint32, tag = "1")]
    pub live_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(832)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VehicleStaminaNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(float, tag = "2")]
    pub cur_stamina: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(833)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetCustomTreeInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub custom_gadget_tree_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(834)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetChangeLevelTagReq {
    #[prost(message, optional, tag = "1")]
    pub combination_info: ::core::option::Option<CustomGadgetTreeInfo>,
    #[prost(uint32, tag = "2")]
    pub level_tag_id: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(835)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetChangeLevelTagRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(836)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NightCrowGadgetObservationMatchReq {
    #[prost(uint32, tag = "1")]
    pub target_gadget_state: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(837)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NightCrowGadgetObservationMatchRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeshretObeliskChestInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
    #[prost(uint32, tag = "4")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(838)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeshretObeliskChestInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub chest_info_list: ::prost::alloc::vec::Vec<DeshretObeliskChestInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(839)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneOwnerGadgetChainLevelNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gadget_chain_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "2")]
    pub is_enter_world: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryFlowerStartParam {
    #[prost(uint32, tag = "1")]
    pub target_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryElectroherculesBattleStartParam {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryStartNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub player_count: u32,
    #[prost(uint32, tag = "3")]
    pub start_time: u32,
    #[prost(uint32, tag = "4")]
    pub owner_uid: u32,
    #[prost(uint32, tag = "5")]
    pub end_time: u32,
    #[prost(oneof = "gallery_start_notify::Detail", tags = "6, 7")]
    pub detail: ::core::option::Option<gallery_start_notify::Detail>,
}
/// Nested message and enum types in `GalleryStartNotify`.
pub mod gallery_start_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "6")]
        FlowerStartParam(super::GalleryFlowerStartParam),
        #[prost(message, tag = "7")]
        ElectroherculesStartParam(super::GalleryElectroherculesBattleStartParam),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryBalloonShootNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(int32, tag = "2")]
    pub add_score: i32,
    #[prost(uint32, tag = "3")]
    pub cur_score: u32,
    #[prost(uint32, tag = "4")]
    pub trigger_entity_id: u32,
    #[prost(uint64, tag = "5")]
    pub combo_disable_time: u64,
    #[prost(uint32, tag = "6")]
    pub combo: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5503)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GalleryBalloonScoreNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub uid_score_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalloonSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub final_score: u32,
    #[prost(uint32, tag = "3")]
    pub max_combo: u32,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
    #[prost(uint32, tag = "5")]
    pub shoot_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryStopNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FallSettleInfo {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub flower_ring_catch_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "3")]
    pub catch_count: u32,
    #[prost(uint32, tag = "4")]
    pub remain_time: u32,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
    #[prost(uint32, tag = "6")]
    pub final_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5505)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GalleryFallCatchNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub ball_catch_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub time_cost: u32,
    #[prost(uint32, tag = "3")]
    pub add_score: u32,
    #[prost(bool, tag = "4")]
    pub is_ground: bool,
    #[prost(uint32, tag = "5")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "6")]
    pub cur_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FallPlayerBrief {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(bool, tag = "2")]
    pub is_ground: bool,
    #[prost(uint32, tag = "3")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5506)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GalleryFallScoreNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub uid_brief_map: ::std::collections::HashMap<u32, FallPlayerBrief>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BalloonPlayerInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub cur_score: u32,
    #[prost(uint32, tag = "3")]
    pub combo_disable_time: u32,
    #[prost(uint32, tag = "4")]
    pub combo: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FallPlayerInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub ball_catch_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "2")]
    pub is_ground: bool,
    #[prost(uint32, tag = "3")]
    pub cur_score: u32,
    #[prost(uint32, tag = "4")]
    pub uid: u32,
    #[prost(uint32, tag = "5")]
    pub time_cost: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryBalloonInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub scene_player_balloon_info_map: ::std::collections::HashMap<
        u32,
        BalloonPlayerInfo,
    >,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryFallInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub scene_player_fall_info_map: ::std::collections::HashMap<u32, FallPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryFlowerInfo {
    #[prost(uint32, tag = "1")]
    pub cur_score: u32,
    #[prost(uint32, tag = "2")]
    pub target_score: u32,
    #[prost(uint32, tag = "3")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryBulletInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub hit_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryBrokenFloorInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub fall_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryHideAndSeekInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub visible_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub caught_uid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryBuoyantCombatInfo {
    #[prost(uint32, tag = "1")]
    pub kill_special_monster_count: u32,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(uint32, tag = "3")]
    pub kill_monster_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryProgressInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub progress_stage_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub ui_form: u32,
    #[prost(uint32, tag = "4")]
    pub progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryBounceConjuringInfo {
    #[prost(uint32, tag = "1")]
    pub total_destroyed_machine_count: u32,
    #[prost(uint32, tag = "2")]
    pub total_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryHandballInfo {
    #[prost(message, optional, tag = "1")]
    pub ball_place_info: ::core::option::Option<PlaceInfo>,
    #[prost(bool, tag = "2")]
    pub is_have_ball: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySumoInfo {
    #[prost(uint32, tag = "1")]
    pub kill_normal_monster_num: u32,
    #[prost(uint32, tag = "2")]
    pub kill_elite_monster_num: u32,
    #[prost(uint32, tag = "3")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySalvagePreventInfo {
    #[prost(uint32, tag = "1")]
    pub monster_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySalvageEscortInfo {
    #[prost(uint32, tag = "1")]
    pub monster_count: u32,
    #[prost(uint32, tag = "2")]
    pub box_count: u32,
    #[prost(uint32, tag = "3")]
    pub max_monster_count: u32,
    #[prost(uint32, tag = "4")]
    pub max_box_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryCrystalLinkInfo {
    #[prost(uint32, tag = "1")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryIrodoriMasterInfo {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_cg_viewed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryHomeBalloonInfo {
    #[prost(uint32, tag = "1")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryLuminanceStoneChallengeInfo {
    #[prost(uint32, tag = "1")]
    pub clean_mud_count: u32,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(uint32, tag = "3")]
    pub kill_monster_count: u32,
    #[prost(uint32, tag = "4")]
    pub kill_special_monster_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryHomeSeekFurnitureInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub player_score_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub cur_tide_duration_time: u32,
    #[prost(uint32, tag = "3")]
    pub cur_tide_left_num: u32,
    #[prost(uint32, tag = "4")]
    pub cur_tide_total_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryIslandPartyDownHillInfo {
    #[prost(uint32, tag = "1")]
    pub total_kill_monster_count: u32,
    #[prost(enumeration = "GalleryStartSource", tag = "2")]
    pub start_source: i32,
    #[prost(uint32, tag = "3")]
    pub max_kill_monster_count: u32,
    #[prost(uint32, tag = "4")]
    pub coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySummerTimeV2BoatInfo {
    #[prost(uint32, tag = "1")]
    pub param1: u32,
    #[prost(uint32, tag = "2")]
    pub used_time: u32,
    #[prost(uint32, tag = "3")]
    pub param3: u32,
    #[prost(uint32, tag = "4")]
    pub param2: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryIslandPartyRaftInfo {
    #[prost(uint32, tag = "1")]
    pub raft_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub coin: u32,
    #[prost(uint32, tag = "3")]
    pub fuel: u32,
    #[prost(uint32, tag = "4")]
    pub point_id: u32,
    #[prost(enumeration = "GalleryStartSource", tag = "5")]
    pub start_source: i32,
    #[prost(uint32, tag = "6")]
    pub component: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryIslandPartySailInfo {
    #[prost(uint32, tag = "1")]
    pub max_kill_progress: u32,
    #[prost(uint32, tag = "2")]
    pub max_clean_progress: u32,
    #[prost(uint32, tag = "3")]
    pub clean_progress: u32,
    #[prost(enumeration = "IslandPartySailStage", tag = "4")]
    pub stage: i32,
    #[prost(enumeration = "GalleryStartSource", tag = "5")]
    pub start_source: i32,
    #[prost(uint32, tag = "6")]
    pub kill_progress: u32,
    #[prost(uint32, tag = "7")]
    pub coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryInstableSprayBuffInfo {
    #[prost(uint64, tag = "1")]
    pub buff_max_time: u64,
    #[prost(uint32, tag = "2")]
    pub buff_id: u32,
    #[prost(uint64, tag = "3")]
    pub buff_end_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryInstableSprayInfo {
    #[prost(message, repeated, tag = "1")]
    pub buff_info_list: ::prost::alloc::vec::Vec<SceneGalleryInstableSprayBuffInfo>,
    #[prost(uint32, tag = "2")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryTreasureSeelieInfo {
    #[prost(uint32, tag = "1")]
    pub progress: u32,
    #[prost(uint32, tag = "2")]
    pub goal: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryWindFieldInfo {
    #[prost(uint32, tag = "1")]
    pub challenge_timestamp: u32,
    #[prost(uint32, tag = "2")]
    pub killed_monster_num: u32,
    #[prost(uint32, tag = "3")]
    pub challenge_ball_max_count: u32,
    #[prost(uint32, tag = "4")]
    pub challenge_ball_cur_count: u32,
    #[prost(uint32, tag = "5")]
    pub coin_num: u32,
    #[prost(uint32, tag = "6")]
    pub challenge_total_time: u32,
    #[prost(uint32, tag = "7")]
    pub show_id: u32,
    #[prost(uint32, tag = "8")]
    pub element_ball_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryFungusFighterTrainingInfo {
    #[prost(uint32, tag = "1")]
    pub max_monster_count: u32,
    #[prost(uint32, tag = "2")]
    pub killed_monster_count: u32,
    #[prost(uint32, tag = "3")]
    pub rest_skill_count: u32,
    #[prost(uint32, tag = "4")]
    pub max_skill_count: u32,
    #[prost(uint32, tag = "5")]
    pub buff_start_time: u32,
    #[prost(uint32, tag = "6")]
    pub buff_last_time: u32,
    #[prost(uint32, tag = "7")]
    pub buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryFungusFighterCaptureInfo {
    #[prost(bool, tag = "1")]
    pub is_hide_progress: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryEffigyChallengeV2Info {
    #[prost(uint32, tag = "1")]
    pub scene_start_time: u32,
    #[prost(uint32, tag = "2")]
    pub total_target_kill_cnt: u32,
    #[prost(uint32, tag = "3")]
    pub boss_violent_level: u32,
    #[prost(uint32, tag = "4")]
    pub t_remain_use_time: u32,
    #[prost(uint32, tag = "5")]
    pub killed_monster_cnt: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryCharAmusementInfo {
    #[prost(uint32, tag = "1")]
    pub max_score: u32,
    #[prost(bool, tag = "2")]
    pub is_finish: bool,
    #[prost(bool, tag = "3")]
    pub is_last_level: bool,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(uint32, tag = "5")]
    pub cur_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryCoinCollectInfo {
    #[prost(uint32, tag = "1")]
    pub coin_collect_num: u32,
    #[prost(uint32, tag = "2")]
    pub coin_total_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryTeamChainInfo {
    #[prost(uint32, tag = "1")]
    pub cur_total_score: u32,
    #[prost(uint32, tag = "2")]
    pub total_target_kill_cnt: u32,
    #[prost(uint32, tag = "3")]
    pub killed_monster_cnt: u32,
    #[prost(uint32, tag = "4")]
    pub cur_gallery_idx: u32,
    #[prost(uint32, tag = "5")]
    pub gallery_score_end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryDuelHeartInfo {
    #[prost(uint32, tag = "1")]
    pub difficulty: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatMultiPlayerData {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub accumulate_coin_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryLanV3BoatMultiInfo {
    #[prost(message, repeated, tag = "1")]
    pub player_data: ::prost::alloc::vec::Vec<LanV3BoatMultiPlayerData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryPacmanInfo {
    #[prost(uint32, tag = "1")]
    pub killed_monster_num: u32,
    #[prost(uint32, tag = "2")]
    pub coin_num: u32,
    #[prost(uint32, tag = "3")]
    pub cur_score: u32,
    #[prost(uint32, tag = "4")]
    pub start_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryFungusFighterV2Info {
    #[prost(message, repeated, tag = "1")]
    pub fungus_info_list: ::prost::alloc::vec::Vec<FungusInfo>,
    #[prost(string, tag = "2")]
    pub transaction: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub total_tower_count: u32,
    #[prost(uint64, tag = "4")]
    pub kaoacldknee: u64,
    #[prost(uint32, tag = "5")]
    pub defeated_tower_count: u32,
    #[prost(float, tag = "6")]
    pub energy_point: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusInfo {
    #[prost(uint64, tag = "1")]
    pub use_skill_time: u64,
    #[prost(bool, tag = "2")]
    pub is_alive: bool,
    #[prost(uint32, tag = "3")]
    pub fungus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryAkaFesArchaeologyInfo {
    #[prost(uint32, tag = "1")]
    pub total_count: u32,
    #[prost(uint32, tag = "2")]
    pub found_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryAkaFesRhythmInfo {
    #[prost(string, tag = "1")]
    pub transaction: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_adjust: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySandwormInfo {
    #[prost(bool, tag = "1")]
    pub is_sandworm_appear: bool,
    #[prost(enumeration = "SceneGallerySandwormCannonSpecialEffectType", tag = "2")]
    pub special_effect_type: i32,
    #[prost(uint32, tag = "3")]
    pub energy: u32,
    #[prost(uint32, tag = "4")]
    pub max_energy: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySorushTrialPhotoMatchInfo {
    #[prost(bool, tag = "1")]
    pub is_change_stage: bool,
    #[prost(bool, tag = "2")]
    pub is_hide_time_end: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGallerySorushTrialHitmanInfo {
    #[prost(uint64, tag = "1")]
    pub trans_no: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryJourneyDiceInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub dice_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub kill_normal_monster_num: u32,
    #[prost(uint32, tag = "3")]
    pub kill_elite_monster_num: u32,
    #[prost(uint32, tag = "4")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomGalleryProgressInfo {
    #[prost(string, repeated, tag = "1")]
    pub score_board_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "2")]
    pub progress_id: u32,
    #[prost(uint32, tag = "3")]
    pub show_state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomGalleryNormalScoreBoard {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomGalleryCountdownScoreBoard {
    #[prost(uint32, tag = "1")]
    pub start_time: u32,
    #[prost(int32, tag = "2")]
    pub passed_time: i32,
    #[prost(bool, tag = "3")]
    pub is_paused: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomGalleryTimerScoreBoard {
    #[prost(uint32, tag = "1")]
    pub start_time: u32,
    #[prost(int32, tag = "2")]
    pub passed_time: i32,
    #[prost(bool, tag = "3")]
    pub is_paused: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomGalleryScoreBoardInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "2")]
    pub progress_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub current_score: u32,
    #[prost(enumeration = "CustomGalleryScoreBoardType", tag = "4")]
    pub r#type: i32,
    #[prost(uint32, tag = "5")]
    pub target_score: u32,
    #[prost(oneof = "custom_gallery_score_board_info::Detail", tags = "6, 7, 8")]
    pub detail: ::core::option::Option<custom_gallery_score_board_info::Detail>,
}
/// Nested message and enum types in `CustomGalleryScoreBoardInfo`.
pub mod custom_gallery_score_board_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "6")]
        Normal(super::CustomGalleryNormalScoreBoard),
        #[prost(message, tag = "7")]
        Countdown(super::CustomGalleryCountdownScoreBoard),
        #[prost(message, tag = "8")]
        Timer(super::CustomGalleryTimerScoreBoard),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomGalleryInfo {
    #[prost(message, repeated, tag = "1")]
    pub score_board_list: ::prost::alloc::vec::Vec<CustomGalleryScoreBoardInfo>,
    #[prost(message, repeated, tag = "2")]
    pub progress_list: ::prost::alloc::vec::Vec<CustomGalleryProgressInfo>,
    #[prost(uint32, repeated, tag = "3")]
    pub modified_progress_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "4")]
    pub is_need_update: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryInfo {
    #[prost(message, optional, tag = "1")]
    pub custom_gallery_info: ::core::option::Option<CustomGalleryInfo>,
    #[prost(message, repeated, tag = "2")]
    pub progress_info_list: ::prost::alloc::vec::Vec<SceneGalleryProgressInfo>,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "4")]
    pub player_count: u32,
    #[prost(enumeration = "GalleryStageType", tag = "5")]
    pub stage: i32,
    #[prost(uint32, tag = "6")]
    pub end_time: u32,
    #[prost(uint32, tag = "7")]
    pub owner_uid: u32,
    #[prost(uint32, tag = "8")]
    pub pre_start_end_time: u32,
    #[prost(uint32, tag = "9")]
    pub start_time: u32,
    #[prost(
        oneof = "scene_gallery_info::Info",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51"
    )]
    pub info: ::core::option::Option<scene_gallery_info::Info>,
}
/// Nested message and enum types in `SceneGalleryInfo`.
pub mod scene_gallery_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Info {
        #[prost(message, tag = "10")]
        BalloonInfo(super::SceneGalleryBalloonInfo),
        #[prost(message, tag = "11")]
        FallInfo(super::SceneGalleryFallInfo),
        #[prost(message, tag = "12")]
        FlowerInfo(super::SceneGalleryFlowerInfo),
        #[prost(message, tag = "13")]
        BulletInfo(super::SceneGalleryBulletInfo),
        #[prost(message, tag = "14")]
        BrokenFloorInfo(super::SceneGalleryBrokenFloorInfo),
        #[prost(message, tag = "15")]
        HideAndSeekInfo(super::SceneGalleryHideAndSeekInfo),
        #[prost(message, tag = "16")]
        BuoyantCombatInfo(super::SceneGalleryBuoyantCombatInfo),
        #[prost(message, tag = "17")]
        BounceConjuringInfo(super::SceneGalleryBounceConjuringInfo),
        #[prost(message, tag = "18")]
        HandballInfo(super::SceneGalleryHandballInfo),
        #[prost(message, tag = "19")]
        SumoInfo(super::SceneGallerySumoInfo),
        #[prost(message, tag = "20")]
        SalvagePreventInfo(super::SceneGallerySalvagePreventInfo),
        #[prost(message, tag = "21")]
        SalvageEscortInfo(super::SceneGallerySalvageEscortInfo),
        #[prost(message, tag = "22")]
        HomeBalloonInfo(super::SceneGalleryHomeBalloonInfo),
        #[prost(message, tag = "23")]
        CrystalLinkInfo(super::SceneGalleryCrystalLinkInfo),
        #[prost(message, tag = "24")]
        IrodoriMasterInfo(super::SceneGalleryIrodoriMasterInfo),
        #[prost(message, tag = "25")]
        LuminanceStoneChallengeInfo(super::SceneGalleryLuminanceStoneChallengeInfo),
        #[prost(message, tag = "26")]
        HomeSeekFurnitureInfo(super::SceneGalleryHomeSeekFurnitureInfo),
        #[prost(message, tag = "27")]
        IslandPartyDownHillInfo(super::SceneGalleryIslandPartyDownHillInfo),
        #[prost(message, tag = "28")]
        SummerTimeV2BoatInfo(super::SceneGallerySummerTimeV2BoatInfo),
        #[prost(message, tag = "29")]
        IslandPartyRaftInfo(super::SceneGalleryIslandPartyRaftInfo),
        #[prost(message, tag = "30")]
        IslandPartySailInfo(super::SceneGalleryIslandPartySailInfo),
        #[prost(message, tag = "31")]
        InstableSprayInfo(super::SceneGalleryInstableSprayInfo),
        #[prost(message, tag = "32")]
        MuqadasPotionInfo(super::SceneGalleryMuqadasPotionInfo),
        #[prost(message, tag = "33")]
        TreasureSeelieInfo(super::SceneGalleryTreasureSeelieInfo),
        #[prost(message, tag = "34")]
        VintageHuntingInfo(super::SceneGalleryVintageHuntingInfo),
        #[prost(message, tag = "35")]
        WindFieldInfo(super::SceneGalleryWindFieldInfo),
        #[prost(message, tag = "36")]
        FungusFighterTrainingInfo(super::SceneGalleryFungusFighterTrainingInfo),
        #[prost(message, tag = "37")]
        EffigyChallengeInfo(super::SceneGalleryEffigyChallengeV2Info),
        #[prost(message, tag = "38")]
        FungusFighterCaptureInfo(super::SceneGalleryFungusFighterCaptureInfo),
        #[prost(message, tag = "39")]
        CharAmusementInfo(super::SceneGalleryCharAmusementInfo),
        #[prost(message, tag = "40")]
        CoinCollectInfo(super::SceneGalleryCoinCollectInfo),
        #[prost(message, tag = "41")]
        TeamChainInfo(super::SceneGalleryTeamChainInfo),
        #[prost(message, tag = "42")]
        DuelHeartInfo(super::SceneGalleryDuelHeartInfo),
        #[prost(message, tag = "43")]
        BoatMultiInfo(super::SceneGalleryLanV3BoatMultiInfo),
        #[prost(message, tag = "44")]
        PacmanInfo(super::SceneGalleryPacmanInfo),
        #[prost(message, tag = "45")]
        FungusFighterV2Info(super::SceneGalleryFungusFighterV2Info),
        #[prost(message, tag = "46")]
        AkaFesArchaeologyInfo(super::SceneGalleryAkaFesArchaeologyInfo),
        #[prost(message, tag = "47")]
        SandwormInfo(super::SceneGallerySandwormInfo),
        #[prost(message, tag = "48")]
        SorushTrialPhotoMatchInfo(super::SceneGallerySorushTrialPhotoMatchInfo),
        #[prost(message, tag = "49")]
        SorushTrialHitmanInfo(super::SceneGallerySorushTrialHitmanInfo),
        #[prost(message, tag = "50")]
        AkaFesRhythmInfo(super::SceneGalleryAkaFesRhythmInfo),
        #[prost(message, tag = "51")]
        JourneyDiceInfo(super::SceneGalleryJourneyDiceInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllSceneGalleryInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5508)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllSceneGalleryInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub gallery_info_list: ::prost::alloc::vec::Vec<SceneGalleryInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5509)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryFlowerCatchNotify {
    #[prost(uint32, tag = "1")]
    pub add_score: u32,
    #[prost(uint32, tag = "2")]
    pub cur_score: u32,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5510)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryPreStartNotify {
    #[prost(uint32, tag = "1")]
    pub pre_start_end_time: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5511)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryBulletHitNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub hit_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5512)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryBrokenFloorFallNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub fall_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5513)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterruptGalleryReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5514)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterruptGalleryRsp {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5515)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGalleryInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub gallery_info: ::core::option::Option<SceneGalleryInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuoyantCombatGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub kill_monster_count: u32,
    #[prost(uint32, tag = "2")]
    pub kill_special_monster_count: u32,
    #[prost(uint32, tag = "3")]
    pub final_score: u32,
    #[prost(uint32, tag = "4")]
    pub gallery_level: u32,
    #[prost(uint32, tag = "5")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "6")]
    pub kill_target_count: u32,
    #[prost(uint32, tag = "7")]
    pub gallery_multiple: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BounceConjuringGallerySettleInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub gadget_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, optional, tag = "2")]
    pub player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(message, repeated, tag = "3")]
    pub card_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(uint32, tag = "4")]
    pub perfect_hit_count: u32,
    #[prost(float, tag = "5")]
    pub damage: f32,
    #[prost(uint32, tag = "6")]
    pub fever_count: u32,
    #[prost(uint32, tag = "7")]
    pub normal_hit_count: u32,
    #[prost(uint32, tag = "8")]
    pub destroyed_machine_count: u32,
    #[prost(uint32, tag = "9")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5516)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryBounceConjuringHitNotify {
    #[prost(bool, tag = "1")]
    pub is_perfect: bool,
    #[prost(uint32, tag = "2")]
    pub add_score: u32,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5517)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GallerySumoKillMonsterNotify {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "3")]
    pub kill_elite_monster_num: u32,
    #[prost(uint32, tag = "4")]
    pub kill_normal_monster_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5518)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryCrystalLinkKillMonsterNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5519)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryCrystalLinkBuffInfoNotify {
    #[prost(bool, tag = "1")]
    pub is_buff_valid: bool,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "3")]
    pub buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishInfo {
    #[prost(uint32, tag = "1")]
    pub free_count: u32,
    #[prost(uint32, tag = "2")]
    pub into_bag_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishingScore {
    #[prost(bool, tag = "1")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "2")]
    pub fishing_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishingGallerySettleInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub fish_map: ::std::collections::HashMap<u32, FishInfo>,
    #[prost(message, repeated, tag = "2")]
    pub fishing_score_list: ::prost::alloc::vec::Vec<FishingScore>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RacingGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub winner_uid: u32,
    #[prost(uint32, tag = "2")]
    pub use_time: u32,
    #[prost(enumeration = "GalleryStopReason", tag = "3")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvagePreventGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub monster_count: u32,
    #[prost(uint32, tag = "2")]
    pub time_remain: u32,
    #[prost(enumeration = "SalvagePreventStopReason", tag = "3")]
    pub reason: i32,
    #[prost(uint32, tag = "4")]
    pub final_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SalvageEscortGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub time_remain: u32,
    #[prost(enumeration = "SalvageEscortStopReason", tag = "2")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BalloonGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub score: u32,
    #[prost(uint32, tag = "2")]
    pub owner_uid: u32,
    #[prost(uint32, tag = "3")]
    pub hit_count: u32,
    #[prost(enumeration = "GalleryStopReason", tag = "4")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriMasterGallerySettleInfo {
    #[prost(enumeration = "GalleryStopReason", tag = "1")]
    pub reason: i32,
    #[prost(uint32, tag = "2")]
    pub difficult: u32,
    #[prost(uint32, tag = "3")]
    pub finish_time: u32,
    #[prost(uint32, tag = "4")]
    pub level_id: u32,
    #[prost(bool, tag = "5")]
    pub is_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LuminanceStoneChallengeGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub kill_monster_count: u32,
    #[prost(uint32, tag = "2")]
    pub final_score: u32,
    #[prost(uint32, tag = "3")]
    pub kill_special_monster_count: u32,
    #[prost(enumeration = "GalleryStopReason", tag = "4")]
    pub reason: i32,
    #[prost(uint32, tag = "5")]
    pub clean_mud_count: u32,
    #[prost(uint32, tag = "6")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5520)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeGalleryInPlayingNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummerTimeV2BoatGallerySettleInfo {
    #[prost(uint32, tag = "1")]
    pub param3: u32,
    #[prost(uint32, tag = "2")]
    pub param1: u32,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "4")]
    pub param2: u32,
    #[prost(uint32, tag = "5")]
    pub used_time: u32,
    #[prost(enumeration = "GalleryStopReason", tag = "6")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5521)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryIslandPartyDownHillInfoNotify {
    #[prost(uint32, tag = "1")]
    pub coin: u32,
    #[prost(uint32, tag = "2")]
    pub total_kill_monster_count: u32,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5522)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IslandPartyRaftInfoNotify {
    #[prost(uint32, tag = "1")]
    pub component: u32,
    #[prost(uint32, tag = "2")]
    pub fuel: u32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
    #[prost(uint32, tag = "4")]
    pub coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5523)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IslandPartySailInfoNotify {
    #[prost(uint32, tag = "1")]
    pub progress: u32,
    #[prost(uint32, tag = "2")]
    pub kill_monster_count: u32,
    #[prost(enumeration = "IslandPartySailStage", tag = "3")]
    pub stage: i32,
    #[prost(uint32, tag = "4")]
    pub coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IslandPartyGallerySettleInfo {
    #[prost(message, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(message, optional, tag = "2")]
    pub player_info: ::core::option::Option<OnlinePlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5524)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackRebornGalleryReq {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5525)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackRebornGalleryRsp {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5526)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryWillStartCountdownNotify {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
    #[prost(bool, tag = "3")]
    pub is_end: bool,
    #[prost(enumeration = "GalleryStartSource", tag = "4")]
    pub start_source: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5527)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstableSprayGalleryInfoNotify {
    #[prost(uint32, tag = "1")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryMuqadasPotionInfo {
    #[prost(uint32, tag = "1")]
    pub skill_energy: u32,
    #[prost(uint32, tag = "2")]
    pub capture_weakness_count: u32,
    #[prost(uint32, tag = "3")]
    pub score: u32,
    #[prost(uint32, tag = "4")]
    pub skill_use_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingFirstStageInfo {
    #[prost(uint32, tag = "1")]
    pub elite_cnt: u32,
    #[prost(uint32, tag = "2")]
    pub brutal_cnt: u32,
    #[prost(uint32, tag = "3")]
    pub score: u32,
    #[prost(uint32, tag = "4")]
    pub timid_cnt: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingSecondStageInfo {
    #[prost(uint32, tag = "1")]
    pub capture_animal_num: u32,
    #[prost(uint32, tag = "2")]
    pub total_num: u32,
    #[prost(uint32, tag = "3")]
    pub left_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VintageHuntingThirdStageInfo {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneGalleryVintageHuntingInfo {
    #[prost(uint32, tag = "1")]
    pub stage_id: u32,
    #[prost(oneof = "scene_gallery_vintage_hunting_info::Info", tags = "2, 3, 4")]
    pub info: ::core::option::Option<scene_gallery_vintage_hunting_info::Info>,
}
/// Nested message and enum types in `SceneGalleryVintageHuntingInfo`.
pub mod scene_gallery_vintage_hunting_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Info {
        #[prost(message, tag = "2")]
        FirstStageInfo(super::VintageHuntingFirstStageInfo),
        #[prost(message, tag = "3")]
        SecondStageInfo(super::VintageHuntingSecondStageInfo),
        #[prost(message, tag = "4")]
        ThirdStageInfo(super::VintageHuntingThirdStageInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5528)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindFieldGalleryInfoNotify {
    #[prost(uint32, tag = "1")]
    pub challenge_total_time: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_ball_max_count: u32,
    #[prost(uint32, tag = "3")]
    pub show_id: u32,
    #[prost(uint32, tag = "4")]
    pub coin_num: u32,
    #[prost(uint32, tag = "5")]
    pub challenge_ball_cur_count: u32,
    #[prost(uint32, tag = "6")]
    pub element_ball_num: u32,
    #[prost(uint32, tag = "7")]
    pub killed_monster_num: u32,
    #[prost(uint32, tag = "8")]
    pub challenge_timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5529)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindFieldGalleryChallengeInfoNotify {
    #[prost(uint32, tag = "1")]
    pub challenge_total_time: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_ball_cur_count: u32,
    #[prost(uint32, tag = "3")]
    pub show_id: u32,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(bool, tag = "5")]
    pub is_start: bool,
    #[prost(uint32, tag = "6")]
    pub challenge_ball_max_count: u32,
    #[prost(uint32, tag = "7")]
    pub challenge_timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5530)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusFighterTrainingInfoNotify {
    #[prost(uint32, tag = "1")]
    pub buff_id: u32,
    #[prost(uint32, tag = "2")]
    pub max_monster_count: u32,
    #[prost(uint32, tag = "3")]
    pub buff_last_time: u32,
    #[prost(uint32, tag = "4")]
    pub max_skill_count: u32,
    #[prost(uint32, tag = "5")]
    pub killed_monster_count: u32,
    #[prost(uint32, tag = "6")]
    pub rest_skill_count: u32,
    #[prost(uint32, tag = "7")]
    pub buff_start_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5531)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FungusCaptureSettleNotify {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5532)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HideAndSeekPlayerCapturedNotify {
    #[prost(uint32, tag = "1")]
    pub ghost_skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5533)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectGallerySettleNotify {
    #[prost(uint32, tag = "1")]
    pub multistage_play_index: u32,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub coin_collect_num: u32,
    #[prost(uint32, tag = "5")]
    pub coin_collect_time: u32,
    #[prost(uint32, tag = "6")]
    pub coin_total_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5534)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomGalleryScoreBoardUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub score_board: ::core::option::Option<CustomGalleryScoreBoardInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5535)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomGalleryProgressUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub progress: ::core::option::Option<CustomGalleryProgressInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5536)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomGalleryTargetNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5537)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryInitNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5538)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GalleryEndTimeChangeNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5539)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialRaceGallerySettleNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "2")]
    pub total_coin_count: u32,
    #[prost(uint32, tag = "3")]
    pub pick_up_coin_count: u32,
    #[prost(bool, tag = "4")]
    pub is_max_score: bool,
    #[prost(bool, tag = "5")]
    pub is_success: bool,
    #[prost(uint32, tag = "6")]
    pub rest_time: u32,
    #[prost(uint32, tag = "7")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5540)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialHitmanGallerySettleNotify {
    #[prost(uint32, tag = "1")]
    pub gallery_id: u32,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(uint32, tag = "3")]
    pub hit_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5541)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushTrialPhotoMatchGallerySettleNotify {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgAttackCostInfo {
    #[prost(message, repeated, tag = "1")]
    pub cost_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPlayCardCostInfo {
    #[prost(message, repeated, tag = "1")]
    pub cost_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSelectOnStageCostInfo {
    #[prost(message, repeated, tag = "1")]
    pub cost_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCostReviseInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub can_use_hand_card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub select_on_stage_cost_list: ::prost::alloc::vec::Vec<GcgSelectOnStageCostInfo>,
    #[prost(message, repeated, tag = "3")]
    pub attack_cost_list: ::prost::alloc::vec::Vec<GcgAttackCostInfo>,
    #[prost(message, repeated, tag = "4")]
    pub play_card_cost_list: ::prost::alloc::vec::Vec<GcgPlayCardCostInfo>,
    #[prost(bool, tag = "5")]
    pub is_can_attack: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgTokenChange {
    #[prost(uint32, tag = "1")]
    pub before: u32,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
    #[prost(enumeration = "GcgReason", tag = "3")]
    pub reason: i32,
    #[prost(uint32, tag = "4")]
    pub after: u32,
    #[prost(uint32, tag = "5")]
    pub token_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgPhaseChange {
    #[prost(message, repeated, tag = "1")]
    pub allow_controller_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(enumeration = "GcgPhaseType", tag = "2")]
    pub before_phase: i32,
    #[prost(enumeration = "GcgPhaseType", tag = "3")]
    pub after_phase: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgAddCards {
    #[prost(uint32, repeated, tag = "1")]
    pub card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "GcgZoneType", tag = "2")]
    pub zone: i32,
    #[prost(uint32, tag = "3")]
    pub controller_id: u32,
    #[prost(uint32, tag = "4")]
    pub pos: u32,
    #[prost(enumeration = "GcgReason", tag = "5")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgRemoveCards {
    #[prost(uint32, repeated, tag = "1")]
    pub card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgReason", tag = "3")]
    pub reason: i32,
    #[prost(enumeration = "GcgZoneType", tag = "4")]
    pub zone: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgMoveCard {
    #[prost(uint32, repeated, tag = "1")]
    pub fail_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "GcgZoneType", tag = "3")]
    pub to: i32,
    #[prost(enumeration = "GcgReason", tag = "4")]
    pub reason: i32,
    #[prost(uint32, tag = "5")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgZoneType", tag = "6")]
    pub from: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgSelectOnStage {
    #[prost(enumeration = "GcgReason", tag = "1")]
    pub reason: i32,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
    #[prost(uint32, tag = "3")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgSelectOnStageByEffect {
    #[prost(uint32, tag = "1")]
    pub controller_id: u32,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
    #[prost(uint32, tag = "3")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgDiceRoll {
    #[prost(enumeration = "GcgDiceSideType", repeated, tag = "1")]
    pub dice_side_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
    #[prost(uint32, tag = "3")]
    pub dice_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgDiceReroll {
    #[prost(enumeration = "GcgDiceSideType", repeated, tag = "1")]
    pub dice_side_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "2")]
    pub select_dice_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgPass {
    #[prost(uint32, tag = "1")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgUseSkill {
    #[prost(uint32, tag = "1")]
    pub skill_id: u32,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgUseSkillEnd {
    #[prost(uint32, tag = "1")]
    pub card_guid: u32,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgDamageDetail {
    #[prost(uint32, tag = "1")]
    pub skill_id: u32,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgSkillResult {
    #[prost(message, repeated, tag = "1")]
    pub detail_list: ::prost::alloc::vec::Vec<GcgDamageDetail>,
    #[prost(uint32, tag = "2")]
    pub from_result_seq: u32,
    #[prost(uint32, tag = "3")]
    pub last_hp: u32,
    #[prost(uint32, tag = "4")]
    pub result_seq: u32,
    #[prost(uint32, tag = "5")]
    pub before_hp: u32,
    #[prost(uint32, tag = "6")]
    pub skill_id: u32,
    #[prost(uint32, tag = "7")]
    pub target_card_guid: u32,
    #[prost(uint32, tag = "8")]
    pub damage: u32,
    #[prost(uint32, tag = "9")]
    pub effect_element: u32,
    #[prost(uint32, tag = "10")]
    pub flag: u32,
    #[prost(uint32, tag = "11")]
    pub src_card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgLimitsInfo {
    #[prost(uint32, tag = "1")]
    pub limit_type: u32,
    #[prost(uint32, tag = "2")]
    pub limit_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillLimitsInfo {
    #[prost(message, repeated, tag = "1")]
    pub limits_list: ::prost::alloc::vec::Vec<GcgLimitsInfo>,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCardSkillLimitsInfo {
    #[prost(message, repeated, tag = "1")]
    pub skill_limits_list: ::prost::alloc::vec::Vec<GcgSkillLimitsInfo>,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgSkillLimitsChange {
    #[prost(message, repeated, tag = "1")]
    pub card_limits_change_list: ::prost::alloc::vec::Vec<GcgCardSkillLimitsInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgCostDice {
    #[prost(uint32, repeated, tag = "1")]
    pub select_dice_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgReason", tag = "3")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgAddDice {
    #[prost(map = "uint32, enumeration(GcgDiceSideType)", tag = "1")]
    pub before_dice_map: ::std::collections::HashMap<u32, i32>,
    #[prost(map = "uint32, enumeration(GcgDiceSideType)", tag = "2")]
    pub dice_map: ::std::collections::HashMap<u32, i32>,
    #[prost(int32, tag = "3")]
    pub change_count: i32,
    #[prost(uint32, tag = "4")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgReason", tag = "5")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgNewCard {
    #[prost(message, optional, tag = "1")]
    pub card: ::core::option::Option<GcgCard>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgUpdateController {
    #[prost(message, repeated, tag = "1")]
    pub allow_controller_list: ::prost::alloc::vec::Vec<Uint32Pair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgModifyAdd {
    #[prost(uint32, repeated, tag = "1")]
    pub card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgReason", tag = "3")]
    pub reason: i32,
    #[prost(uint32, tag = "4")]
    pub owner_card_guid: u32,
    #[prost(uint32, tag = "5")]
    pub pos: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgModifyRemove {
    #[prost(uint32, repeated, tag = "1")]
    pub card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "GcgReason", tag = "2")]
    pub reason: i32,
    #[prost(uint32, tag = "3")]
    pub controller_id: u32,
    #[prost(uint32, tag = "4")]
    pub owner_card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgPveIntention {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgPveIntentionInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub intention_map: ::std::collections::HashMap<u32, GcgMsgPveIntention>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgPveIntentionChange {
    #[prost(message, repeated, tag = "1")]
    pub change_intention_list: ::prost::alloc::vec::Vec<GcgMsgPveIntention>,
    #[prost(enumeration = "GcgIntentionChangeType", tag = "2")]
    pub change_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgDuelDataChange {
    #[prost(uint32, tag = "1")]
    pub round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgClientPerform {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "GcgClientPerformType", tag = "2")]
    pub perform_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgGameOver {
    #[prost(enumeration = "GcgEndReason", tag = "1")]
    pub end_reason: i32,
    #[prost(uint32, tag = "2")]
    pub win_controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgOpTimer {
    #[prost(fixed64, tag = "1")]
    pub time_stamp: u64,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgPhaseType", tag = "3")]
    pub phase: i32,
    #[prost(fixed64, tag = "4")]
    pub begin_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgWaitingListChange {
    #[prost(uint32, tag = "1")]
    pub controller_id: u32,
    #[prost(uint32, tag = "2")]
    pub cur_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgCardUpdate {
    #[prost(message, optional, tag = "1")]
    pub card: ::core::option::Option<GcgCard>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgCostRevise {
    #[prost(message, optional, tag = "1")]
    pub cost_revise: ::core::option::Option<GcgCostReviseInfo>,
    #[prost(uint32, tag = "2")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgPhaseContinue {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMsgNoDamageSkillResult {
    #[prost(message, repeated, tag = "1")]
    pub detail_list: ::prost::alloc::vec::Vec<GcgDamageDetail>,
    #[prost(uint32, tag = "2")]
    pub target_card_guid: u32,
    #[prost(uint32, tag = "3")]
    pub effect_element: u32,
    #[prost(uint32, tag = "4")]
    pub skill_id: u32,
    #[prost(uint32, tag = "5")]
    pub src_card_guid: u32,
    #[prost(uint32, tag = "6")]
    pub result_seq: u32,
    #[prost(uint32, tag = "7")]
    pub from_result_seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgReactionBegin {
    #[prost(uint32, tag = "1")]
    pub skill_id: u32,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgMsgReactionEnd {
    #[prost(uint32, tag = "1")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMessage {
    #[prost(
        oneof = "gcg_message::Message",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33"
    )]
    pub message: ::core::option::Option<gcg_message::Message>,
}
/// Nested message and enum types in `GCGMessage`.
pub mod gcg_message {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        TokenChange(super::GcgMsgTokenChange),
        #[prost(message, tag = "2")]
        PhaseChange(super::GcgMsgPhaseChange),
        #[prost(message, tag = "3")]
        AddCards(super::GcgMsgAddCards),
        #[prost(message, tag = "4")]
        RemoveCards(super::GcgMsgRemoveCards),
        #[prost(message, tag = "5")]
        SelectOnStage(super::GcgMsgSelectOnStage),
        #[prost(message, tag = "6")]
        DiceRoll(super::GcgMsgDiceRoll),
        #[prost(message, tag = "7")]
        DiceReroll(super::GcgMsgDiceReroll),
        #[prost(message, tag = "8")]
        Pass(super::GcgMsgPass),
        #[prost(message, tag = "9")]
        SkillResult(super::GcgMsgSkillResult),
        #[prost(message, tag = "10")]
        CostDice(super::GcgMsgCostDice),
        #[prost(message, tag = "11")]
        AddDice(super::GcgMsgAddDice),
        #[prost(message, tag = "12")]
        MoveCard(super::GcgMsgMoveCard),
        #[prost(message, tag = "13")]
        UseSkill(super::GcgMsgUseSkill),
        #[prost(message, tag = "14")]
        NewCard(super::GcgMsgNewCard),
        #[prost(message, tag = "15")]
        UpdateController(super::GcgMsgUpdateController),
        #[prost(message, tag = "16")]
        ModifyAdd(super::GcgMsgModifyAdd),
        #[prost(message, tag = "17")]
        ModifyRemove(super::GcgMsgModifyRemove),
        #[prost(message, tag = "18")]
        UseSkillEnd(super::GcgMsgUseSkillEnd),
        #[prost(message, tag = "19")]
        DuelDataChange(super::GcgMsgDuelDataChange),
        #[prost(message, tag = "20")]
        ClientPerform(super::GcgMsgClientPerform),
        #[prost(message, tag = "21")]
        GameOver(super::GcgMsgGameOver),
        #[prost(message, tag = "22")]
        OpTimer(super::GcgMsgOpTimer),
        #[prost(message, tag = "23")]
        WaitingListChange(super::GcgMsgWaitingListChange),
        #[prost(message, tag = "24")]
        CardUpdate(super::GcgMsgCardUpdate),
        #[prost(message, tag = "25")]
        SelectOnStageByEffect(super::GcgMsgSelectOnStageByEffect),
        #[prost(message, tag = "26")]
        CostRevise(super::GcgMsgCostRevise),
        #[prost(message, tag = "27")]
        PhaseContinue(super::GcgMsgPhaseContinue),
        #[prost(message, tag = "28")]
        PveIntentionInfo(super::GcgMsgPveIntentionInfo),
        #[prost(message, tag = "29")]
        PveIntentionChange(super::GcgMsgPveIntentionChange),
        #[prost(message, tag = "30")]
        SkillLimitsChange(super::GcgMsgSkillLimitsChange),
        #[prost(message, tag = "31")]
        NoDamageSkillResult(super::GcgMsgNoDamageSkillResult),
        #[prost(message, tag = "32")]
        ReactionBegin(super::GcgMsgReactionBegin),
        #[prost(message, tag = "33")]
        ReactionEnd(super::GcgMsgReactionEnd),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMessagePack {
    #[prost(message, repeated, tag = "1")]
    pub msg_list: ::prost::alloc::vec::Vec<GcgMessage>,
    #[prost(uint32, tag = "2")]
    pub action_trans_id: u32,
    #[prost(enumeration = "GcgActionType", tag = "3")]
    pub action_type: i32,
    #[prost(uint32, tag = "4")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationRedraw {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationOnStageSelect {
    #[prost(uint32, repeated, tag = "1")]
    pub cost_dice_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationReroll {
    #[prost(uint32, repeated, tag = "1")]
    pub dice_index_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationAttack {
    #[prost(uint32, repeated, tag = "1")]
    pub cost_dice_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgOperationPass {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationPlayCard {
    #[prost(uint32, repeated, tag = "1")]
    pub cost_dice_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub target_card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub replace_card_guid: u32,
    #[prost(uint32, tag = "4")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationReboot {
    #[prost(uint32, repeated, tag = "1")]
    pub dice_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub cost_card_guid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgOperationSurrender {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperation {
    #[prost(oneof = "gcg_operation::Op", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub op: ::core::option::Option<gcg_operation::Op>,
}
/// Nested message and enum types in `GCGOperation`.
pub mod gcg_operation {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Op {
        #[prost(message, tag = "1")]
        OpRedraw(super::GcgOperationRedraw),
        #[prost(message, tag = "2")]
        OpSelectOnStage(super::GcgOperationOnStageSelect),
        #[prost(message, tag = "3")]
        OpReroll(super::GcgOperationReroll),
        #[prost(message, tag = "4")]
        OpAttack(super::GcgOperationAttack),
        #[prost(message, tag = "5")]
        OpPass(super::GcgOperationPass),
        #[prost(message, tag = "6")]
        OpPlayCard(super::GcgOperationPlayCard),
        #[prost(message, tag = "7")]
        OpReboot(super::GcgOperationReboot),
        #[prost(message, tag = "8")]
        OpSurrender(super::GcgOperationSurrender),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgToken {
    #[prost(uint32, tag = "1")]
    pub key: u32,
    #[prost(uint32, tag = "2")]
    pub value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCard {
    #[prost(message, repeated, tag = "1")]
    pub skill_limits_list: ::prost::alloc::vec::Vec<GcgSkillLimitsInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub token_list: ::prost::alloc::vec::Vec<GcgToken>,
    #[prost(uint32, tag = "5")]
    pub id: u32,
    #[prost(uint32, tag = "6")]
    pub controller_id: u32,
    #[prost(uint32, tag = "7")]
    pub face_type: u32,
    #[prost(uint32, tag = "8")]
    pub guid: u32,
    #[prost(bool, tag = "9")]
    pub is_show: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgZone {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgWaitingCharacter {
    #[prost(uint32, tag = "1")]
    pub cond_count: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPlayerField {
    #[prost(message, optional, tag = "1")]
    pub hand_zone: ::core::option::Option<GcgZone>,
    #[prost(message, optional, tag = "2")]
    pub on_stage_zone: ::core::option::Option<GcgZone>,
    #[prost(message, optional, tag = "3")]
    pub summon_zone: ::core::option::Option<GcgZone>,
    #[prost(message, optional, tag = "4")]
    pub character_zone: ::core::option::Option<GcgZone>,
    #[prost(map = "uint32, message", tag = "5")]
    pub modify_zone_map: ::std::collections::HashMap<u32, GcgZone>,
    #[prost(message, repeated, tag = "6")]
    pub waiting_list: ::prost::alloc::vec::Vec<GcgWaitingCharacter>,
    #[prost(enumeration = "GcgDiceSideType", repeated, tag = "7")]
    pub dice_side_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "8")]
    pub assist_zone: ::core::option::Option<GcgZone>,
    #[prost(uint32, tag = "9")]
    pub controller_id: u32,
    #[prost(uint32, tag = "10")]
    pub deck_card_num: u32,
    #[prost(uint32, tag = "11")]
    pub field_show_id: u32,
    #[prost(uint32, tag = "12")]
    pub card_back_show_id: u32,
    #[prost(bool, tag = "13")]
    pub is_passed: bool,
    #[prost(uint32, tag = "14")]
    pub cur_waiting_index: u32,
    #[prost(uint32, tag = "15")]
    pub dice_count: u32,
    #[prost(uint32, tag = "16")]
    pub on_stage_character_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPhase {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub allow_controller_map: ::std::collections::HashMap<u32, u32>,
    #[prost(enumeration = "GcgPhaseType", tag = "2")]
    pub phase_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgControllerShowInfo {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub psn_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgpveIntention {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgDuelChallenge {
    #[prost(uint32, tag = "1")]
    pub total_progress: u32,
    #[prost(uint32, tag = "2")]
    pub challenge_id: u32,
    #[prost(uint32, tag = "3")]
    pub cur_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgOpTimer {
    #[prost(uint64, tag = "1")]
    pub begin_time: u64,
    #[prost(uint64, tag = "2")]
    pub time_stamp: u64,
    #[prost(uint32, tag = "3")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgDuel {
    #[prost(message, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<GcgCard>,
    #[prost(uint32, repeated, tag = "2")]
    pub card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub challenge_list: ::prost::alloc::vec::Vec<GcgDuelChallenge>,
    #[prost(uint32, repeated, tag = "4")]
    pub forbid_finish_challenge_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "5")]
    pub history_msg_pack_list: ::prost::alloc::vec::Vec<GcgMessagePack>,
    #[prost(message, repeated, tag = "6")]
    pub show_info_list: ::prost::alloc::vec::Vec<GcgControllerShowInfo>,
    #[prost(message, optional, tag = "7")]
    pub phase: ::core::option::Option<GcgPhase>,
    #[prost(message, repeated, tag = "8")]
    pub history_card_list: ::prost::alloc::vec::Vec<GcgCard>,
    #[prost(message, repeated, tag = "9")]
    pub field_list: ::prost::alloc::vec::Vec<GcgPlayerField>,
    #[prost(message, optional, tag = "10")]
    pub cost_revise: ::core::option::Option<GcgCostReviseInfo>,
    #[prost(message, repeated, tag = "11")]
    pub op_timer_list: ::prost::alloc::vec::Vec<GcgOpTimer>,
    #[prost(message, repeated, tag = "12")]
    pub history_field_list: ::prost::alloc::vec::Vec<GcgPlayerField>,
    #[prost(message, repeated, tag = "13")]
    pub intention_list: ::prost::alloc::vec::Vec<GcgpveIntention>,
    #[prost(uint32, tag = "14")]
    pub round: u32,
    #[prost(uint32, tag = "15")]
    pub game_id: u32,
    #[prost(uint32, tag = "16")]
    pub server_seq: u32,
    #[prost(uint32, tag = "17")]
    pub cur_controller_id: u32,
    #[prost(uint32, tag = "18")]
    pub operation_seq: u32,
    #[prost(uint32, tag = "19")]
    pub controller_id: u32,
    #[prost(enumeration = "GcgGameBusinessType", tag = "20")]
    pub business_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7601)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgOperationReq {
    #[prost(message, optional, tag = "1")]
    pub op: ::core::option::Option<GcgOperation>,
    #[prost(uint32, tag = "2")]
    pub redirect_uid: u32,
    #[prost(uint32, tag = "3")]
    pub op_seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7602)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgOperationRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub op_seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMessagePackNotify {
    #[prost(message, repeated, tag = "1")]
    pub msg_pack_list: ::prost::alloc::vec::Vec<GcgMessagePack>,
    #[prost(uint32, tag = "2")]
    pub server_seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgAskDuelReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7603)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgAskDuelRsp {
    #[prost(message, optional, tag = "1")]
    pub duel: ::core::option::Option<GcgDuel>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPlayerBriefData {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub psn_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "4")]
    pub card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "5")]
    pub card_face_map: ::std::collections::HashMap<u32, u32>,
    #[prost(string, tag = "6")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "7")]
    pub controller_id: u32,
    #[prost(uint32, tag = "8")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGameBriefData {
    #[prost(message, repeated, tag = "1")]
    pub player_brief_list: ::prost::alloc::vec::Vec<GcgPlayerBriefData>,
    #[prost(uint32, tag = "2")]
    pub game_uid: u32,
    #[prost(uint32, tag = "3")]
    pub platform_type: u32,
    #[prost(uint32, tag = "4")]
    pub verify_code: u32,
    #[prost(enumeration = "GcgGameBusinessType", tag = "5")]
    pub business_type: i32,
    #[prost(uint32, tag = "6")]
    pub game_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7501)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGameBriefDataNotify {
    #[prost(message, optional, tag = "1")]
    pub gcg_brief_data: ::core::option::Option<GcgGameBriefData>,
    #[prost(bool, tag = "2")]
    pub is_new_game: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgInitFinishReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgInitFinishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgHeartBeatNotify {
    #[prost(uint32, tag = "1")]
    pub server_seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewHpInfo {
    #[prost(bool, tag = "1")]
    pub is_revive: bool,
    #[prost(uint32, tag = "2")]
    pub hp_change_value: u32,
    #[prost(enumeration = "GcgSkillHpChangeType", tag = "3")]
    pub change_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewReactionInfo {
    #[prost(uint32, tag = "1")]
    pub target_element: u32,
    #[prost(uint32, tag = "2")]
    pub source_element: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewElementReactionInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub source_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub fresh_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub reaction_list: ::prost::alloc::vec::Vec<GcgSkillPreviewReactionInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewCardInfo {
    #[prost(enumeration = "GcgZoneType", tag = "1")]
    pub zone_type: i32,
    #[prost(uint32, tag = "2")]
    pub card_guid: u32,
    #[prost(uint32, tag = "3")]
    pub face_type: u32,
    #[prost(uint32, tag = "4")]
    pub operator_type: u32,
    #[prost(uint32, tag = "5")]
    pub owner_card_guid: u32,
    #[prost(uint32, tag = "6")]
    pub controller_id: u32,
    #[prost(uint32, tag = "7")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewOnstageChangeInfo {
    #[prost(uint32, tag = "1")]
    pub target_onstage_card_guid: u32,
    #[prost(uint32, tag = "2")]
    pub source_onstage_card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewTokenInfo {
    #[prost(uint32, tag = "1")]
    pub before_value: u32,
    #[prost(uint32, tag = "2")]
    pub after_value: u32,
    #[prost(uint32, tag = "3")]
    pub token_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewTokenChangeInfo {
    #[prost(message, repeated, tag = "1")]
    pub token_change_list: ::prost::alloc::vec::Vec<GcgSkillPreviewTokenInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewExtraInfo {
    #[prost(message, repeated, tag = "1")]
    pub refresh_card_when_exist_list: ::prost::alloc::vec::Vec<GcgSkillPreviewCardInfo>,
    #[prost(message, repeated, tag = "2")]
    pub fail_added_when_full_list: ::prost::alloc::vec::Vec<GcgSkillPreviewCardInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub reaction_info_map: ::std::collections::HashMap<
        u32,
        GcgSkillPreviewElementReactionInfo,
    >,
    #[prost(map = "uint32, message", tag = "2")]
    pub card_token_change_map: ::std::collections::HashMap<
        u32,
        GcgSkillPreviewTokenChangeInfo,
    >,
    #[prost(map = "uint32, message", tag = "3")]
    pub hp_info_map: ::std::collections::HashMap<u32, GcgSkillPreviewHpInfo>,
    #[prost(message, optional, tag = "4")]
    pub extra_info: ::core::option::Option<GcgSkillPreviewExtraInfo>,
    #[prost(message, repeated, tag = "5")]
    pub rm_card_list: ::prost::alloc::vec::Vec<GcgSkillPreviewCardInfo>,
    #[prost(message, repeated, tag = "6")]
    pub change_onstage_character_list: ::prost::alloc::vec::Vec<
        GcgSkillPreviewOnstageChangeInfo,
    >,
    #[prost(message, repeated, tag = "7")]
    pub add_card_list: ::prost::alloc::vec::Vec<GcgSkillPreviewCardInfo>,
    #[prost(uint32, tag = "8")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgChangeOnstageInfo {
    #[prost(message, optional, tag = "1")]
    pub change_onstage_preview_info: ::core::option::Option<GcgSkillPreviewInfo>,
    #[prost(bool, tag = "2")]
    pub is_quick: bool,
    #[prost(uint32, tag = "3")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewPlayCardInfo {
    #[prost(message, optional, tag = "1")]
    pub play_card_info: ::core::option::Option<GcgSkillPreviewInfo>,
    #[prost(uint32, tag = "2")]
    pub hand_card_guid: u32,
    #[prost(uint32, tag = "3")]
    pub target_card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7502)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewNotify {
    #[prost(message, repeated, tag = "1")]
    pub change_onstage_preview_list: ::prost::alloc::vec::Vec<GcgChangeOnstageInfo>,
    #[prost(message, repeated, tag = "2")]
    pub play_card_list: ::prost::alloc::vec::Vec<GcgSkillPreviewPlayCardInfo>,
    #[prost(message, repeated, tag = "3")]
    pub skill_preview_list: ::prost::alloc::vec::Vec<GcgSkillPreviewInfo>,
    #[prost(uint32, tag = "4")]
    pub onstage_card_guid: u32,
    #[prost(uint32, tag = "5")]
    pub controller_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewAskReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSkillPreviewAskRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgChallengeUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub challenge: ::core::option::Option<GcgDuelChallenge>,
    #[prost(uint32, tag = "2")]
    pub server_seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgBackToDuelReq {
    #[prost(bool, tag = "1")]
    pub is_back: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgBackToDuelRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7104)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgDebugReplayNotify {
    #[prost(string, tag = "1")]
    pub json_str: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGameMaxNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7606)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGameCreateFailReasonNotify {
    #[prost(enumeration = "GcgGameCreateReason", tag = "1")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgHintNotify {
    #[prost(enumeration = "GcgHintType", tag = "1")]
    pub hint_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7607)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgDuelCompareNotify {
    #[prost(string, tag = "1")]
    pub cur_duel_str: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub compare_duel_str: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7002)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCheatInfoNotify {
    #[prost(enumeration = "GcgDiceSideType", repeated, tag = "1")]
    pub dice_side_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "2")]
    pub self_deck_card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub hand_card_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPlayCardTargetParam {
    #[prost(uint32, repeated, tag = "1")]
    pub card_guid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCandidatePlayCardData {
    #[prost(uint32, repeated, tag = "1")]
    pub replace_card_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub target_list: ::prost::alloc::vec::Vec<GcgPlayCardTargetParam>,
    #[prost(uint32, tag = "3")]
    pub card_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCandidateOpNotify {
    #[prost(message, repeated, tag = "1")]
    pub play_card_data_list: ::prost::alloc::vec::Vec<GcgCandidatePlayCardData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsDeckData {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "2")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub card_back_id: u32,
    #[prost(bool, tag = "5")]
    pub is_valid: bool,
    #[prost(uint32, tag = "6")]
    pub field_id: u32,
    #[prost(fixed32, tag = "7")]
    pub create_time: u32,
    #[prost(uint32, tag = "8")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsCardData {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_face_type_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub proficiency_reward_taken_idx_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub card_id: u32,
    #[prost(uint32, tag = "4")]
    pub proficiency: u32,
    #[prost(uint32, tag = "5")]
    pub num: u32,
    #[prost(uint32, tag = "6")]
    pub face_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub deck_list: ::prost::alloc::vec::Vec<GcgdsDeckData>,
    #[prost(uint32, repeated, tag = "2")]
    pub unlock_field_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub unlock_deck_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub card_list: ::prost::alloc::vec::Vec<GcgdsCardData>,
    #[prost(uint32, repeated, tag = "5")]
    pub unlock_card_back_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "6")]
    pub cur_deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsCardBackUnlockNotify {
    #[prost(uint32, tag = "1")]
    pub card_back_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsFieldUnlockNotify {
    #[prost(uint32, tag = "1")]
    pub field_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7702)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsCardFaceUnlockNotify {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub face_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsCardNumChangeNotify {
    #[prost(uint32, tag = "1")]
    pub num: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeCardFaceReq {
    #[prost(uint32, tag = "1")]
    pub face_type: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeCardFaceRsp {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub face_type: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeCardBackReq {
    #[prost(uint32, tag = "1")]
    pub card_back_id: u32,
    #[prost(uint32, tag = "2")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7403)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeCardBackRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub card_back_id: u32,
    #[prost(uint32, tag = "3")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeFieldReq {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
    #[prost(uint32, tag = "2")]
    pub field_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7106)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeFieldRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub deck_id: u32,
    #[prost(uint32, tag = "3")]
    pub field_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7902)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsChangeDeckNameReq {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_only_check: bool,
    #[prost(uint32, tag = "3")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7404)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsChangeDeckNameRsp {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub deck_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(bool, tag = "4")]
    pub is_only_check: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7903)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsDeckSaveReq {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "3")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7004)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsDeckSaveRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub deck_id: u32,
    #[prost(fixed32, tag = "3")]
    pub create_time: u32,
    #[prost(bool, tag = "4")]
    pub is_valid: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeCurDeckReq {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsChangeCurDeckRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsCurDeckChangeNotify {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsDeleteDeckReq {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7405)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsDeleteDeckRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsDeckUnlockNotify {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsCardProficiencyNotify {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub proficiency: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7305)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsDeckUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
    #[prost(bool, tag = "2")]
    pub is_valid: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7506)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsCardFaceUpdateNotify {
    #[prost(uint32, tag = "1")]
    pub face_type: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsTakeCardProficiencyRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_index: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgdsTakeCardProficiencyRewardRsp {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub reward_index: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7107)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgdsBanCardNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7108)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgtcTavernInfoNotify {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub character_id: u32,
    #[prost(bool, tag = "3")]
    pub is_owner_in_duel: bool,
    #[prost(bool, tag = "4")]
    pub is_last_duel_win: bool,
    #[prost(uint32, tag = "5")]
    pub element_type: u32,
    #[prost(uint32, tag = "6")]
    pub level_id: u32,
    #[prost(uint32, tag = "7")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgtcInviteReq {
    #[prost(uint32, tag = "1")]
    pub character_id: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgtcInviteRsp {
    #[prost(uint32, tag = "1")]
    pub character_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgtcTavernChallengeData {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_level_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub character_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7704)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgtcTavernChallengeDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub tavern_challenge_list: ::prost::alloc::vec::Vec<GcgtcTavernChallengeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7906)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgtcTavernChallengeUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub tavern_challenge: ::core::option::Option<GcgtcTavernChallengeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGrowthLevelNotify {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub exp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7109)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGrowthLevelRewardNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub level_reward_taken_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGrowthLevelTakeRewardReq {
    #[prost(uint32, tag = "1")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGrowthLevelTakeRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7408)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgInviteGuestBattleReq {
    #[prost(uint32, tag = "1")]
    pub festival_mode_type: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7907)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgInviteGuestBattleRsp {
    #[prost(uint32, tag = "1")]
    pub punish_end_time: u32,
    #[prost(uint32, tag = "2")]
    pub festival_mode_type: u32,
    #[prost(uint32, tag = "3")]
    pub confirm_end_time: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7804)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgInviteBattleNotify {
    #[prost(uint32, tag = "1")]
    pub confirm_end_time: u32,
    #[prost(uint32, tag = "2")]
    pub festival_mode_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7706)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgApplyInviteBattleReq {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7908)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgApplyInviteBattleRsp {
    #[prost(uint32, tag = "1")]
    pub punish_end_time: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgApplyInviteBattleNotify {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7410)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgWorldPlayerGcgStateReq {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPlayerGcgState {
    #[prost(bool, tag = "1")]
    pub is_resource_complete: bool,
    #[prost(bool, tag = "2")]
    pub is_gcg_state_open: bool,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7005)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgWorldPlayerGcgStateRsp {
    #[prost(message, repeated, tag = "1")]
    pub player_state: ::prost::alloc::vec::Vec<GcgPlayerGcgState>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgpveActivitySettle {
    #[prost(uint32, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgArenaSettle {
    #[prost(uint32, tag = "1")]
    pub cur_fail_count: u32,
    #[prost(uint32, tag = "2")]
    pub cur_win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7307)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSettleNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub forbid_finish_challenge_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub finished_challenge_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub reward_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "4")]
    pub win_controller_id: u32,
    #[prost(enumeration = "GcgEndReason", tag = "5")]
    pub reason: i32,
    #[prost(uint32, tag = "6")]
    pub game_id: u32,
    #[prost(enumeration = "GcgGameBusinessType", tag = "7")]
    pub business_type: i32,
    #[prost(bool, tag = "8")]
    pub is_win: bool,
    #[prost(oneof = "gcg_settle_notify::Detail", tags = "9, 10")]
    pub detail: ::core::option::Option<gcg_settle_notify::Detail>,
}
/// Nested message and enum types in `GCGSettleNotify`.
pub mod gcg_settle_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "9")]
        PveActivitySettle(super::GcgpveActivitySettle),
        #[prost(message, tag = "10")]
        ArenaSettle(super::GcgArenaSettle),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7909)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgResourceStateNotify {
    #[prost(bool, tag = "1")]
    pub is_complete: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgClientSettleReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7910)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgClientSettleRsp {
    #[prost(uint32, tag = "1")]
    pub close_time: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7308)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSettleOptionReq {
    #[prost(enumeration = "GcgSettleOption", tag = "1")]
    pub option: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7911)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSettleOptionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(enumeration = "GcgSettleOption", tag = "2")]
    pub option: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7508)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgBasicDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub level_reward_taken_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub exp: u32,
    #[prost(uint32, tag = "3")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgTavernNpcInfo {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub scene_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7411)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgTavernNpcInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub week_npc_list: ::prost::alloc::vec::Vec<GcgTavernNpcInfo>,
    #[prost(message, optional, tag = "2")]
    pub character_npc: ::core::option::Option<GcgTavernNpcInfo>,
    #[prost(message, repeated, tag = "3")]
    pub const_npc_list: ::prost::alloc::vec::Vec<GcgTavernNpcInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7509)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgStartChallengeReq {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(enumeration = "GcgLevelType", tag = "3")]
    pub level_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7309)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgStartChallengeRsp {
    #[prost(enumeration = "GcgLevelType", tag = "1")]
    pub level_type: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgWeekChallengeInfo {
    #[prost(uint32, tag = "1")]
    pub unlock_time: u32,
    #[prost(uint32, tag = "2")]
    pub npc_id: u32,
    #[prost(bool, tag = "3")]
    pub is_finished: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7510)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgWeekChallengeInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub challenge_info_list: ::prost::alloc::vec::Vec<GcgWeekChallengeInfo>,
    #[prost(uint32, tag = "2")]
    pub next_refresh_time: u32,
    #[prost(bool, tag = "3")]
    pub is_notify_npc_change: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7912)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgStartChallengeByCheckRewardReq {
    #[prost(enumeration = "GcgLevelType", tag = "1")]
    pub level_type: i32,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7708)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgStartChallengeByCheckRewardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub exceeded_item_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub exceeded_item_type_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(enumeration = "GcgLevelType", tag = "5")]
    pub level_type: i32,
    #[prost(uint32, tag = "6")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgLevelData {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_challenge_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgBossChallengeData {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_level_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7608)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgLevelChallengeNotify {
    #[prost(message, repeated, tag = "1")]
    pub unlock_boss_challenge_list: ::prost::alloc::vec::Vec<GcgBossChallengeData>,
    #[prost(message, repeated, tag = "2")]
    pub level_list: ::prost::alloc::vec::Vec<GcgLevelData>,
    #[prost(uint32, repeated, tag = "3")]
    pub unlock_world_challenge_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7205)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgLevelChallengeFinishNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_challenge_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7110)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgWorldChallengeUnlockNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7006)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgBossChallengeUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub boss_challenge: ::core::option::Option<GcgBossChallengeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7007)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgLevelChallengeDeleteNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub level_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgReplayBriefData {
    #[prost(message, repeated, tag = "1")]
    pub card_replay_version_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(message, repeated, tag = "2")]
    pub player_brief_list: ::prost::alloc::vec::Vec<GcgPlayerBriefData>,
    #[prost(uint32, tag = "3")]
    pub controller_id: u32,
    #[prost(uint32, tag = "4")]
    pub game_id: u32,
    #[prost(bool, tag = "5")]
    pub is_invalid: bool,
    #[prost(enumeration = "GcgGameBusinessType", tag = "6")]
    pub business_type: i32,
    #[prost(uint32, tag = "7")]
    pub time_stamp: u32,
    #[prost(uint32, tag = "8")]
    pub expire_time: u32,
    #[prost(uint32, tag = "9")]
    pub win_controller_id: u32,
    #[prost(uint32, tag = "10")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGetReplayListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7111)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGetReplayListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub history_replay_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub replay_list: ::prost::alloc::vec::Vec<GcgReplayBriefData>,
    #[prost(uint32, repeated, tag = "3")]
    pub favorite_replay_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplaySetFavoriteReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(bool, tag = "2")]
    pub is_favorite: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplaySetFavoriteRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_favorite: bool,
    #[prost(uint32, tag = "3")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7112)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplayStartReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplayStartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplayAskDuelReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7413)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgReplayAskDuelRsp {
    #[prost(message, optional, tag = "1")]
    pub duel: ::core::option::Option<GcgDuel>,
    #[prost(message, repeated, tag = "2")]
    pub msg_pack_list: ::prost::alloc::vec::Vec<GcgMessagePack>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7511)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplaySettleReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7512)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgReplaySettleRsp {
    #[prost(uint32, tag = "1")]
    pub close_time: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7609)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgReplayBriefDataNotify {
    #[prost(message, optional, tag = "1")]
    pub replay_brief_data: ::core::option::Option<GcgGameBriefData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7913)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPickInfoNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickPlayerInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub card_face_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub pick_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickRoundInfo {
    #[prost(message, repeated, tag = "1")]
    pub player_pick_info_list: ::prost::alloc::vec::Vec<GcgPickPlayerInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub cur_pick_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub round: u32,
    #[prost(uint32, tag = "4")]
    pub cur_uid: u32,
    #[prost(uint32, tag = "5")]
    pub expire_time: u32,
    #[prost(uint32, tag = "6")]
    pub cur_pick_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7208)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickDetailNotify {
    #[prost(message, optional, tag = "1")]
    pub round_info: ::core::option::Option<GcgPickRoundInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub candidate_pick_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub player_info_list: ::prost::alloc::vec::Vec<OnlinePlayerInfo>,
    #[prost(uint32, tag = "4")]
    pub game_id: u32,
    #[prost(uint32, tag = "5")]
    pub match_id: u32,
    #[prost(uint32, tag = "6")]
    pub first_hand_uid: u32,
    #[prost(enumeration = "GcgGameBusinessType", tag = "7")]
    pub business_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7008)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPickFinishNotify {
    #[prost(uint32, tag = "1")]
    pub force_stop_uid: u32,
    #[prost(uint32, tag = "2")]
    pub close_time: u32,
    #[prost(bool, tag = "3")]
    pub is_force_stop: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7009)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPickDetailReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPickDetailRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7709)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickSelectReq {
    #[prost(uint32, repeated, tag = "1")]
    pub pick_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7414)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickSelectRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_pick_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7914)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickSelectNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_pick_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7513)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickConfirmReq {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_pick_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7514)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickConfirmRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_pick_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7210)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgPickRoundInfoUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub round_info: ::core::option::Option<GcgPickRoundInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7415)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPickGiveUpReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7710)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgPickGiveUpRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGetArenaScheduleInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgArenaDeckInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub is_set: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgArenaScheduleDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub deck_info: ::core::option::Option<GcgArenaDeckInfo>,
    #[prost(bool, tag = "3")]
    pub is_in_challenge: bool,
    #[prost(uint32, tag = "4")]
    pub last_get_win_count: u32,
    #[prost(uint32, tag = "5")]
    pub cur_win_count: u32,
    #[prost(uint32, tag = "6")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "7")]
    pub last_get_fail_count: u32,
    #[prost(uint32, tag = "8")]
    pub schedule_end_time: u32,
    #[prost(uint32, tag = "9")]
    pub cur_fail_count: u32,
    #[prost(uint32, tag = "10")]
    pub best_win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgArenaScheduleLookBackInfo {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub best_win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgArenaChallengeFinishInfo {
    #[prost(uint32, tag = "1")]
    pub fail_count: u32,
    #[prost(uint32, tag = "2")]
    pub win_count: u32,
    #[prost(bool, tag = "3")]
    pub is_tips: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7010)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGetArenaScheduleInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub challenge_finish_info: ::core::option::Option<GcgArenaChallengeFinishInfo>,
    #[prost(message, optional, tag = "2")]
    pub look_back_info: ::core::option::Option<GcgArenaScheduleLookBackInfo>,
    #[prost(message, optional, tag = "3")]
    pub detail_info: ::core::option::Option<GcgArenaScheduleDetailInfo>,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7806)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgArenaScheduleBriefInfoNotify {
    #[prost(uint32, tag = "1")]
    pub end_schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub cur_schedule_id: u32,
    #[prost(bool, tag = "3")]
    pub is_in_challenge: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7711)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgSetArenaDeckReq {
    #[prost(uint32, tag = "1")]
    pub deck_id: u32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7515)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgSetArenaDeckRsp {
    #[prost(message, optional, tag = "1")]
    pub deck_info: ::core::option::Option<GcgArenaDeckInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7416)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgStartArenaChallengeReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7807)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgStartArenaChallengeRsp {
    #[prost(message, optional, tag = "1")]
    pub schedule_detail_info: ::core::option::Option<GcgArenaScheduleDetailInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7417)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgCancelArenaChallengeReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7516)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgCancelArenaChallengeRsp {
    #[prost(message, optional, tag = "1")]
    pub schedule_detail_info: ::core::option::Option<GcgArenaScheduleDetailInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7113)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGetArenaHistoryInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgArenaHistoryDeckBriefInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgArenaHistoryScheduleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub honor_character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub deck_brief_info_list: ::prost::alloc::vec::Vec<GcgArenaHistoryDeckBriefInfo>,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "4")]
    pub best_win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7211)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGetArenaHistoryInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub schedule_info_list: ::prost::alloc::vec::Vec<GcgArenaHistoryScheduleInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7011)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGetArenaHonorCharacterInfoReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgArenaHonorCharacterInfo {
    #[prost(message, repeated, tag = "1")]
    pub statistic_item_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, tag = "2")]
    pub character_card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7517)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGetArenaHonorCharacterInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub character_info_list: ::prost::alloc::vec::Vec<GcgArenaHonorCharacterInfo>,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7114)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcgGetArenaHistoryDeckDetailInfoReq {
    #[prost(uint32, tag = "1")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "2")]
    pub deck_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgArenaHistoryDeckDetailInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7610)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgGetArenaHistoryDeckDetailInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub deck_detail_info: ::core::option::Option<GcgArenaHistoryDeckDetailInfo>,
    #[prost(uint32, tag = "2")]
    pub deck_index: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7212)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgDeckHonorCharacterInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub character_card_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupLinkBundle {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub bundle_id: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
    #[prost(bool, tag = "4")]
    pub is_show_mark: bool,
    #[prost(bool, tag = "5")]
    pub is_activated: bool,
    #[prost(uint32, tag = "6")]
    pub radius: u32,
    #[prost(enumeration = "GroupLinkShowAreaState", tag = "7")]
    pub show_area_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupLinkAllNotify {
    #[prost(message, repeated, tag = "1")]
    pub bundle_list: ::prost::alloc::vec::Vec<GroupLinkBundle>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5702)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupLinkChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub bundle: ::core::option::Option<GroupLinkBundle>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupLinkDeleteNotify {
    #[prost(uint32, tag = "1")]
    pub bundle_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5704)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupLinkMarkUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub bundle: ::core::option::Option<GroupLinkBundle>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupLinkShowAreaStateUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub bundle: ::core::option::Option<GroupLinkBundle>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct H5ActivityInfo {
    #[prost(string, tag = "1")]
    pub prefab_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub h5_activity_id: u32,
    #[prost(uint32, tag = "4")]
    pub begin_time: u32,
    #[prost(uint32, tag = "5")]
    pub content_close_time: u32,
    #[prost(uint32, tag = "6")]
    pub h5_schedule_id: u32,
    #[prost(uint32, tag = "7")]
    pub end_time: u32,
    #[prost(bool, tag = "8")]
    pub is_entrance_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5601)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllH5ActivityInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5602)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllH5ActivityInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub h5_activity_info_list: ::prost::alloc::vec::Vec<H5ActivityInfo>,
    #[prost(uint32, tag = "2")]
    pub client_red_dot_timestamp: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5603)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct H5ActivityIdsNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub h5_activity_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub client_red_dot_timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5604)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetH5ActivityRedDotTimestampReq {
    #[prost(uint32, tag = "1")]
    pub client_red_dot_timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetH5ActivityRedDotTimestampRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryEnterHomeReq {
    #[prost(uint32, tag = "1")]
    pub target_point: u32,
    #[prost(bool, tag = "2")]
    pub is_transfer_to_main_house: bool,
    #[prost(bool, tag = "3")]
    pub is_transfer_to_safe_point: bool,
    #[prost(uint32, tag = "4")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4701)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TryEnterHomeRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4601)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JoinHomeWorldFailNotify {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeBlockNotify {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBasicInfo {
    #[prost(string, tag = "1")]
    pub owner_nick_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub limited_shop_info: ::core::option::Option<HomeLimitedShopInfo>,
    #[prost(uint32, tag = "3")]
    pub cur_module_id: u32,
    #[prost(bool, tag = "4")]
    pub is_in_edit_mode: bool,
    #[prost(uint64, tag = "5")]
    pub exp: u64,
    #[prost(uint32, tag = "6")]
    pub home_owner_uid: u32,
    #[prost(uint32, tag = "7")]
    pub cur_room_scene_id: u32,
    #[prost(uint32, tag = "8")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeGetBasicInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4602)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBasicInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub basic_info: ::core::option::Option<HomeBasicInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4603)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeEditModeReq {
    #[prost(bool, tag = "1")]
    pub is_enter_edit_mode: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeEditModeRsp {
    #[prost(bool, tag = "1")]
    pub is_enter_edit_mode: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4503)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeModuleReq {
    #[prost(uint32, tag = "1")]
    pub target_module_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeModuleRsp {
    #[prost(uint32, tag = "1")]
    pub target_module_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeFurnitureData {
    #[prost(message, optional, tag = "1")]
    pub spawn_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub spawn_rot: ::core::option::Option<Vector>,
    #[prost(int32, tag = "3")]
    pub parent_furniture_index: i32,
    #[prost(uint32, tag = "4")]
    pub furniture_id: u32,
    #[prost(uint32, tag = "5")]
    pub version: u32,
    #[prost(uint32, tag = "6")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeFurnitureSuiteData {
    #[prost(int32, repeated, tag = "1")]
    pub included_furniture_index_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "2")]
    pub spawn_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub guid: u32,
    #[prost(bool, tag = "4")]
    pub is_allow_summon: bool,
    #[prost(uint32, tag = "5")]
    pub suite_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeNpcData {
    #[prost(message, optional, tag = "1")]
    pub spawn_rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub spawn_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "4")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAnimalData {
    #[prost(message, optional, tag = "1")]
    pub spawn_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub spawn_rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub furniture_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeekendDjinnInfo {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBlockDotPattern {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub width: u32,
    #[prost(uint32, tag = "3")]
    pub height: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeBlockSubFieldData {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBlockFieldData {
    #[prost(message, repeated, tag = "1")]
    pub sub_field_list: ::prost::alloc::vec::Vec<HomeBlockSubFieldData>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub furniture_id: u32,
    #[prost(uint32, tag = "5")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeFurnitureGroupData {
    #[prost(message, repeated, tag = "1")]
    pub virtual_furniture_list: ::prost::alloc::vec::Vec<HomeFurnitureData>,
    #[prost(uint32, tag = "2")]
    pub group_furniture_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeFurnitureCustomSuiteData {
    #[prost(message, optional, tag = "1")]
    pub spawn_pos: ::core::option::Option<Vector>,
    #[prost(int32, repeated, tag = "2")]
    pub included_furniture_index_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "3")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBlockArrangementInfo {
    #[prost(message, repeated, tag = "1")]
    pub weekend_djinn_info_list: ::prost::alloc::vec::Vec<WeekendDjinnInfo>,
    #[prost(message, repeated, tag = "2")]
    pub furniture_group_list: ::prost::alloc::vec::Vec<HomeFurnitureGroupData>,
    #[prost(message, repeated, tag = "3")]
    pub persistent_furniture_list: ::prost::alloc::vec::Vec<HomeFurnitureData>,
    #[prost(message, repeated, tag = "4")]
    pub furniture_suite_list: ::prost::alloc::vec::Vec<HomeFurnitureSuiteData>,
    #[prost(message, repeated, tag = "5")]
    pub deploy_npc_list: ::prost::alloc::vec::Vec<HomeNpcData>,
    #[prost(message, repeated, tag = "6")]
    pub dot_pattern_list: ::prost::alloc::vec::Vec<HomeBlockDotPattern>,
    #[prost(message, repeated, tag = "7")]
    pub furniture_custom_suite_list: ::prost::alloc::vec::Vec<
        HomeFurnitureCustomSuiteData,
    >,
    #[prost(message, repeated, tag = "8")]
    pub deploy_furniture_list: ::prost::alloc::vec::Vec<HomeFurnitureData>,
    #[prost(message, repeated, tag = "9")]
    pub deploy_animal_list: ::prost::alloc::vec::Vec<HomeAnimalData>,
    #[prost(message, repeated, tag = "10")]
    pub field_list: ::prost::alloc::vec::Vec<HomeBlockFieldData>,
    #[prost(uint32, tag = "11")]
    pub comfort_value: u32,
    #[prost(uint32, tag = "12")]
    pub block_id: u32,
    #[prost(bool, tag = "13")]
    pub is_unlocked: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSceneArrangementInfo {
    #[prost(message, repeated, tag = "1")]
    pub block_arrangement_info_list: ::prost::alloc::vec::Vec<HomeBlockArrangementInfo>,
    #[prost(message, optional, tag = "2")]
    pub born_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub born_rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "4")]
    pub djinn_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "5")]
    pub main_house: ::core::option::Option<HomeFurnitureData>,
    #[prost(message, repeated, tag = "6")]
    pub stair_list: ::prost::alloc::vec::Vec<HomeFurnitureData>,
    #[prost(message, repeated, tag = "7")]
    pub door_list: ::prost::alloc::vec::Vec<HomeFurnitureData>,
    #[prost(uint32, tag = "8")]
    pub bgm_id: u32,
    #[prost(uint32, tag = "9")]
    pub comfort_value: u32,
    #[prost(uint32, tag = "10")]
    pub tmp_version: u32,
    #[prost(uint32, tag = "11")]
    pub scene_id: u32,
    #[prost(bool, tag = "12")]
    pub is_set_born_pos: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGetArrangementInfoReq {
    #[prost(uint32, repeated, tag = "1")]
    pub scene_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4604)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGetArrangementInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub scene_arrangement_info_list: ::prost::alloc::vec::Vec<HomeSceneArrangementInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4804)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeUpdateArrangementInfoReq {
    #[prost(message, optional, tag = "1")]
    pub scene_arrangement_info: ::core::option::Option<HomeSceneArrangementInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4703)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeUpdateArrangementInfoRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHomeCompInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub seen_module_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub unlocked_module_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub levelup_reward_got_level_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "FriendEnterHomeOption", tag = "4")]
    pub friend_enter_home_option: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPlayerHomeCompInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4704)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHomeCompInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub comp_info: ::core::option::Option<PlayerHomeCompInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetFriendEnterHomeOptionReq {
    #[prost(enumeration = "FriendEnterHomeOption", tag = "1")]
    pub option: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetFriendEnterHomeOptionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterHomeNotify {
    #[prost(message, optional, tag = "1")]
    pub src_player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub src_app_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4605)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterHomeResultReq {
    #[prost(bool, tag = "1")]
    pub is_agreed: bool,
    #[prost(uint32, tag = "2")]
    pub apply_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterHomeResultRsp {
    #[prost(uint32, tag = "1")]
    pub apply_uid: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub param: u32,
    #[prost(bool, tag = "4")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4606)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterHomeResultNotify {
    #[prost(string, tag = "1")]
    pub target_nickname: ::prost::alloc::string::String,
    #[prost(enumeration = "PlayerApplyEnterHomeReason", tag = "2")]
    pub reason: i32,
    #[prost(bool, tag = "3")]
    pub is_agreed: bool,
    #[prost(uint32, tag = "4")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4607)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSceneJumpReq {
    #[prost(bool, tag = "1")]
    pub is_enter_room_scene: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4506)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSceneJumpRsp {
    #[prost(bool, tag = "1")]
    pub is_enter_room_scene: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4806)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChooseModuleReq {
    #[prost(uint32, tag = "1")]
    pub module_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4608)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChooseModuleRsp {
    #[prost(uint32, tag = "1")]
    pub module_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4609)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeModuleUnlockNotify {
    #[prost(uint32, tag = "1")]
    pub module_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeGetOnlineStatusReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4706)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGetOnlineStatusRsp {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<OnlinePlayerInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4610)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeKickPlayerReq {
    #[prost(bool, tag = "1")]
    pub is_kick_all: bool,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4611)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeKickPlayerRsp {
    #[prost(bool, tag = "1")]
    pub is_kick_all: bool,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4807)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeModuleSeenReq {
    #[prost(uint32, repeated, tag = "1")]
    pub seen_module_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4707)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeModuleSeenRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub seen_module_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4507)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockedFurnitureFormulaDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub furniture_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_all: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4612)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockedFurnitureSuiteDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub furniture_suite_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_all: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4708)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetHomeLevelUpRewardReq {
    #[prost(uint32, tag = "1")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4508)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetHomeLevelUpRewardRsp {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4613)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFurnitureCurModuleArrangeCountReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4808)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureCurModuleArrangeCountNotify {
    #[prost(message, repeated, tag = "1")]
    pub furniture_arrange_count_list: ::prost::alloc::vec::Vec<Uint32Pair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeModuleComfortInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub world_scene_block_comfort_value_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub room_scene_comfort_value: u32,
    #[prost(uint32, tag = "3")]
    pub module_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4509)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeComfortInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub module_info_list: ::prost::alloc::vec::Vec<HomeModuleComfortInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4614)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerQuitFromHomeNotify {
    #[prost(enumeration = "PlayerQuitFromHomeReason", tag = "1")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4809)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtherPlayerEnterHomeNotify {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(enumeration = "OtherPlayerEnterHomeNotifyReason", tag = "2")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4510)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePriorCheckNotify {
    #[prost(fixed32, tag = "1")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeMarkPointSceneData {
    #[prost(message, repeated, tag = "1")]
    pub furniture_list: ::prost::alloc::vec::Vec<HomeMarkPointFurnitureData>,
    #[prost(message, optional, tag = "2")]
    pub safe_point_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub teapot_spirit_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub scene_id: u32,
    #[prost(uint32, tag = "5")]
    pub module_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4403)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeMarkPointNotify {
    #[prost(message, repeated, tag = "1")]
    pub mark_point_data_list: ::prost::alloc::vec::Vec<HomeMarkPointSceneData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4404)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAllUnlockedBgmIdListNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub all_unlocked_bgm_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4511)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeNewUnlockedBgmIdListNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub new_unlocked_bgm_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4405)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeBgmReq {
    #[prost(uint32, tag = "1")]
    pub bgm_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeBgmRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeChangeBgmNotify {
    #[prost(uint32, tag = "1")]
    pub bgm_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4810)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePreChangeEditModeNotify {
    #[prost(bool, tag = "1")]
    pub is_enter_edit_mode: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4512)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeEnterEditModeFinishReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4513)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeEnterEditModeFinishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeData {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub make_id: u32,
    #[prost(fixed32, tag = "3")]
    pub begin_time: u32,
    #[prost(uint32, tag = "4")]
    pub dur_time: u32,
    #[prost(uint32, tag = "5")]
    pub index: u32,
    #[prost(fixed32, tag = "6")]
    pub accelerate_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeSlot {
    #[prost(message, repeated, tag = "1")]
    pub furniture_make_data_list: ::prost::alloc::vec::Vec<FurnitureMakeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeBeHelpedData {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub player_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
    #[prost(fixed32, tag = "4")]
    pub time: u32,
    #[prost(uint32, tag = "5")]
    pub icon: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeHelpData {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub times: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeMakeInfo {
    #[prost(uint32, tag = "1")]
    pub furniture_id: u32,
    #[prost(uint32, tag = "2")]
    pub make_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4709)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4615)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeRsp {
    #[prost(message, repeated, tag = "1")]
    pub helped_data_list: ::prost::alloc::vec::Vec<FurnitureMakeBeHelpedData>,
    #[prost(message, optional, tag = "2")]
    pub furniture_make_slot: ::core::option::Option<FurnitureMakeSlot>,
    #[prost(message, repeated, tag = "3")]
    pub help_data_list: ::prost::alloc::vec::Vec<FurnitureMakeHelpData>,
    #[prost(message, repeated, tag = "4")]
    pub make_info_list: ::prost::alloc::vec::Vec<FurnitureMakeMakeInfo>,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4616)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeFurnitureMakeReq {
    #[prost(uint32, tag = "1")]
    pub make_id: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
    #[prost(bool, tag = "3")]
    pub is_fast_finish: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4811)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeFurnitureMakeRsp {
    #[prost(message, repeated, tag = "1")]
    pub return_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub output_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, optional, tag = "3")]
    pub furniture_make_slot: ::core::option::Option<FurnitureMakeSlot>,
    #[prost(uint32, tag = "4")]
    pub make_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4812)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeFinishNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4813)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeStartReq {
    #[prost(uint32, tag = "1")]
    pub make_id: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4710)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeStartRsp {
    #[prost(message, optional, tag = "1")]
    pub furniture_make_slot: ::core::option::Option<FurnitureMakeSlot>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4617)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeCancelReq {
    #[prost(uint32, tag = "1")]
    pub make_id: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4814)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeCancelRsp {
    #[prost(message, optional, tag = "1")]
    pub furniture_make_slot: ::core::option::Option<FurnitureMakeSlot>,
    #[prost(uint32, tag = "2")]
    pub make_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4408)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeBeHelpedNotify {
    #[prost(message, optional, tag = "1")]
    pub furniture_make_helped_data: ::core::option::Option<FurnitureMakeBeHelpedData>,
    #[prost(message, optional, tag = "2")]
    pub furniture_make_slot: ::core::option::Option<FurnitureMakeSlot>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4711)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeHelpReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4514)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FurnitureMakeHelpRsp {
    #[prost(message, repeated, tag = "1")]
    pub help_data_list: ::prost::alloc::vec::Vec<FurnitureMakeHelpData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4515)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FurnitureMakeMakeInfoChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub make_info: ::core::option::Option<FurnitureMakeMakeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopInfo {
    #[prost(message, optional, tag = "1")]
    pub djinn_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub djinn_rot: ::core::option::Option<Vector>,
    #[prost(fixed32, tag = "3")]
    pub next_guest_open_time: u32,
    #[prost(fixed32, tag = "4")]
    pub next_open_time: u32,
    #[prost(fixed32, tag = "5")]
    pub next_close_time: u32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4712)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4815)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub shop_info: ::core::option::Option<HomeLimitedShopInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4816)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub shop_info: ::core::option::Option<HomeLimitedShopInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopGoods {
    #[prost(message, optional, tag = "1")]
    pub goods_item: ::core::option::Option<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub cost_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "3")]
    pub bought_num: u32,
    #[prost(uint32, tag = "4")]
    pub goods_id: u32,
    #[prost(uint32, tag = "5")]
    pub disable_type: u32,
    #[prost(uint32, tag = "6")]
    pub buy_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLimitedShop {
    #[prost(message, repeated, tag = "1")]
    pub goods_list: ::prost::alloc::vec::Vec<HomeLimitedShopGoods>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4713)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopGoodsListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4516)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopGoodsListRsp {
    #[prost(message, optional, tag = "1")]
    pub shop: ::core::option::Option<HomeLimitedShop>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4409)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopBuyGoodsReq {
    #[prost(message, optional, tag = "1")]
    pub goods: ::core::option::Option<HomeLimitedShopGoods>,
    #[prost(uint32, tag = "2")]
    pub buy_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4714)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopBuyGoodsRsp {
    #[prost(message, repeated, tag = "1")]
    pub goods_list: ::prost::alloc::vec::Vec<HomeLimitedShopGoods>,
    #[prost(message, optional, tag = "2")]
    pub goods: ::core::option::Option<HomeLimitedShopGoods>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub buy_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4715)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLimitedShopInfoChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub goods_list: ::prost::alloc::vec::Vec<HomeLimitedShopGoods>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeResource {
    #[prost(fixed32, tag = "1")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "2")]
    pub store_value: u32,
    #[prost(uint32, tag = "3")]
    pub store_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4817)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeResourceNotify {
    #[prost(message, optional, tag = "1")]
    pub home_coin: ::core::option::Option<HomeResource>,
    #[prost(message, optional, tag = "2")]
    pub fetter_exp: ::core::option::Option<HomeResource>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4716)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeResourceTakeHomeCoinReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4717)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeResourceTakeHomeCoinRsp {
    #[prost(message, optional, tag = "1")]
    pub home_coin: ::core::option::Option<HomeResource>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4718)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeResourceTakeFetterExpReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4517)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeResourceTakeFetterExpRsp {
    #[prost(message, optional, tag = "1")]
    pub fetter_exp: ::core::option::Option<HomeResource>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarTalkFinishInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub finish_talk_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4719)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarTalkFinishInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub avatar_talk_info_list: ::prost::alloc::vec::Vec<HomeAvatarTalkFinishInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4818)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarTalkReq {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub talk_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4819)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarTalkRsp {
    #[prost(message, optional, tag = "1")]
    pub avatar_talk_info: ::core::option::Option<HomeAvatarTalkFinishInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarRewardEventInfo {
    #[prost(uint32, tag = "1")]
    pub event_id: u32,
    #[prost(uint32, tag = "2")]
    pub suite_id: u32,
    #[prost(uint32, tag = "3")]
    pub guid: u32,
    #[prost(uint32, tag = "4")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "5")]
    pub random_position: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4820)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarRewardEventNotify {
    #[prost(message, repeated, tag = "1")]
    pub pending_list: ::prost::alloc::vec::Vec<HomeAvatarRewardEventInfo>,
    #[prost(message, optional, tag = "2")]
    pub reward_event: ::core::option::Option<HomeAvatarRewardEventInfo>,
    #[prost(bool, tag = "3")]
    pub is_event_trigger: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4720)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarRewardEventGetReq {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub event_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4821)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarRewardEventGetRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub event_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarSummonEventInfo {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub event_over_time: u32,
    #[prost(uint32, tag = "3")]
    pub random_position: u32,
    #[prost(uint32, tag = "4")]
    pub suit_id: u32,
    #[prost(uint32, tag = "5")]
    pub guid: u32,
    #[prost(uint32, tag = "6")]
    pub event_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4518)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarSummonAllEventNotify {
    #[prost(message, repeated, tag = "1")]
    pub summon_event_list: ::prost::alloc::vec::Vec<HomeAvatarSummonEventInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4721)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarSummonEventReq {
    #[prost(uint32, tag = "1")]
    pub guid: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "3")]
    pub suit_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4822)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarSummonEventRsp {
    #[prost(uint32, tag = "1")]
    pub event_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4519)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarCostumeChangeNotify {
    #[prost(uint32, tag = "1")]
    pub costume_id: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4618)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarSummonFinishReq {
    #[prost(uint32, tag = "1")]
    pub event_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4520)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeAvatarSummonFinishRsp {
    #[prost(uint32, tag = "1")]
    pub event_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4619)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeAvatarAllFinishRewardNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub event_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4410)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSceneInitFinishReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4824)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSceneInitFinishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4521)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePlantSeedReq {
    #[prost(uint32, repeated, tag = "1")]
    pub seed_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub index: u32,
    #[prost(uint32, tag = "3")]
    pub field_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4522)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePlantSeedRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4722)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePlantWeedReq {
    #[prost(uint32, tag = "1")]
    pub field_guid: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4620)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePlantWeedRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePlantSubFieldData {
    #[prost(uint32, repeated, tag = "1")]
    pub entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub home_gather_id: u32,
    #[prost(enumeration = "HomePlantFieldStatus", tag = "3")]
    pub field_status: i32,
    #[prost(fixed32, tag = "4")]
    pub end_time: u32,
    #[prost(uint32, tag = "5")]
    pub seed_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePlantFieldData {
    #[prost(message, optional, tag = "1")]
    pub spawn_pos: ::core::option::Option<Vector>,
    #[prost(message, repeated, tag = "2")]
    pub sub_field_list: ::prost::alloc::vec::Vec<HomePlantSubFieldData>,
    #[prost(uint32, tag = "3")]
    pub furniture_id: u32,
    #[prost(uint32, tag = "4")]
    pub field_guid: u32,
    #[prost(uint32, tag = "5")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4621)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePlantInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub field_list: ::prost::alloc::vec::Vec<HomePlantFieldData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4622)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePlantFieldNotify {
    #[prost(message, optional, tag = "1")]
    pub field: ::core::option::Option<HomePlantFieldData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4825)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePlantInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4523)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePlantInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub field_list: ::prost::alloc::vec::Vec<HomePlantFieldData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4411)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeTransferReq {
    #[prost(uint32, tag = "1")]
    pub guid: u32,
    #[prost(bool, tag = "2")]
    pub is_transfer_to_safe_point: bool,
    #[prost(bool, tag = "3")]
    pub is_transfer_to_main_house: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeTransferRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeFishFarmingInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub fish_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub fishpond_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4826)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeGetFishFarmingInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4723)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGetFishFarmingInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub fish_farming_info_list: ::prost::alloc::vec::Vec<HomeFishFarmingInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4827)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeFishFarmingInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub fish_farming_info_list: ::prost::alloc::vec::Vec<HomeFishFarmingInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4623)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeUpdateFishFarmingInfoReq {
    #[prost(message, optional, tag = "1")]
    pub fish_farming_info: ::core::option::Option<HomeFishFarmingInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4624)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeUpdateFishFarmingInfoRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeScenePointFishFarmingInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub fish_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub local_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4625)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeUpdateScenePointFishFarmingInfoReq {
    #[prost(message, optional, tag = "1")]
    pub fish_farming_info: ::core::option::Option<HomeScenePointFishFarmingInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4413)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeUpdateScenePointFishFarmingInfoRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4724)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeScenePointFishFarmingInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub fish_farming_info_list: ::prost::alloc::vec::Vec<HomeScenePointFishFarmingInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeCustomFurnitureInfo {
    #[prost(message, repeated, tag = "1")]
    pub sub_furniture_list: ::prost::alloc::vec::Vec<CustomCommonNodeInfo>,
    #[prost(uint32, tag = "2")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4626)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeCustomFurnitureInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub custom_furniture_info_list: ::prost::alloc::vec::Vec<HomeCustomFurnitureInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub delete_custom_furniture_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub used_sub_furniture_count_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4725)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeEditCustomFurnitureReq {
    #[prost(message, optional, tag = "1")]
    pub custom_furniture_info: ::core::option::Option<HomeCustomFurnitureInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4524)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeEditCustomFurnitureRsp {
    #[prost(message, optional, tag = "1")]
    pub custom_furniture_info: ::core::option::Option<HomeCustomFurnitureInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePictureFrameInfo {
    #[prost(uint32, tag = "1")]
    pub picture_id: u32,
    #[prost(uint32, tag = "2")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4726)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePictureFrameInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub picture_frame_info_list: ::prost::alloc::vec::Vec<HomePictureFrameInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4525)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeUpdatePictureFrameInfoReq {
    #[prost(message, optional, tag = "1")]
    pub picture_frame_info: ::core::option::Option<HomePictureFrameInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4828)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeUpdatePictureFrameInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub picture_frame_info: ::core::option::Option<HomePictureFrameInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4526)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeRacingGallerySettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<RacingGallerySettleInfo>,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "4")]
    pub rank: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGroupPlayerInfo {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub psn_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "4")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub player_level: u32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeRacingGalleryRecord {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<HomeGroupPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub timestamp: u32,
    #[prost(uint32, tag = "3")]
    pub use_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeRacingRecord {
    #[prost(message, repeated, tag = "1")]
    pub record_list: ::prost::alloc::vec::Vec<HomeRacingGalleryRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBalloonGalleryRecord {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<HomeGroupPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(uint32, tag = "3")]
    pub timestamp: u32,
    #[prost(uint32, tag = "4")]
    pub hit_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBalloonRecord {
    #[prost(message, repeated, tag = "1")]
    pub record_list: ::prost::alloc::vec::Vec<HomeBalloonGalleryRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeStakePlayRecord {
    #[prost(message, repeated, tag = "1")]
    pub engaged_player_info_list: ::prost::alloc::vec::Vec<HomeGroupPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeStakeRecord {
    #[prost(message, repeated, tag = "1")]
    pub record_list: ::prost::alloc::vec::Vec<HomeStakePlayRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSeekFurniturePlayerScore {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<HomeGroupPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSeekFurnitureOneRecord {
    #[prost(message, repeated, tag = "1")]
    pub engaged_player_score_list: ::prost::alloc::vec::Vec<
        HomeSeekFurniturePlayerScore,
    >,
    #[prost(uint32, tag = "2")]
    pub timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSeekFurnitureAllRecord {
    #[prost(message, repeated, tag = "1")]
    pub record_list: ::prost::alloc::vec::Vec<HomeSeekFurnitureOneRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGroupRecord {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(oneof = "home_group_record::Detail", tags = "2, 3, 4, 5")]
    pub detail: ::core::option::Option<home_group_record::Detail>,
}
/// Nested message and enum types in `HomeGroupRecord`.
pub mod home_group_record {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "2")]
        RacingGalleryInfo(super::HomeRacingRecord),
        #[prost(message, tag = "3")]
        BalloonGalleryInfo(super::HomeBalloonRecord),
        #[prost(message, tag = "4")]
        StakePlayInfo(super::HomeStakeRecord),
        #[prost(message, tag = "5")]
        SeekFurnitureGalleryInfo(super::HomeSeekFurnitureAllRecord),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4627)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeGetGroupRecordReq {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4727)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGetGroupRecordRsp {
    #[prost(message, optional, tag = "1")]
    pub group_record: ::core::option::Option<HomeGroupRecord>,
    #[prost(uint32, tag = "2")]
    pub record_type: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4628)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeClearGroupRecordReq {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4414)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeClearGroupRecordRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4415)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeBalloonGallerySettleNotify {
    #[prost(message, optional, tag = "1")]
    pub settle_info: ::core::option::Option<BalloonGallerySettleInfo>,
    #[prost(bool, tag = "2")]
    pub is_new_record: bool,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "4")]
    pub rank: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4728)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeBalloonGalleryScoreNotify {
    #[prost(uint32, tag = "1")]
    pub add_score: u32,
    #[prost(uint32, tag = "2")]
    pub gallery_id: u32,
    #[prost(uint32, tag = "3")]
    pub cur_score: u32,
    #[prost(uint32, tag = "4")]
    pub trigger_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4729)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSeekFurnitureGalleryScoreNotify {
    #[prost(message, optional, tag = "1")]
    pub record: ::core::option::Option<HomeSeekFurnitureOneRecord>,
    #[prost(enumeration = "GalleryStopReason", tag = "2")]
    pub reason: i32,
    #[prost(uint32, tag = "3")]
    pub gallery_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4730)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetHomeExchangeWoodInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4629)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHomeExchangeWoodInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub wood_info_list: ::prost::alloc::vec::Vec<HomeExchangeWoodInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeExchangeWoodInfo {
    #[prost(fixed32, tag = "1")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "2")]
    pub wood_id: u32,
    #[prost(uint32, tag = "3")]
    pub exchange_limit: u32,
    #[prost(uint32, tag = "4")]
    pub exchanged_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4630)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeExchangeWoodReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub material_count_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub wood_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4829)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeExchangeWoodRsp {
    #[prost(uint32, tag = "1")]
    pub wood_count: u32,
    #[prost(uint32, tag = "2")]
    pub wood_id: u32,
    #[prost(uint32, tag = "3")]
    pub exchanged_count: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBlueprintSlotInfo {
    #[prost(string, tag = "1")]
    pub share_code: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub module_id: u32,
    #[prost(uint32, tag = "4")]
    pub create_time: u32,
    #[prost(uint32, tag = "5")]
    pub block_id: u32,
    #[prost(bool, tag = "6")]
    pub is_allow_copy: bool,
    #[prost(bool, tag = "7")]
    pub is_save_from_other: bool,
    #[prost(uint32, tag = "8")]
    pub slot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4416)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeGetBlueprintSlotInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4631)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeGetBlueprintSlotInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub slot_info_list: ::prost::alloc::vec::Vec<HomeBlueprintSlotInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub delete_slot_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4830)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSetBlueprintSlotOptionReq {
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
    #[prost(bool, tag = "2")]
    pub is_allow_copy: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4527)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSetBlueprintSlotOptionRsp {
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_allow_copy: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4831)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSetBlueprintFriendOptionReq {
    #[prost(bool, tag = "1")]
    pub is_allow_friend_copy: bool,
    #[prost(bool, tag = "2")]
    pub is_need_owner_confirm: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4528)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSetBlueprintFriendOptionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_allow_friend_copy: bool,
    #[prost(bool, tag = "3")]
    pub is_need_owner_confirm: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4832)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeBlueprintInfoNotify {
    #[prost(bool, tag = "1")]
    pub is_allow_friend_copy: bool,
    #[prost(bool, tag = "2")]
    pub is_need_owner_confirm: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4529)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePreviewBlueprintReq {
    #[prost(string, tag = "1")]
    pub share_code: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub slot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4530)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePreviewBlueprintRsp {
    #[prost(message, optional, tag = "1")]
    pub scene_arrangement_info: ::core::option::Option<HomeSceneArrangementInfo>,
    #[prost(string, tag = "2")]
    pub share_code: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4833)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeCreateBlueprintReq {
    #[prost(string, tag = "1")]
    pub server_share_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub scene_arrangement_info: ::core::option::Option<HomeSceneArrangementInfo>,
    #[prost(uint32, tag = "3")]
    pub slot_id: u32,
    #[prost(uint32, tag = "4")]
    pub gen_share_code_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4834)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeCreateBlueprintRsp {
    #[prost(message, optional, tag = "1")]
    pub slot_info: ::core::option::Option<HomeBlueprintSlotInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4632)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeDeleteBlueprintReq {
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4633)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeDeleteBlueprintRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub slot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeBlueprintSearchInfo {
    #[prost(string, tag = "1")]
    pub share_code: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub module_id: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
    #[prost(uint32, tag = "4")]
    pub block_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4634)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSearchBlueprintReq {
    #[prost(string, tag = "1")]
    pub share_code: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4835)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSearchBlueprintRsp {
    #[prost(message, optional, tag = "1")]
    pub search_info: ::core::option::Option<HomeBlueprintSearchInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4731)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSaveBlueprintToSlotReq {
    #[prost(string, tag = "1")]
    pub share_code: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4531)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSaveBlueprintToSlotRsp {
    #[prost(message, optional, tag = "1")]
    pub slot_info: ::core::option::Option<HomeBlueprintSlotInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4635)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyCreateBlueprintNotify {
    #[prost(message, optional, tag = "1")]
    pub src_player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub src_app_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4732)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyCreateBlueprintResultReq {
    #[prost(uint32, tag = "1")]
    pub apply_uid: u32,
    #[prost(bool, tag = "2")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4532)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyCreateBlueprintResultRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub apply_uid: u32,
    #[prost(bool, tag = "3")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4417)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyCreateBlueprintResultNotify {
    #[prost(string, tag = "1")]
    pub target_nickname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
    #[prost(enumeration = "PlayerApplyCreateBlueprintResultNotifyReason", tag = "3")]
    pub reason: i32,
    #[prost(bool, tag = "4")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4636)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSaveArrangementNoChangeReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4733)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSaveArrangementNoChangeRsp {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingPair {
    #[prost(uint32, tag = "1")]
    pub refresh_id: u32,
    #[prost(uint32, tag = "2")]
    pub monster_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4301)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeHuntingOfferReq {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeHuntingOfferRsp {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingOfferData {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
    #[prost(enumeration = "HuntingOfferState", tag = "3")]
    pub state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCityHuntingOfferReq {
    #[prost(uint32, tag = "1")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4304)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCityHuntingOfferRsp {
    #[prost(message, optional, tag = "1")]
    pub ongoing_hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(message, repeated, tag = "2")]
    pub hunting_offer_list: ::prost::alloc::vec::Vec<HuntingOfferData>,
    #[prost(uint32, tag = "3")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "4")]
    pub city_id: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub cur_week_finished_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4305)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetHuntingOfferRewardReq {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetHuntingOfferRewardRsp {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingStartNotify {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(message, optional, tag = "2")]
    pub clue_position: ::core::option::Option<Vector>,
    #[prost(bool, tag = "3")]
    pub is_final: bool,
    #[prost(uint32, tag = "4")]
    pub fail_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4308)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingRevealClueNotify {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(message, optional, tag = "2")]
    pub clue_position: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub finished_group_id: u32,
    #[prost(uint32, tag = "4")]
    pub finish_clue_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4309)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingRevealFinalNotify {
    #[prost(message, optional, tag = "1")]
    pub final_position: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(uint32, tag = "3")]
    pub finished_group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingSuccessNotify {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingFailNotify {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4312)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingOngoingNotify {
    #[prost(message, optional, tag = "1")]
    pub next_position: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(bool, tag = "3")]
    pub is_started: bool,
    #[prost(bool, tag = "4")]
    pub is_final: bool,
    #[prost(uint32, tag = "5")]
    pub finish_clue_count: u32,
    #[prost(uint32, tag = "6")]
    pub fail_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4313)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingGiveUpReq {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4314)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HuntingGiveUpRsp {
    #[prost(message, optional, tag = "1")]
    pub hunting_pair: ::core::option::Option<HuntingPair>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Investigation {
    #[prost(uint32, tag = "1")]
    pub progress: u32,
    #[prost(uint32, tag = "2")]
    pub total_progress: u32,
    #[prost(enumeration = "InvestigationState", tag = "3")]
    pub state: i32,
    #[prost(uint32, tag = "4")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvestigationTarget {
    #[prost(enumeration = "InvestigationTargetState", tag = "1")]
    pub state: i32,
    #[prost(uint32, tag = "2")]
    pub investigation_id: u32,
    #[prost(uint32, tag = "3")]
    pub quest_id: u32,
    #[prost(uint32, tag = "4")]
    pub progress: u32,
    #[prost(uint32, tag = "5")]
    pub total_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1927)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerInvestigationAllInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub investigation_target_list: ::prost::alloc::vec::Vec<InvestigationTarget>,
    #[prost(message, repeated, tag = "2")]
    pub investigation_list: ::prost::alloc::vec::Vec<Investigation>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1928)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeInvestigationRewardReq {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1929)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeInvestigationRewardRsp {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1930)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeInvestigationTargetRewardReq {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1931)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeInvestigationTargetRewardRsp {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1932)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInvestigationMonsterReq {
    #[prost(uint32, repeated, tag = "1")]
    pub city_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_for_mark: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvestigationMonster {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub weekly_boss_resin_discount_info: ::core::option::Option<
        WeeklyBossResinDiscountInfo,
    >,
    #[prost(uint32, tag = "3")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "4")]
    pub max_boss_chest_num: u32,
    #[prost(uint32, tag = "5")]
    pub resin: u32,
    #[prost(uint32, tag = "6")]
    pub id: u32,
    #[prost(uint32, tag = "7")]
    pub level: u32,
    #[prost(uint32, tag = "8")]
    pub monster_id: u32,
    #[prost(bool, tag = "9")]
    pub is_alive: bool,
    #[prost(bool, tag = "10")]
    pub is_area_locked: bool,
    #[prost(uint32, tag = "11")]
    pub boss_chest_num: u32,
    #[prost(uint32, tag = "12")]
    pub city_id: u32,
    #[prost(uint32, tag = "13")]
    pub refresh_interval: u32,
    #[prost(uint32, tag = "14")]
    pub group_id: u32,
    #[prost(uint32, tag = "15")]
    pub scene_id: u32,
    #[prost(uint32, tag = "16")]
    pub next_boss_chest_refresh_time: u32,
    #[prost(enumeration = "LockState", tag = "17")]
    pub lock_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1933)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInvestigationMonsterRsp {
    #[prost(message, repeated, tag = "1")]
    pub monster_list: ::prost::alloc::vec::Vec<InvestigationMonster>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_for_mark: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1934)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerInvestigationNotify {
    #[prost(message, repeated, tag = "1")]
    pub investigation_list: ::prost::alloc::vec::Vec<Investigation>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1935)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerInvestigationTargetNotify {
    #[prost(message, repeated, tag = "1")]
    pub investigation_target_list: ::prost::alloc::vec::Vec<InvestigationTarget>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1936)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarkTargetInvestigationMonsterNotify {
    #[prost(uint32, tag = "1")]
    pub monster_id: u32,
    #[prost(uint32, tag = "2")]
    pub investigation_monster_id: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
    #[prost(uint32, tag = "4")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1937)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvestigationMonsterUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub investigation_monster: ::core::option::Option<InvestigationMonster>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1938)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvestigationQuestDailyNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1939)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvestigationReadQuestDailyNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(601)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerStoreNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<Item>,
    #[prost(enumeration = "StoreType", tag = "2")]
    pub store_type: i32,
    #[prost(uint32, tag = "3")]
    pub weight_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(602)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StoreWeightLimitNotify {
    #[prost(uint32, tag = "1")]
    pub material_count_limit: u32,
    #[prost(uint32, tag = "2")]
    pub reliquary_count_limit: u32,
    #[prost(uint32, tag = "3")]
    pub weight_limit: u32,
    #[prost(uint32, tag = "4")]
    pub furniture_count_limit: u32,
    #[prost(enumeration = "StoreType", tag = "5")]
    pub store_type: i32,
    #[prost(uint32, tag = "6")]
    pub weapon_count_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(603)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreItemChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<Item>,
    #[prost(enumeration = "StoreType", tag = "2")]
    pub store_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(604)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreItemDelNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(enumeration = "StoreType", tag = "2")]
    pub store_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ItemHint {
    #[prost(bool, tag = "1")]
    pub is_new: bool,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
    #[prost(uint32, tag = "3")]
    pub item_id: u32,
    #[prost(uint32, tag = "4")]
    pub count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(605)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemAddHintNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemHint>,
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<Vector>,
    #[prost(message, repeated, tag = "3")]
    pub overflow_transformed_item_list: ::prost::alloc::vec::Vec<ItemHint>,
    #[prost(bool, tag = "4")]
    pub is_position_valid: bool,
    #[prost(bool, tag = "5")]
    pub is_transferred_from_avatar_card: bool,
    #[prost(bool, tag = "6")]
    pub is_general_reward_hidden: bool,
    #[prost(uint32, tag = "7")]
    pub quest_id: u32,
    #[prost(uint32, tag = "8")]
    pub reason: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(606)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseItemReq {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(bool, tag = "2")]
    pub is_enter_mp_dungeon_team: bool,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
    #[prost(uint64, tag = "4")]
    pub target_guid: u64,
    #[prost(uint32, tag = "5")]
    pub option_idx: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(607)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseItemRsp {
    #[prost(uint64, tag = "1")]
    pub target_guid: u64,
    #[prost(uint32, tag = "2")]
    pub option_idx: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint64, tag = "4")]
    pub guid: u64,
    #[prost(uint32, tag = "5")]
    pub item_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(608)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DropItemReq {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(enumeration = "StoreType", tag = "2")]
    pub store_type: i32,
    #[prost(uint32, tag = "3")]
    pub count: u32,
    #[prost(uint64, tag = "4")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(609)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DropItemRsp {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "StoreType", tag = "3")]
    pub store_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(610)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WearEquipReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint64, tag = "2")]
    pub equip_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(611)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WearEquipRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub equip_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(612)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeoffEquipReq {
    #[prost(uint32, tag = "1")]
    pub slot: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(613)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeoffEquipRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub slot: u32,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(614)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarEquipChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub weapon: ::core::option::Option<SceneWeaponInfo>,
    #[prost(message, optional, tag = "2")]
    pub reliquary: ::core::option::Option<SceneReliquaryInfo>,
    #[prost(uint64, tag = "3")]
    pub equip_guid: u64,
    #[prost(uint32, tag = "4")]
    pub item_id: u32,
    #[prost(uint32, tag = "5")]
    pub equip_type: u32,
    #[prost(uint64, tag = "6")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(615)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeaponUpgradeReq {
    #[prost(message, repeated, tag = "1")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint64, repeated, tag = "2")]
    pub food_weapon_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "3")]
    pub target_weapon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(616)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeaponUpgradeRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub old_level: u32,
    #[prost(uint64, tag = "3")]
    pub target_weapon_guid: u64,
    #[prost(uint32, tag = "4")]
    pub cur_level: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(617)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeaponPromoteReq {
    #[prost(uint64, tag = "1")]
    pub target_weapon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(618)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeaponPromoteRsp {
    #[prost(uint32, tag = "1")]
    pub old_promote_level: u32,
    #[prost(uint32, tag = "2")]
    pub cur_promote_level: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint64, tag = "4")]
    pub target_weapon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(619)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryUpgradeReq {
    #[prost(uint64, repeated, tag = "1")]
    pub food_reliquary_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "2")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint64, tag = "3")]
    pub target_reliquary_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(620)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryUpgradeRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub old_append_prop_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub cur_append_prop_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, tag = "3")]
    pub target_reliquary_guid: u64,
    #[prost(uint32, tag = "4")]
    pub old_level: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub power_up_rate: u32,
    #[prost(uint32, tag = "7")]
    pub cur_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(621)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReliquaryPromoteReq {
    #[prost(uint64, tag = "1")]
    pub target_guid: u64,
    #[prost(uint64, tag = "2")]
    pub item_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(622)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryPromoteRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub cur_append_prop_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub old_append_prop_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub old_promote_level: u32,
    #[prost(uint64, tag = "5")]
    pub target_reliquary_guid: u64,
    #[prost(uint32, tag = "6")]
    pub cur_promote_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(623)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarCardChangeReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub count: u32,
    #[prost(uint32, tag = "3")]
    pub item_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(624)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarCardChangeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(625)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantRewardNotify {
    #[prost(message, optional, tag = "1")]
    pub reward: ::core::option::Option<Reward>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(626)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeaponAwakenReq {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub affix_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint64, tag = "2")]
    pub item_guid: u64,
    #[prost(uint64, tag = "3")]
    pub target_weapon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(627)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeaponAwakenRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub cur_affix_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub old_affix_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint64, tag = "3")]
    pub target_weapon_guid: u64,
    #[prost(uint64, tag = "4")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "5")]
    pub target_weapon_awaken_level: u32,
    #[prost(int32, tag = "6")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(628)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemCdGroupTimeNotify {
    #[prost(map = "uint32, uint64", tag = "1")]
    pub item_cd_map: ::std::collections::HashMap<u32, u64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(629)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropHintNotify {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint32, repeated, tag = "2")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(630)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CombineReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub combine_count: u32,
    #[prost(uint32, tag = "3")]
    pub combine_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(631)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CombineRsp {
    #[prost(message, repeated, tag = "1")]
    pub result_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub cost_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "3")]
    pub total_return_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "4")]
    pub total_random_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "5")]
    pub total_extra_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "6")]
    pub combine_count: u32,
    #[prost(uint64, tag = "7")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "8")]
    pub combine_id: u32,
    #[prost(int32, tag = "9")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForgeQueueData {
    #[prost(uint32, tag = "1")]
    pub total_finish_timestamp: u32,
    #[prost(uint32, tag = "2")]
    pub unfinished_count: u32,
    #[prost(uint32, tag = "3")]
    pub next_finish_timestamp: u32,
    #[prost(uint32, tag = "4")]
    pub forge_id: u32,
    #[prost(uint32, tag = "5")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "6")]
    pub finish_count: u32,
    #[prost(uint32, tag = "7")]
    pub queue_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(632)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgeQueueDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub removed_forge_queue_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, message", tag = "2")]
    pub forge_queue_map: ::std::collections::HashMap<u32, ForgeQueueData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(633)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForgeGetQueueDataReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(634)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgeGetQueueDataRsp {
    #[prost(map = "uint32, message", tag = "1")]
    pub forge_queue_map: ::std::collections::HashMap<u32, ForgeQueueData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub max_queue_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(635)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForgeStartReq {
    #[prost(uint32, tag = "1")]
    pub forge_count: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "3")]
    pub forge_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(636)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForgeStartRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(637)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForgeQueueManipulateReq {
    #[prost(enumeration = "ForgeQueueManipulateType", tag = "1")]
    pub manipulate_type: i32,
    #[prost(uint32, tag = "2")]
    pub forge_queue_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(638)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgeQueueManipulateRsp {
    #[prost(message, repeated, tag = "1")]
    pub return_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub extra_output_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "3")]
    pub output_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(enumeration = "ForgeQueueManipulateType", tag = "4")]
    pub manipulate_type: i32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(639)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResinChangeNotify {
    #[prost(uint32, tag = "1")]
    pub next_add_timestamp: u32,
    #[prost(uint32, tag = "2")]
    pub cur_value: u32,
    #[prost(uint32, tag = "3")]
    pub cur_buy_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(640)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuyResinReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(641)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuyResinRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub cur_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(642)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaterialDeleteReturnNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub delete_material_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub return_item_map: ::std::collections::HashMap<u32, u32>,
    #[prost(enumeration = "MaterialDeleteReturnType", tag = "3")]
    pub r#type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(643)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeMaterialDeleteReturnReq {
    #[prost(enumeration = "MaterialDeleteReturnType", tag = "1")]
    pub r#type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(644)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeMaterialDeleteReturnRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(645)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaterialDeleteUpdateNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(646)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct McoinExchangeHcoinReq {
    #[prost(uint32, tag = "1")]
    pub mcoin_cost: u32,
    #[prost(uint32, tag = "2")]
    pub hcoin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(647)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct McoinExchangeHcoinRsp {
    #[prost(uint32, tag = "1")]
    pub hcoin: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub mcoin_cost: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaterialInfo {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(648)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestroyMaterialReq {
    #[prost(message, repeated, tag = "1")]
    pub material_list: ::prost::alloc::vec::Vec<MaterialInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(649)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestroyMaterialRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub item_count_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(650)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEquipLockStateReq {
    #[prost(bool, tag = "1")]
    pub is_locked: bool,
    #[prost(uint64, tag = "2")]
    pub target_equip_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(651)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEquipLockStateRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_locked: bool,
    #[prost(uint64, tag = "3")]
    pub target_equip_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(652)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalcWeaponUpgradeReturnItemsReq {
    #[prost(message, repeated, tag = "1")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint64, repeated, tag = "2")]
    pub food_weapon_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "3")]
    pub target_weapon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(653)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalcWeaponUpgradeReturnItemsRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint64, tag = "2")]
    pub target_weapon_guid: u64,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(654)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgeDataNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub forge_queue_map: ::std::collections::HashMap<u32, ForgeQueueData>,
    #[prost(uint32, repeated, tag = "2")]
    pub forge_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub max_queue_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(655)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForgeFormulaDataNotify {
    #[prost(uint32, tag = "1")]
    pub forge_id: u32,
    #[prost(bool, tag = "2")]
    pub is_locked: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(656)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CombineDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub combine_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(657)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CombineFormulaDataNotify {
    #[prost(uint32, tag = "1")]
    pub combine_id: u32,
    #[prost(bool, tag = "2")]
    pub is_locked: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(658)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClosedItemNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub item_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(659)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckAddItemExceedLimitNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub exceeded_item_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub exceeded_item_type_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_drop: bool,
    #[prost(enumeration = "ItemExceedLimitMsgType", tag = "4")]
    pub msg_type: i32,
    #[prost(uint32, tag = "5")]
    pub reason: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(660)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetIsAutoUnlockSpecificEquipReq {
    #[prost(bool, tag = "1")]
    pub is_auto_unlock_specific_equip: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(661)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetIsAutoUnlockSpecificEquipRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(662)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryDecomposeReq {
    #[prost(uint64, repeated, tag = "1")]
    pub guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub target_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(663)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryDecomposeRsp {
    #[prost(uint64, repeated, tag = "1")]
    pub guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(664)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryFilterStateSaveNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub reliquary_filter_state_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(665)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReliquaryFilterStateNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub reliquary_filter_state_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub mail_list: ::prost::alloc::vec::Vec<MailData>,
    #[prost(uint32, repeated, tag = "2")]
    pub del_mail_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadMailNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub mail_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1403)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMailItemReq {
    #[prost(uint32, repeated, tag = "1")]
    pub mail_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1404)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMailItemRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub mail_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub item_list: ::prost::alloc::vec::Vec<EquipParam>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1405)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelMailReq {
    #[prost(uint32, repeated, tag = "1")]
    pub mail_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1406)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelMailRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub mail_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1407)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAuthkeyReq {
    #[prost(string, tag = "1")]
    pub auth_appid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub authkey_ver: u32,
    #[prost(uint32, tag = "3")]
    pub sign_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1408)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAuthkeyRsp {
    #[prost(string, tag = "1")]
    pub authkey: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub game_biz: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub auth_appid: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub sign_type: u32,
    #[prost(uint32, tag = "6")]
    pub authkey_ver: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientNewMailNotify {
    #[prost(uint32, tag = "1")]
    pub not_got_attachment_num: u32,
    #[prost(uint32, tag = "2")]
    pub not_read_num: u32,
    #[prost(bool, tag = "3")]
    pub aabeckmmeac: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1410)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllMailReq {
    #[prost(bool, tag = "1")]
    pub is_collected: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1411)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllMailRsp {
    #[prost(message, repeated, tag = "1")]
    pub mail_list: ::prost::alloc::vec::Vec<MailData>,
    #[prost(bool, tag = "2")]
    pub is_truncated: bool,
    #[prost(bool, tag = "3")]
    pub is_collected: bool,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1412)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeMailStarNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub mail_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_star: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1413)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllMailNotify {
    #[prost(bool, tag = "1")]
    pub is_collected: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1414)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllMailResultNotify {
    #[prost(message, repeated, tag = "1")]
    pub mail_list: ::prost::alloc::vec::Vec<MailData>,
    #[prost(string, tag = "2")]
    pub transaction: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub total_page_count: u32,
    #[prost(bool, tag = "4")]
    pub is_collected: bool,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub page_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerStartMatchReq {
    #[prost(uint32, repeated, tag = "1")]
    pub match_param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub match_id: u32,
    #[prost(enumeration = "MatchType", tag = "3")]
    pub match_type: i32,
    #[prost(uint32, tag = "4")]
    pub mechanicus_difficult_level: u32,
    #[prost(uint32, tag = "5")]
    pub mp_play_id: u32,
    #[prost(uint32, tag = "6")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerStartMatchRsp {
    #[prost(uint32, tag = "1")]
    pub mp_play_id: u32,
    #[prost(uint32, tag = "2")]
    pub punish_end_time: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
    #[prost(enumeration = "MatchType", tag = "4")]
    pub match_type: i32,
    #[prost(uint32, tag = "5")]
    pub mechanicus_difficult_level: u32,
    #[prost(uint32, tag = "6")]
    pub match_id: u32,
    #[prost(int32, tag = "7")]
    pub retcode: i32,
    #[prost(uint32, tag = "8")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4103)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerMatchInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub match_param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub mechanicus_difficult_level: u32,
    #[prost(uint32, tag = "3")]
    pub match_id: u32,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "5")]
    pub host_uid: u32,
    #[prost(enumeration = "MatchType", tag = "6")]
    pub match_type: i32,
    #[prost(uint32, tag = "7")]
    pub estimate_match_cost_time: u32,
    #[prost(uint32, tag = "8")]
    pub mp_play_id: u32,
    #[prost(uint32, tag = "9")]
    pub match_begin_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCancelMatchReq {
    #[prost(enumeration = "MatchType", tag = "1")]
    pub match_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCancelMatchRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(enumeration = "MatchType", tag = "2")]
    pub match_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4106)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerMatchStopNotify {
    #[prost(enumeration = "MatchReason", tag = "1")]
    pub reason: i32,
    #[prost(uint32, tag = "2")]
    pub host_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchPlayerInfo {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(bool, tag = "2")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneralMatchInfo {
    #[prost(message, repeated, tag = "1")]
    pub player_list: ::prost::alloc::vec::Vec<MatchPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub match_param: u32,
    #[prost(uint32, tag = "3")]
    pub match_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcgMatchInfo {
    #[prost(message, repeated, tag = "1")]
    pub player_list: ::prost::alloc::vec::Vec<MatchPlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4107)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerMatchSuccNotify {
    #[prost(message, optional, tag = "1")]
    pub gcg_match_info: ::core::option::Option<GcgMatchInfo>,
    #[prost(message, optional, tag = "2")]
    pub general_match_info: ::core::option::Option<GeneralMatchInfo>,
    #[prost(uint32, tag = "3")]
    pub mp_play_id: u32,
    #[prost(uint32, tag = "4")]
    pub confirm_end_time: u32,
    #[prost(uint32, tag = "5")]
    pub host_uid: u32,
    #[prost(uint32, tag = "6")]
    pub mechanicus_difficult_level: u32,
    #[prost(uint32, tag = "7")]
    pub dungeon_id: u32,
    #[prost(enumeration = "MatchType", tag = "8")]
    pub match_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4108)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerConfirmMatchReq {
    #[prost(enumeration = "MatchType", tag = "1")]
    pub match_type: i32,
    #[prost(bool, tag = "2")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4109)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerConfirmMatchRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(enumeration = "MatchType", tag = "2")]
    pub match_type: i32,
    #[prost(uint32, tag = "3")]
    pub match_id: u32,
    #[prost(bool, tag = "4")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4110)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerAllowEnterMpAfterAgreeMatchNotify {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerMatchAgreedResultNotify {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(enumeration = "MatchType", tag = "2")]
    pub match_type: i32,
    #[prost(enumeration = "PlayerMatchAgreedResultNotifyReason", tag = "3")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4112)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpAfterMatchAgreedNotify {
    #[prost(message, optional, tag = "1")]
    pub src_player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub matchserver_id: u32,
    #[prost(enumeration = "MatchType", tag = "3")]
    pub match_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4113)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerGeneralMatchDismissNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub match_id: u32,
    #[prost(enumeration = "MatchReason", tag = "3")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4114)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerGeneralMatchConfirmNotify {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub match_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4115)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerGetForceQuitBanInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4116)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerGetForceQuitBanInfoRsp {
    #[prost(uint32, tag = "1")]
    pub match_id: u32,
    #[prost(uint32, tag = "2")]
    pub expire_time: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4117)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerTryCancelGeneralMatchNotify {
    #[prost(uint32, tag = "1")]
    pub match_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4118)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerGcgMatchDismissNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub match_id: u32,
    #[prost(enumeration = "MatchReason", tag = "3")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4119)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerGcgMatchConfirmNotify {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub match_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4120)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Nodacifpfbp {
    #[prost(uint32, tag = "1")]
    pub match_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MechanicusInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub open_sequence_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub gear_level_pair_list: ::prost::alloc::vec::Vec<Uint32Pair>,
    #[prost(uint32, repeated, tag = "3")]
    pub finish_difficult_level_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "4")]
    pub is_finish_teach_dungeon: bool,
    #[prost(uint32, tag = "5")]
    pub punish_over_time: u32,
    #[prost(uint32, tag = "6")]
    pub coin: u32,
    #[prost(uint32, tag = "7")]
    pub mechanicus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMechanicusInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3902)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMechanicusInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub mechanicus_info: ::core::option::Option<MechanicusInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3903)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusSequenceOpenNotify {
    #[prost(uint32, tag = "1")]
    pub mechanicus_id: u32,
    #[prost(uint32, tag = "2")]
    pub sequence_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusCoinNotify {
    #[prost(uint32, tag = "1")]
    pub mechanicus_id: u32,
    #[prost(uint32, tag = "2")]
    pub coin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusOpenNotify {
    #[prost(uint32, tag = "1")]
    pub mechanicus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3906)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusCloseNotify {
    #[prost(uint32, tag = "1")]
    pub mechanicus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3907)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusUnlockGearReq {
    #[prost(uint32, tag = "1")]
    pub gear_id: u32,
    #[prost(uint32, tag = "2")]
    pub mechanicus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3908)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusUnlockGearRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub gear_id: u32,
    #[prost(uint32, tag = "3")]
    pub mechanicus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3909)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusLevelupGearReq {
    #[prost(uint32, tag = "1")]
    pub gear_id: u32,
    #[prost(uint32, tag = "2")]
    pub mechanicus_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3910)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusLevelupGearRsp {
    #[prost(uint32, tag = "1")]
    pub gear_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub mechanicus_id: u32,
    #[prost(uint32, tag = "4")]
    pub after_gear_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3911)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterMechanicusDungeonReq {
    #[prost(uint32, tag = "1")]
    pub difficult_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3912)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterMechanicusDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub wrong_uid: u32,
    #[prost(uint32, tag = "3")]
    pub difficult_level: u32,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3913)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusCandidateTeamCreateReq {
    #[prost(uint32, tag = "1")]
    pub difficult_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3914)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MechanicusCandidateTeamCreateRsp {
    #[prost(uint32, tag = "1")]
    pub difficult_level: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseMiracleRingReq {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub miracle_ring_op_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseMiracleRingRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub miracle_ring_op_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiracleRingDataNotify {
    #[prost(uint32, tag = "1")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub last_deliver_item_time: u32,
    #[prost(bool, tag = "3")]
    pub is_gadget_created: bool,
    #[prost(uint32, tag = "4")]
    pub last_take_reward_time: u32,
    #[prost(uint32, tag = "5")]
    pub miracle_ring_cd: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiracleRingTakeRewardReq {
    #[prost(uint32, tag = "1")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiracleRingTakeRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5206)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiracleRingDropResultNotify {
    #[prost(uint32, tag = "1")]
    pub last_take_reward_time: u32,
    #[prost(int32, tag = "2")]
    pub drop_result: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5207)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiracleRingDeliverItemReq {
    #[prost(message, repeated, tag = "1")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint64, repeated, tag = "2")]
    pub food_weapon_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "3")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub gadget_id: u32,
    #[prost(enumeration = "InterOpType", tag = "5")]
    pub op_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiracleRingDeliverItemRsp {
    #[prost(enumeration = "InteractType", tag = "1")]
    pub interact_type: i32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "InterOpType", tag = "3")]
    pub op_type: i32,
    #[prost(uint32, tag = "4")]
    pub gadget_entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiracleRingDestroyNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeepAliveNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmTalkReq {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmTalkRsp {
    #[prost(string, tag = "1")]
    pub retmsg: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub msg: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgParam {
    #[prost(oneof = "msg_param::Param", tags = "1, 2, 3")]
    pub param: ::core::option::Option<msg_param::Param>,
}
/// Nested message and enum types in `MsgParam`.
pub mod msg_param {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(uint32, tag = "1")]
        IntParam(u32),
        #[prost(float, tag = "2")]
        FltParam(f32),
        #[prost(string, tag = "3")]
        StrParam(::prost::alloc::string::String),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowMessageNotify {
    #[prost(message, repeated, tag = "1")]
    pub params: ::prost::alloc::vec::Vec<MsgParam>,
    #[prost(enumeration = "SvrMsgId", tag = "2")]
    pub msg_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingReq {
    #[prost(bytes = "vec", tag = "1")]
    pub sc_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub seq: u32,
    #[prost(double, tag = "3")]
    pub total_tick_time: f64,
    #[prost(uint32, tag = "4")]
    pub client_time: u32,
    #[prost(float, tag = "5")]
    pub ue_time: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PingRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub client_time: u32,
    #[prost(uint32, tag = "3")]
    pub seq: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(7)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnlinePlayerListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(8)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOnlinePlayerListRsp {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub param: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerTimeNotify {
    #[prost(uint64, tag = "1")]
    pub server_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(10)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerLogNotify {
    #[prost(string, tag = "1")]
    pub server_log: ::prost::alloc::string::String,
    #[prost(enumeration = "ServerLogLevel", tag = "2")]
    pub log_level: i32,
    #[prost(enumeration = "ServerLogType", tag = "3")]
    pub log_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(11)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientReconnectNotify {
    #[prost(enumeration = "ClientReconnectReason", tag = "1")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(12)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RobotPushPlayerDataNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub bin: ::prost::alloc::vec::Vec<u8>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(13)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientReportNotify {
    #[prost(string, tag = "1")]
    pub report_value: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub report_type: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionCmd {
    #[prost(bytes = "vec", tag = "1")]
    pub body: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub message_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(14)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionCmdNotify {
    #[prost(message, repeated, tag = "1")]
    pub cmd_list: ::prost::alloc::vec::Vec<UnionCmd>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(15)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOnlinePlayerInfoReq {
    #[prost(bool, tag = "1")]
    pub is_online_id: bool,
    #[prost(oneof = "get_online_player_info_req::PlayerId", tags = "2, 3, 4")]
    pub player_id: ::core::option::Option<get_online_player_info_req::PlayerId>,
}
/// Nested message and enum types in `GetOnlinePlayerInfoReq`.
pub mod get_online_player_info_req {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PlayerId {
        #[prost(uint32, tag = "2")]
        TargetUid(u32),
        #[prost(string, tag = "3")]
        OnlineId(::prost::alloc::string::String),
        #[prost(string, tag = "4")]
        PsnId(::prost::alloc::string::String),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(16)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOnlinePlayerInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub target_player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub param: u32,
    #[prost(uint32, tag = "3")]
    pub target_uid: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SegmentInfo {
    #[prost(uint32, tag = "1")]
    pub offset: u32,
    #[prost(uint32, tag = "2")]
    pub module: u32,
    #[prost(uint32, tag = "3")]
    pub size: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentCrcInfo {
    #[prost(string, tag = "1")]
    pub crc: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub size: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub module: u32,
    #[prost(uint32, tag = "5")]
    pub offset: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(17)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckSegmentCrcNotify {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<SegmentInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(18)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckSegmentCrcReq {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<SegmentCrcInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerRttInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub rtt: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(19)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldPlayerRttNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_rtt_list: ::prost::alloc::vec::Vec<PlayerRttInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(20)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EchoNotify {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub seq_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(21)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRedPointNotify {
    #[prost(message, repeated, tag = "1")]
    pub red_point_list: ::prost::alloc::vec::Vec<RedPointData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(22)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientBulletCreateNotify {
    #[prost(uint32, tag = "1")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(23)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeServerGlobalValueNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(24)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmTalkNotify {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(25)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LastPacketPrintNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterSummonTagNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub summon_tag_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub monster_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1801)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpNotify {
    #[prost(message, optional, tag = "1")]
    pub src_player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub src_app_id: u32,
    #[prost(uint32, tag = "3")]
    pub src_thread_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1802)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpRsp {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(uint32, tag = "2")]
    pub param: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1804)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpResultNotify {
    #[prost(string, tag = "1")]
    pub target_nickname: ::prost::alloc::string::String,
    #[prost(enumeration = "PlayerApplyEnterMpResultNotifyReason", tag = "2")]
    pub reason: i32,
    #[prost(bool, tag = "3")]
    pub is_agreed: bool,
    #[prost(uint32, tag = "4")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpResultReq {
    #[prost(uint32, tag = "1")]
    pub apply_uid: u32,
    #[prost(bool, tag = "2")]
    pub is_agreed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1806)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerApplyEnterMpResultRsp {
    #[prost(uint32, tag = "1")]
    pub apply_uid: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_agreed: bool,
    #[prost(uint32, tag = "4")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1807)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerQuitFromMpNotify {
    #[prost(enumeration = "PlayerQuitFromMpNotifyQuitReason", tag = "1")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1808)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerPreEnterMpNotify {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(enumeration = "PlayerPreEnterMpNotifyState", tag = "2")]
    pub state: i32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1809)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPlayerMpModeAvailabilityReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1810)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerMpModeAvailabilityRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub mp_ret: i32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1811)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSetOnlyMpWithPsPlayerReq {
    #[prost(bool, tag = "1")]
    pub is_only: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1812)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSetOnlyMpWithPsPlayerRsp {
    #[prost(bool, tag = "1")]
    pub is_only: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1813)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PsPlayerApplyEnterMpReq {
    #[prost(string, tag = "1")]
    pub target_psn_id: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1814)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PsPlayerApplyEnterMpRsp {
    #[prost(string, tag = "1")]
    pub target_psn_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1815)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayOwnerCheckReq {
    #[prost(uint32, tag = "1")]
    pub mp_play_id: u32,
    #[prost(bool, tag = "2")]
    pub is_skip_match: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1816)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayOwnerCheckRsp {
    #[prost(bool, tag = "1")]
    pub is_skip_match: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub wrong_uid: u32,
    #[prost(uint32, tag = "4")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1817)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayOwnerStartInviteReq {
    #[prost(uint32, tag = "1")]
    pub mp_play_id: u32,
    #[prost(bool, tag = "2")]
    pub is_skip_match: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1818)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayOwnerStartInviteRsp {
    #[prost(uint32, tag = "1")]
    pub mp_play_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(bool, tag = "3")]
    pub is_skip_match: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1819)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayOwnerInviteNotify {
    #[prost(uint32, tag = "1")]
    pub cd: u32,
    #[prost(bool, tag = "2")]
    pub is_remain_reward: bool,
    #[prost(uint32, tag = "3")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1820)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayGuestReplyInviteReq {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1821)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayGuestReplyInviteRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1822)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayGuestReplyNotify {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1823)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayPrepareNotify {
    #[prost(uint32, tag = "1")]
    pub prepare_end_time: u32,
    #[prost(uint32, tag = "2")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1824)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayInviteResultNotify {
    #[prost(bool, tag = "1")]
    pub all_agree: bool,
    #[prost(uint32, tag = "2")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1825)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpPlayPrepareInterruptNotify {
    #[prost(uint32, tag = "1")]
    pub mp_play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1826)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MpBlockNotify {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusBuildingInfo {
    #[prost(uint32, tag = "1")]
    pub refund_points: u32,
    #[prost(uint32, tag = "2")]
    pub cost_points: u32,
    #[prost(uint32, tag = "3")]
    pub building_id: u32,
    #[prost(uint32, tag = "4")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusPlayerInfo {
    #[prost(message, repeated, tag = "1")]
    pub building_list: ::prost::alloc::vec::Vec<InBattleMechanicusBuildingInfo>,
    #[prost(uint32, tag = "2")]
    pub building_points: u32,
    #[prost(uint32, tag = "3")]
    pub pick_card_id: u32,
    #[prost(bool, tag = "4")]
    pub is_card_confirmed: bool,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusMonsterInfo {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub monster_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusCardInfo {
    #[prost(uint32, tag = "1")]
    pub rand_effect_id: u32,
    #[prost(enumeration = "InBattleMechanicusCardChallengeState", tag = "2")]
    pub challenge_state: i32,
    #[prost(uint32, tag = "3")]
    pub begin_round: u32,
    #[prost(uint32, tag = "4")]
    pub cost_points: u32,
    #[prost(uint32, tag = "5")]
    pub card_id: u32,
    #[prost(uint32, tag = "6")]
    pub end_round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusInfo {
    #[prost(message, repeated, tag = "1")]
    pub pick_card_list: ::prost::alloc::vec::Vec<InBattleMechanicusCardInfo>,
    #[prost(message, repeated, tag = "2")]
    pub history_card_list: ::prost::alloc::vec::Vec<InBattleMechanicusCardInfo>,
    #[prost(message, repeated, tag = "3")]
    pub player_list: ::prost::alloc::vec::Vec<InBattleMechanicusPlayerInfo>,
    #[prost(uint32, repeated, tag = "4")]
    pub exit_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub entrance_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "6")]
    pub monster_list: ::prost::alloc::vec::Vec<InBattleMechanicusMonsterInfo>,
    #[prost(uint32, tag = "7")]
    pub building_stage_duration: u32,
    #[prost(enumeration = "InBattleMechanicusStageType", tag = "8")]
    pub stage: i32,
    #[prost(uint32, tag = "9")]
    pub total_round: u32,
    #[prost(uint32, tag = "10")]
    pub max_escape_monster_num: u32,
    #[prost(uint64, tag = "11")]
    pub wait_begin_time_us: u64,
    #[prost(uint64, tag = "12")]
    pub begin_time_ms: u64,
    #[prost(uint64, tag = "13")]
    pub duration_ms: u64,
    #[prost(uint32, tag = "14")]
    pub wait_seconds: u32,
    #[prost(uint32, tag = "15")]
    pub left_monster_num: u32,
    #[prost(uint32, tag = "16")]
    pub round: u32,
    #[prost(uint32, tag = "17")]
    pub escaped_monster_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleFleurFairInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub ability_group_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub gallery_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub preview_stage_index: u32,
    #[prost(uint32, tag = "4")]
    pub gallery_stage_index: u32,
    #[prost(uint32, tag = "5")]
    pub preview_display_duration: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharAmusementAvatarInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub punish_time: u32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharAmusementInfo {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<CharAmusementAvatarInfo>,
    #[prost(uint32, tag = "2")]
    pub preview_stage_index: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
    #[prost(uint32, tag = "4")]
    pub stage_id: u32,
    #[prost(uint32, tag = "5")]
    pub total_cost_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub battle_info_list: ::prost::alloc::vec::Vec<BrickBreakerPlayerBattleInfo>,
    #[prost(enumeration = "BrickBreakerStageType", tag = "2")]
    pub stage_type: i32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCollectStageInfo {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<CoinCollectPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub play_index: u32,
    #[prost(uint32, tag = "3")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanV3BoatStageInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub player_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_single: bool,
    #[prost(uint32, tag = "3")]
    pub match_id: u32,
    #[prost(uint32, tag = "4")]
    pub map_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PacmanStageInfo {
    #[prost(bool, tag = "1")]
    pub is_from_match: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultistagePlayInfo {
    #[prost(uint32, tag = "1")]
    pub stage_index: u32,
    #[prost(uint32, tag = "2")]
    pub duration: u32,
    #[prost(uint32, tag = "3")]
    pub begin_time: u32,
    #[prost(uint32, tag = "4")]
    pub stage_type: u32,
    #[prost(uint32, tag = "5")]
    pub play_type: u32,
    #[prost(uint32, tag = "6")]
    pub group_id: u32,
    #[prost(uint32, tag = "7")]
    pub play_index: u32,
    #[prost(
        oneof = "multistage_play_info::Detail",
        tags = "8, 9, 10, 11, 12, 13, 14, 15, 16, 17"
    )]
    pub detail: ::core::option::Option<multistage_play_info::Detail>,
}
/// Nested message and enum types in `MultistagePlayInfo`.
pub mod multistage_play_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "8")]
        MechanicusInfo(super::InBattleMechanicusInfo),
        #[prost(message, tag = "9")]
        FleurFairInfo(super::InBattleFleurFairInfo),
        #[prost(message, tag = "10")]
        HideAndSeekInfo(super::HideAndSeekStageInfo),
        #[prost(message, tag = "11")]
        ChessInfo(super::InBattleChessInfo),
        #[prost(message, tag = "12")]
        IrodoriChessInfo(super::InBattleIrodoriChessInfo),
        #[prost(message, tag = "13")]
        CharAmusementInfo(super::CharAmusementInfo),
        #[prost(message, tag = "14")]
        BrickBreakerInfo(super::BrickBreakerStageInfo),
        #[prost(message, tag = "15")]
        CoinCollectInfo(super::CoinCollectStageInfo),
        #[prost(message, tag = "16")]
        LanV3BoatInfo(super::LanV3BoatStageInfo),
        #[prost(message, tag = "17")]
        FleurFairV2PacmanInfo(super::FleurFairV2PacmanStageInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultistagePlayInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<MultistagePlayInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5302)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultistagePlayFinishStageReq {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub play_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5303)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusEscapeMonsterNotify {
    #[prost(uint32, tag = "1")]
    pub escaped_monster_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusLeftMonsterNotify {
    #[prost(uint32, tag = "1")]
    pub left_monster_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5305)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusBuildingPointsNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub player_building_points_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusPickCardReq {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(uint32, tag = "3")]
    pub play_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusPickCardRsp {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub play_index: u32,
    #[prost(uint32, tag = "4")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5308)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusPickCardNotify {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(uint32, tag = "3")]
    pub play_index: u32,
    #[prost(uint32, tag = "4")]
    pub player_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5309)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusConfirmCardReq {
    #[prost(uint32, tag = "1")]
    pub play_index: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusConfirmCardRsp {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub play_index: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusConfirmCardNotify {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub player_uid: u32,
    #[prost(uint32, tag = "3")]
    pub play_index: u32,
    #[prost(uint32, tag = "4")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5312)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusCardResultNotify {
    #[prost(message, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<InBattleMechanicusCardInfo>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub player_confirmed_card_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint64, tag = "3")]
    pub wait_begin_time_us: u64,
    #[prost(uint32, tag = "4")]
    pub play_index: u32,
    #[prost(uint32, tag = "5")]
    pub group_id: u32,
    #[prost(uint32, tag = "6")]
    pub wait_seconds: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5313)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultistagePlayFinishStageRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub play_index: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultistageSettleWatcherInfo {
    #[prost(bool, tag = "1")]
    pub is_inverse: bool,
    #[prost(uint32, tag = "2")]
    pub watcher_id: u32,
    #[prost(uint32, tag = "3")]
    pub cur_progress: u32,
    #[prost(uint32, tag = "4")]
    pub total_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5314)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusSettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub watcher_list: ::prost::alloc::vec::Vec<MultistageSettleWatcherInfo>,
    #[prost(uint64, tag = "2")]
    pub scene_time_ms: u64,
    #[prost(uint32, tag = "3")]
    pub difficulty_percentage: u32,
    #[prost(uint32, tag = "4")]
    pub total_token: u32,
    #[prost(uint32, tag = "5")]
    pub play_index: u32,
    #[prost(bool, tag = "6")]
    pub is_success: bool,
    #[prost(uint32, tag = "7")]
    pub real_token: u32,
    #[prost(uint32, tag = "8")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleMechanicusSettleInfo {
    #[prost(message, repeated, tag = "1")]
    pub watcher_list: ::prost::alloc::vec::Vec<MultistageSettleWatcherInfo>,
    #[prost(uint32, tag = "2")]
    pub difficulty_percentage: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub real_token: u32,
    #[prost(bool, tag = "5")]
    pub is_success: bool,
    #[prost(uint64, tag = "6")]
    pub scene_time_ms: u64,
    #[prost(uint32, tag = "7")]
    pub play_index: u32,
    #[prost(uint32, tag = "8")]
    pub total_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5315)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultistagePlaySettleNotify {
    #[prost(uint32, tag = "1")]
    pub play_index: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(oneof = "multistage_play_settle_notify::Detail", tags = "3, 4, 5")]
    pub detail: ::core::option::Option<multistage_play_settle_notify::Detail>,
}
/// Nested message and enum types in `MultistagePlaySettleNotify`.
pub mod multistage_play_settle_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "3")]
        MechanicusSettleInfo(super::InBattleMechanicusSettleInfo),
        #[prost(message, tag = "4")]
        ChessSettleInfo(super::InBattleChessSettleInfo),
        #[prost(message, tag = "5")]
        IrodoriChessSettleInfo(super::InBattleIrodoriChessSettleInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5316)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultistagePlayStageEndNotify {
    #[prost(uint32, tag = "1")]
    pub play_index: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5317)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultistagePlayEndNotify {
    #[prost(uint32, tag = "1")]
    pub play_index: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5318)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairBuffEnergyNotify {
    #[prost(uint32, tag = "1")]
    pub energy: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairGallerySettleInfo {
    #[prost(map = "uint32, int32", tag = "1")]
    pub energy_stat_map: ::std::collections::HashMap<u32, i32>,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(uint32, tag = "3")]
    pub gallery_stage_index: u32,
    #[prost(uint32, tag = "4")]
    pub gallery_stage_count: u32,
    #[prost(uint32, tag = "5")]
    pub energy: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairPlayerStatInfo {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub stat_id: u32,
    #[prost(int32, tag = "5")]
    pub param: i32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
    #[prost(uint32, tag = "7")]
    pub head_image: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairBossSettleInfo {
    #[prost(message, repeated, tag = "1")]
    pub stat_info_list: ::prost::alloc::vec::Vec<FleurFairPlayerStatInfo>,
    #[prost(uint32, tag = "2")]
    pub energy: u32,
    #[prost(uint32, tag = "3")]
    pub reward_token_num: u32,
    #[prost(uint32, tag = "4")]
    pub cost_time: u32,
    #[prost(bool, tag = "5")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5319)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleurFairStageSettleNotify {
    #[prost(uint32, tag = "1")]
    pub stage_type: u32,
    #[prost(oneof = "fleur_fair_stage_settle_notify::Detail", tags = "2, 3")]
    pub detail: ::core::option::Option<fleur_fair_stage_settle_notify::Detail>,
}
/// Nested message and enum types in `FleurFairStageSettleNotify`.
pub mod fleur_fair_stage_settle_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "2")]
        GallerySettleInfo(super::FleurFairGallerySettleInfo),
        #[prost(message, tag = "3")]
        BossSettleInfo(super::FleurFairBossSettleInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5320)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairFinishGalleryStageNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekPlayerBattleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(bool, tag = "3")]
    pub is_ready: bool,
    #[prost(uint32, tag = "4")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekStageInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub battle_info_map: ::std::collections::HashMap<u32, HideAndSeekPlayerBattleInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub hider_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_record_score: bool,
    #[prost(uint32, tag = "4")]
    pub hunter_uid: u32,
    #[prost(uint32, tag = "5")]
    pub map_id: u32,
    #[prost(enumeration = "HideAndSeekStageType", tag = "6")]
    pub stage_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5321)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HideAndSeekSelectAvatarReq {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5322)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HideAndSeekSelectAvatarRsp {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5323)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HideAndSeekSetReadyReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5324)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HideAndSeekSetReadyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekSettleInfo {
    #[prost(string, tag = "1")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub card_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(message, optional, tag = "3")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "4")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub head_image: u32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5325)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekSettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub winner_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub settle_info_list: ::prost::alloc::vec::Vec<HideAndSeekSettleInfo>,
    #[prost(uint32, tag = "4")]
    pub cost_time: u32,
    #[prost(bool, tag = "5")]
    pub is_record_score: bool,
    #[prost(enumeration = "HideAndSeekSettleNotifySettleReason", tag = "6")]
    pub reason: i32,
    #[prost(uint32, tag = "7")]
    pub play_index: u32,
    #[prost(uint32, tag = "8")]
    pub stage_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5326)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HideAndSeekPlayerReadyNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5327)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HideAndSeekPlayerSetAvatarNotify {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessCardInfo {
    #[prost(uint32, tag = "1")]
    pub card_id: u32,
    #[prost(uint32, tag = "2")]
    pub effect_stack: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleChessInfo {
    #[prost(message, optional, tag = "1")]
    pub mystery_info: ::core::option::Option<ChessMysteryInfo>,
    #[prost(map = "uint32, message", tag = "2")]
    pub player_info_map: ::std::collections::HashMap<u32, ChessPlayerInfo>,
    #[prost(message, repeated, tag = "3")]
    pub selected_card_info_list: ::prost::alloc::vec::Vec<ChessCardInfo>,
    #[prost(uint32, repeated, tag = "4")]
    pub ban_card_tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub escaped_monsters: u32,
    #[prost(uint32, tag = "6")]
    pub total_round: u32,
    #[prost(uint32, tag = "7")]
    pub max_escapable_monsters: u32,
    #[prost(uint32, tag = "8")]
    pub left_monsters: u32,
    #[prost(uint32, tag = "9")]
    pub round: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleChessSettleInfo {
    #[prost(message, repeated, tag = "1")]
    pub score_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(uint32, tag = "2")]
    pub chess_level: u32,
    #[prost(uint64, tag = "3")]
    pub scene_time_ms: u64,
    #[prost(uint32, tag = "4")]
    pub chess_exp: u32,
    #[prost(uint32, tag = "5")]
    pub old_chess_exp: u32,
    #[prost(uint32, tag = "6")]
    pub old_chess_level: u32,
    #[prost(bool, tag = "7")]
    pub is_success: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessPlayerInfo {
    #[prost(message, repeated, tag = "1")]
    pub candidate_card_info_list: ::prost::alloc::vec::Vec<ChessNormalCardInfo>,
    #[prost(uint32, tag = "2")]
    pub refresh_cost: u32,
    #[prost(uint32, tag = "3")]
    pub candidate_index: u32,
    #[prost(uint32, tag = "4")]
    pub free_refresh_limit: u32,
    #[prost(uint32, tag = "5")]
    pub building_points: u32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
    #[prost(uint32, tag = "7")]
    pub free_refresh_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessMonsterInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub monster_id: u32,
    #[prost(uint32, tag = "3")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessEntranceInfo {
    #[prost(message, repeated, tag = "1")]
    pub monster_info_list: ::prost::alloc::vec::Vec<ChessMonsterInfo>,
    #[prost(uint32, tag = "2")]
    pub entrance_point_id: u32,
    #[prost(uint32, tag = "3")]
    pub entrance_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessEntranceDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<ChessEntranceInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessMysteryInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub detail_info_map: ::std::collections::HashMap<u32, ChessEntranceDetailInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub exit_point_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub entrance_point_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessNormalCardInfo {
    #[prost(uint32, tag = "1")]
    pub cost_points: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
    #[prost(bool, tag = "3")]
    pub is_attach_curse: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5328)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessPickCardReq {
    #[prost(uint32, tag = "1")]
    pub card_index: u32,
    #[prost(uint32, tag = "2")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5329)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessPickCardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub card_index: u32,
    #[prost(uint32, tag = "3")]
    pub card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5330)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessPickCardNotify {
    #[prost(message, optional, tag = "1")]
    pub normal_card_info: ::core::option::Option<ChessNormalCardInfo>,
    #[prost(uint32, tag = "2")]
    pub curse_card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5331)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessManualRefreshCardsReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5332)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessManualRefreshCardsRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5333)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessPlayerInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<ChessPlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5334)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessLeftMonstersNotify {
    #[prost(uint32, tag = "1")]
    pub left_monsters: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5335)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChessEscapedMonstersNotify {
    #[prost(uint32, tag = "1")]
    pub escaped_monsters: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5336)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChessSelectedCardsNotify {
    #[prost(message, repeated, tag = "1")]
    pub selected_card_info_list: ::prost::alloc::vec::Vec<ChessCardInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5337)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalBuildingInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub building_list: ::prost::alloc::vec::Vec<BuildingInfo>,
    #[prost(uint32, tag = "2")]
    pub current_num: u32,
    #[prost(uint32, tag = "3")]
    pub max_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InBattleIrodoriChessInfo {
    #[prost(message, optional, tag = "1")]
    pub mystery_info: ::core::option::Option<IrodoriChessMysteryInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub selected_card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub left_monsters: u32,
    #[prost(uint32, tag = "4")]
    pub settle_score: u32,
    #[prost(uint32, tag = "5")]
    pub building_points: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessMonsterInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub grant_points: u32,
    #[prost(uint32, tag = "3")]
    pub level: u32,
    #[prost(uint32, tag = "4")]
    pub monster_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessEntranceInfo {
    #[prost(message, repeated, tag = "1")]
    pub monster_info_list: ::prost::alloc::vec::Vec<IrodoriChessMonsterInfo>,
    #[prost(uint32, tag = "2")]
    pub entrance_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessEntranceDetailInfo {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<IrodoriChessEntranceInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IrodoriChessMysteryInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub entrance_point_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub exit_point_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "3")]
    pub entrance_detail_info: ::core::option::Option<IrodoriChessEntranceDetailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InBattleIrodoriChessSettleInfo {
    #[prost(uint32, tag = "1")]
    pub settle_score: u32,
    #[prost(bool, tag = "2")]
    pub is_activity_end: bool,
    #[prost(bool, tag = "3")]
    pub is_new_record: bool,
    #[prost(bool, tag = "4")]
    pub is_perfect: bool,
    #[prost(uint64, tag = "5")]
    pub scene_time_ms: u64,
    #[prost(uint32, tag = "6")]
    pub kill_monster_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessPlayerInfo {
    #[prost(uint32, tag = "1")]
    pub building_points: u32,
    #[prost(uint32, tag = "2")]
    pub settle_score: u32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5338)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessPlayerInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub player_info: ::core::option::Option<IrodoriChessPlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5339)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IrodoriChessLeftMonsterNotify {
    #[prost(uint32, tag = "1")]
    pub left_monsters: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerPlayerBattleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "3")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "4")]
    pub costume_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
    #[prost(bool, tag = "6")]
    pub is_changing: bool,
    #[prost(bool, tag = "7")]
    pub is_ready: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5340)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerPlayerReadyNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5341)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerPlayerSetAvatarNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub costume_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5342)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerPlayerSetSkillNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5343)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerSetReadyReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5344)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerSetReadyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5345)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerSelectAvatarReq {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5346)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerSelectAvatarRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub avatar_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5347)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerSelectSkillReq {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5348)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrickBreakerSelectSkillRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5349)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerSetChangingReq {
    #[prost(bool, tag = "1")]
    pub is_changing: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5350)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerSetChangingRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5351)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrickBreakerPlayerSetChangingNotify {
    #[prost(bool, tag = "1")]
    pub is_changing: bool,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectTeamAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub costume_id: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCollectPlayerInfo {
    #[prost(string, tag = "1")]
    pub player_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<CoinCollectTeamAvatarInfo>,
    #[prost(bool, tag = "3")]
    pub is_prepare: bool,
    #[prost(uint32, tag = "4")]
    pub player_uid: u32,
    #[prost(uint32, tag = "5")]
    pub choose_skill_no: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCollectPrepareStageNotify {
    #[prost(message, optional, tag = "1")]
    pub coin_collect_info: ::core::option::Option<CoinCollectStageInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanV3BoatSettleInfo {
    #[prost(message, repeated, tag = "1")]
    pub card_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(uint32, tag = "5")]
    pub head_image: u32,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6501)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanV3BoatSettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub settle_info_list: ::prost::alloc::vec::Vec<LanV3BoatSettleInfo>,
    #[prost(message, repeated, tag = "2")]
    pub score_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(uint32, repeated, tag = "3")]
    pub winner_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub play_index: u32,
    #[prost(uint32, tag = "5")]
    pub begin_time: u32,
    #[prost(bool, tag = "6")]
    pub is_single: bool,
    #[prost(bool, tag = "7")]
    pub is_gallery_succ: bool,
    #[prost(uint32, tag = "8")]
    pub stage_type: u32,
    #[prost(uint32, tag = "9")]
    pub duration: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanV3BoatPlayerPrepareNotify {
    #[prost(uint32, tag = "1")]
    pub play_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FleurFairV2PacmanPrepareNotify {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(501)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NpcTalkReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub talk_id: u32,
    #[prost(uint32, tag = "3")]
    pub npc_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NpcTalkRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub cur_talk_id: u32,
    #[prost(uint32, tag = "4")]
    pub npc_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(503)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSceneNpcPositionReq {
    #[prost(uint32, repeated, tag = "1")]
    pub npc_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(504)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSceneNpcPositionRsp {
    #[prost(message, repeated, tag = "1")]
    pub npc_info_list: ::prost::alloc::vec::Vec<NpcPositionInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(505)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetNpcIdListNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub npc_first_met_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(506)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MeetNpcReq {
    #[prost(uint32, tag = "1")]
    pub npc_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MeetNpcRsp {
    #[prost(uint32, tag = "1")]
    pub npc_first_met_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(508)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinishedTalkIdListNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub finished_talk_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerOfferingData {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub taken_random_level_reward_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub taken_level_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub offering_id: u32,
    #[prost(bool, tag = "4")]
    pub is_new_max_level: bool,
    #[prost(bool, tag = "5")]
    pub is_first_interact: bool,
    #[prost(uint32, tag = "6")]
    pub level: u32,
    #[prost(oneof = "player_offering_data::Detail", tags = "7")]
    pub detail: ::core::option::Option<player_offering_data::Detail>,
}
/// Nested message and enum types in `PlayerOfferingData`.
pub mod player_offering_data {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "7")]
        OfferingPariDetailData(super::OfferingPariDetailData),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingPariDetailData {
    #[prost(bool, tag = "1")]
    pub is_taken_finish_reward: bool,
    #[prost(uint32, tag = "2")]
    pub jdccojleibp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2901)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerOfferingDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub offering_data_list: ::prost::alloc::vec::Vec<PlayerOfferingData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerOfferingReq {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2903)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerOfferingRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, optional, tag = "2")]
    pub offering_data: ::core::option::Option<PlayerOfferingData>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeOfferingLevelRewardReq {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2905)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeOfferingLevelRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub take_level: u32,
    #[prost(uint32, tag = "4")]
    pub offering_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2906)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingInteractReq {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2907)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfferingInteractRsp {
    #[prost(message, optional, tag = "1")]
    pub offering_data: ::core::option::Option<PlayerOfferingData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2908)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingPariSearchReq {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2909)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingPariSearchRsp {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2910)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingPariSearchResultNotify {
    #[prost(message, optional, tag = "1")]
    pub hint_center_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub offering_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub config_id: u32,
    #[prost(uint32, tag = "5")]
    pub hint_radius: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2911)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingPariSearchFinishNotify {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2912)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingPariTakeFinishRewardReq {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2913)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfferingPariTakeFinishRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub offering_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpActivityInfo {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
    #[prost(uint32, tag = "2")]
    pub begin_time: u32,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
    #[prost(uint32, tag = "4")]
    pub activity_id: u32,
    #[prost(bool, tag = "5")]
    pub is_has_change: bool,
    #[prost(oneof = "op_activity_info::Detail", tags = "6")]
    pub detail: ::core::option::Option<op_activity_info::Detail>,
}
/// Nested message and enum types in `OpActivityInfo`.
pub mod op_activity_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "6")]
        BonusInfo(super::BonusOpActivityInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BonusOpActivityInfo {
    #[prost(uint32, tag = "1")]
    pub left_bonus_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOpActivityInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOpActivityInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub op_activity_info_list: ::prost::alloc::vec::Vec<OpActivityInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5103)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpActivityDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub op_activity_info_list: ::prost::alloc::vec::Vec<OpActivityInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpActivityUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub op_activity_info: ::core::option::Option<OpActivityInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryFilter {
    #[prost(int32, tag = "1")]
    pub area_mask: i32,
    #[prost(int32, tag = "2")]
    pub type_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPathReq {
    #[prost(message, optional, tag = "1")]
    pub source_pos: ::core::option::Option<Vector>,
    #[prost(message, repeated, tag = "2")]
    pub destination_pos: ::prost::alloc::vec::Vec<Vector>,
    #[prost(message, optional, tag = "3")]
    pub filter: ::core::option::Option<QueryFilter>,
    #[prost(message, optional, tag = "4")]
    pub destination_extend: ::core::option::Option<Vector3Int>,
    #[prost(message, optional, tag = "5")]
    pub source_extend: ::core::option::Option<Vector3Int>,
    #[prost(enumeration = "QueryPathReqOptionType", tag = "6")]
    pub query_type: i32,
    #[prost(int32, tag = "7")]
    pub query_id: i32,
    #[prost(uint32, tag = "8")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2302)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPathRsp {
    #[prost(message, repeated, tag = "1")]
    pub corners: ::prost::alloc::vec::Vec<Vector>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "QueryPathRspPathStatusType", tag = "3")]
    pub query_status: i32,
    #[prost(int32, tag = "4")]
    pub query_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ObstacleInfo {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rotation: ::core::option::Option<MathQuaternion>,
    #[prost(message, optional, tag = "3")]
    pub extents: ::core::option::Option<Vector3Int>,
    #[prost(int32, tag = "4")]
    pub obstacle_id: i32,
    #[prost(enumeration = "ObstacleInfoShapeType", tag = "5")]
    pub shape: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2303)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObstacleModifyNotify {
    #[prost(message, repeated, tag = "1")]
    pub add_obstacles: ::prost::alloc::vec::Vec<ObstacleInfo>,
    #[prost(int32, repeated, tag = "2")]
    pub remove_obstacle_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PathfindingPingNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2305)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathfindingEnterSceneReq {
    #[prost(message, repeated, tag = "1")]
    pub obstacles: ::prost::alloc::vec::Vec<ObstacleInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub polygon_id: u32,
    #[prost(uint32, tag = "4")]
    pub version: u32,
    #[prost(bool, tag = "5")]
    pub is_editor: bool,
    #[prost(uint32, tag = "6")]
    pub scene_tag_hash: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PathfindingEnterSceneRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GmShowObstacleReq {
    #[prost(int32, tag = "1")]
    pub uid: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GmObstacleInfo {
    #[prost(message, optional, tag = "1")]
    pub rotation: ::core::option::Option<MathQuaternion>,
    #[prost(message, optional, tag = "2")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub extents: ::core::option::Option<Vector3Int>,
    #[prost(int32, tag = "4")]
    pub obstacle_id: i32,
    #[prost(enumeration = "ObstacleInfoShapeType", tag = "5")]
    pub shape: i32,
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2308)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmShowObstacleRsp {
    #[prost(message, repeated, tag = "1")]
    pub obstacles: ::prost::alloc::vec::Vec<GmObstacleInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2309)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GmShowNavMeshReq {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub extent: ::core::option::Option<Vector>,
    #[prost(int32, tag = "3")]
    pub uid: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PbNavMeshPoly {
    #[prost(enumeration = "EdgeType", repeated, tag = "1")]
    pub edge_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "2")]
    pub vects: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, tag = "3")]
    pub area: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PbNavMeshTile {
    #[prost(message, repeated, tag = "1")]
    pub vecs: ::prost::alloc::vec::Vec<Vector>,
    #[prost(message, repeated, tag = "2")]
    pub polys: ::prost::alloc::vec::Vec<PbNavMeshPoly>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2310)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmShowNavMeshRsp {
    #[prost(message, repeated, tag = "1")]
    pub tiles: ::prost::alloc::vec::Vec<PbNavMeshTile>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbNavMeshStatsInfo {
    #[prost(int32, tag = "1")]
    pub authority_ai_in_combat: i32,
    #[prost(int32, tag = "2")]
    pub total_no_authority_ai: i32,
    #[prost(int32, tag = "3")]
    pub total_authority_ai: i32,
    #[prost(int32, tag = "4")]
    pub no_authority_ai_in_combat: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2311)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NavMeshStatsNotify {
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<PbNavMeshStatsInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmPathPolygon {
    #[prost(message, repeated, tag = "1")]
    pub points: ::prost::alloc::vec::Vec<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2312)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GmQueryPathReq {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<QueryFilter>,
    #[prost(message, optional, tag = "2")]
    pub source_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub source_extend: ::core::option::Option<Vector3Int>,
    #[prost(message, optional, tag = "4")]
    pub destination_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "5")]
    pub destination_extend: ::core::option::Option<Vector3Int>,
    #[prost(int32, tag = "6")]
    pub uid: i32,
    #[prost(int32, tag = "7")]
    pub query_id: i32,
    #[prost(uint32, tag = "8")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2313)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GmQueryPathRsp {
    #[prost(message, repeated, tag = "1")]
    pub iceffkbdgji: ::prost::alloc::vec::Vec<Vector>,
    #[prost(message, repeated, tag = "2")]
    pub result_polys: ::prost::alloc::vec::Vec<GmPathPolygon>,
    #[prost(message, repeated, tag = "3")]
    pub path_polys: ::prost::alloc::vec::Vec<GmPathPolygon>,
    #[prost(message, repeated, tag = "4")]
    pub corners: ::prost::alloc::vec::Vec<Vector>,
    #[prost(int32, tag = "5")]
    pub query_id: i32,
    #[prost(int32, tag = "6")]
    pub retcode: i32,
    #[prost(enumeration = "GmQueryPathRspPathStatusType", tag = "7")]
    pub query_status: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerTokenReq {
    #[prost(string, tag = "1")]
    pub ticket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_rand_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub psn_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub account_ext: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub account_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub account_token: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub client_ip_str: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub psn_region: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub birthday: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "12")]
    pub lang: u32,
    #[prost(uint32, tag = "13")]
    pub account_type: u32,
    #[prost(uint32, tag = "14")]
    pub uid: u32,
    #[prost(uint32, tag = "15")]
    pub platform_type: u32,
    #[prost(uint32, tag = "16")]
    pub key_id: u32,
    #[prost(uint32, tag = "17")]
    pub cloud_client_ip: u32,
    #[prost(bool, tag = "18")]
    pub is_guest: bool,
    #[prost(uint32, tag = "19")]
    pub channel_id: u32,
    #[prost(uint32, tag = "20")]
    pub sub_channel_id: u32,
    #[prost(uint32, tag = "21")]
    pub minors_reg_min_age: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerTokenRsp {
    #[prost(message, optional, tag = "1")]
    pub stop_server: ::core::option::Option<StopServerInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub security_cmd_buffer: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub client_version_random_key: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub client_ip_str: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub account_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub birthday: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub psn_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub msg: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "10")]
    pub extra_bin_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "11")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub secret_key: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub server_rand_key: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub sign: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "15")]
    pub finish_collection_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "16")]
    pub uid: u32,
    #[prost(uint32, tag = "17")]
    pub minors_reg_min_age: u32,
    #[prost(uint32, tag = "18")]
    pub reg_platform: u32,
    #[prost(int32, tag = "19")]
    pub retcode: i32,
    #[prost(uint32, tag = "20")]
    pub black_uid_end_time: u32,
    #[prost(uint64, tag = "21")]
    pub secret_key_seed: u64,
    #[prost(uint32, tag = "22")]
    pub channel_id: u32,
    #[prost(bool, tag = "23")]
    pub is_guest: bool,
    #[prost(bool, tag = "24")]
    pub is_proficient_player: bool,
    #[prost(bool, tag = "25")]
    pub is_login_white_list: bool,
    #[prost(bool, tag = "26")]
    pub is_watchdog_uid: bool,
    #[prost(uint32, tag = "27")]
    pub tag: u32,
    #[prost(uint32, tag = "28")]
    pub key_id: u32,
    #[prost(uint32, tag = "29")]
    pub sub_channel_id: u32,
    #[prost(uint32, tag = "30")]
    pub platform_type: u32,
    #[prost(uint32, tag = "31")]
    pub gm_uid: u32,
    #[prost(uint32, tag = "32")]
    pub account_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackingIoInfo {
    #[prost(string, tag = "1")]
    pub deviceid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_tz: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub appid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub current_caid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub cached_caid: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub rydevicetype: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub mac: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjustTrackingInfo {
    #[prost(string, tag = "1")]
    pub adid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub fire_adid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub gps_adid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub app_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub event_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub idfa: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(103)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLoginReq {
    #[prost(bytes = "vec", tag = "1")]
    pub environment_error_code: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub cps: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub checksum: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub ua_pc: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub platform: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "7")]
    pub extra_bin_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub security_cmd_reply: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "9")]
    pub client_version: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub device_info: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub birthday: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub security_library_version: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub client_version_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub psn_id: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub device_uuid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "18")]
    pub tracking_io_info: ::core::option::Option<TrackingIoInfo>,
    #[prost(string, tag = "19")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub account_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub security_library_md5: ::prost::alloc::string::String,
    #[prost(string, tag = "22")]
    pub checksum_client_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "23")]
    pub adjust_tracking_info: ::core::option::Option<AdjustTrackingInfo>,
    #[prost(string, tag = "24")]
    pub system_version: ::prost::alloc::string::String,
    #[prost(uint32, tag = "25")]
    pub channel_id: u32,
    #[prost(uint32, tag = "26")]
    pub gm_uid: u32,
    #[prost(uint32, tag = "27")]
    pub cloud_client_ip: u32,
    #[prost(uint32, tag = "28")]
    pub target_home_param: u32,
    #[prost(uint32, tag = "29")]
    pub client_port: u32,
    #[prost(uint32, tag = "30")]
    pub language_type: u32,
    #[prost(uint32, tag = "31")]
    pub target_home_owner_uid: u32,
    #[prost(uint32, tag = "32")]
    pub sub_channel_id: u32,
    #[prost(uint32, tag = "33")]
    pub account_type: u32,
    #[prost(uint32, tag = "34")]
    pub target_uid: u32,
    #[prost(uint32, tag = "35")]
    pub tag: u32,
    #[prost(uint32, tag = "36")]
    pub client_token: u32,
    #[prost(uint64, tag = "37")]
    pub login_rand: u64,
    #[prost(bool, tag = "38")]
    pub is_transfer: bool,
    #[prost(bool, tag = "39")]
    pub is_guest: bool,
    #[prost(bool, tag = "40")]
    pub is_editor: bool,
    #[prost(uint32, tag = "41")]
    pub platform_type: u32,
    #[prost(uint32, tag = "42")]
    pub client_data_version: u32,
    #[prost(uint32, tag = "43")]
    pub reg_platform: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShortAbilityHashPair {
    #[prost(sfixed32, tag = "1")]
    pub ability_config_hash: i32,
    #[prost(sfixed32, tag = "2")]
    pub ability_name_hash: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(104)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLoginRsp {
    #[prost(string, tag = "1")]
    pub client_silence_version_suffix: ::prost::alloc::string::String,
    #[prost(map = "string, int32", tag = "2")]
    pub ability_hash_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i32,
    >,
    #[prost(string, tag = "3")]
    pub next_resource_url: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub short_ability_hash_map: ::prost::alloc::vec::Vec<ShortAbilityHashPair>,
    #[prost(bytes = "vec", tag = "5")]
    pub sc_info: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "6")]
    pub client_md5: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub res_version_config: ::core::option::Option<ResVersionConfig>,
    #[prost(string, tag = "8")]
    pub register_cps: ::prost::alloc::string::String,
    #[prost(map = "uint32, message", tag = "9")]
    pub block_info_map: ::std::collections::HashMap<u32, BlockInfo>,
    #[prost(message, repeated, tag = "10")]
    pub feature_block_info_list: ::prost::alloc::vec::Vec<FeatureBlockInfo>,
    #[prost(string, tag = "11")]
    pub client_version_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub client_silence_md5: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub next_res_version_config: ::core::option::Option<ResVersionConfig>,
    #[prost(bytes = "vec", tag = "14")]
    pub player_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "15")]
    pub birthday: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub country_code: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub game_biz: ::prost::alloc::string::String,
    #[prost(uint32, tag = "18")]
    pub target_home_owner_uid: u32,
    #[prost(bool, tag = "19")]
    pub is_new_player: bool,
    #[prost(bool, tag = "20")]
    pub is_data_need_relogin: bool,
    #[prost(bool, tag = "21")]
    pub is_relogin: bool,
    #[prost(bool, tag = "22")]
    pub is_audit: bool,
    #[prost(bool, tag = "23")]
    pub is_login_rsp_split: bool,
    #[prost(bool, tag = "24")]
    pub is_use_ability_hash: bool,
    #[prost(bool, tag = "25")]
    pub is_sc_open: bool,
    #[prost(bool, tag = "26")]
    pub is_enable_client_hash_debug: bool,
    #[prost(uint32, tag = "27")]
    pub client_data_version: u32,
    #[prost(double, tag = "28")]
    pub total_tick_time: f64,
    #[prost(uint32, tag = "29")]
    pub client_silence_data_version: u32,
    #[prost(uint32, tag = "30")]
    pub target_uid: u32,
    #[prost(uint64, tag = "31")]
    pub login_rand: u64,
    #[prost(int32, tag = "32")]
    pub retcode: i32,
    #[prost(uint32, tag = "33")]
    pub player_data_version: u32,
    #[prost(int32, tag = "34")]
    pub ability_hash_code: i32,
    #[prost(bool, tag = "35")]
    pub is_transfer: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLogoutReq {
    #[prost(enumeration = "PlayerLogoutReqReason", tag = "1")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(106)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLogoutRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(107)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLogoutNotify {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(108)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerDataNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub prop_map: ::std::collections::HashMap<u32, PropValue>,
    #[prost(string, tag = "2")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub server_time: u64,
    #[prost(bool, tag = "4")]
    pub is_first_login_today: bool,
    #[prost(uint32, tag = "5")]
    pub region_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(109)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeGameTimeReq {
    #[prost(uint32, tag = "1")]
    pub extra_days: u32,
    #[prost(bool, tag = "2")]
    pub is_force_set: bool,
    #[prost(uint32, tag = "3")]
    pub game_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(110)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeGameTimeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub cur_game_time: u32,
    #[prost(uint32, tag = "3")]
    pub extra_days: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerGameTimeNotify {
    #[prost(bool, tag = "1")]
    pub is_home: bool,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(uint32, tag = "3")]
    pub game_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(112)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerPropNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub prop_map: ::std::collections::HashMap<u32, PropValue>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(113)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientTriggerEventNotify {
    #[prost(enumeration = "EventTriggerType", tag = "1")]
    pub event_type: i32,
    #[prost(uint32, tag = "2")]
    pub force_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(114)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPlayerPropReq {
    #[prost(message, repeated, tag = "1")]
    pub prop_list: ::prost::alloc::vec::Vec<PropValue>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(115)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetPlayerPropRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(116)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPlayerBornDataReq {
    #[prost(string, tag = "1")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(117)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetPlayerBornDataRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(118)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoSetPlayerBornDataNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(119)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerPropChangeNotify {
    #[prost(uint32, tag = "1")]
    pub prop_delta: u32,
    #[prost(uint32, tag = "2")]
    pub prop_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(120)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPlayerNameReq {
    #[prost(string, tag = "1")]
    pub nick_name: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(121)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPlayerNameRsp {
    #[prost(string, tag = "1")]
    pub nick_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(122)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetOpenStateReq {
    #[prost(uint32, tag = "1")]
    pub key: u32,
    #[prost(uint32, tag = "2")]
    pub value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(123)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetOpenStateRsp {
    #[prost(uint32, tag = "1")]
    pub value: u32,
    #[prost(uint32, tag = "2")]
    pub key: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(124)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenStateUpdateNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub open_state_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(125)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenStateChangeNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub open_state_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(126)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCookReq {
    #[prost(uint32, tag = "1")]
    pub assist_avatar: u32,
    #[prost(uint32, tag = "2")]
    pub cook_count: u32,
    #[prost(uint32, tag = "3")]
    pub qte_quality: u32,
    #[prost(uint32, tag = "4")]
    pub recipe_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(127)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerCookRsp {
    #[prost(message, repeated, tag = "1")]
    pub extra_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, optional, tag = "2")]
    pub recipe_data: ::core::option::Option<CookRecipeData>,
    #[prost(message, repeated, tag = "3")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "4")]
    pub cook_count: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub qte_quality: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(128)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRandomCookReq {
    #[prost(message, repeated, tag = "1")]
    pub material_list: ::prost::alloc::vec::Vec<ItemParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(129)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerRandomCookRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CookRecipeData {
    #[prost(uint32, tag = "1")]
    pub proficiency: u32,
    #[prost(uint32, tag = "2")]
    pub recipe_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(130)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CookDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub recipe_data_list: ::prost::alloc::vec::Vec<CookRecipeData>,
    #[prost(uint32, tag = "2")]
    pub grade: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(131)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CookRecipeDataNotify {
    #[prost(message, optional, tag = "1")]
    pub recipe_data: ::core::option::Option<CookRecipeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(132)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CookGradeDataNotify {
    #[prost(uint32, tag = "1")]
    pub grade: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(133)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCompoundMaterialReq {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(uint32, tag = "2")]
    pub compound_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompoundQueueData {
    #[prost(uint32, tag = "1")]
    pub wait_count: u32,
    #[prost(uint32, tag = "2")]
    pub output_count: u32,
    #[prost(uint32, tag = "3")]
    pub compound_id: u32,
    #[prost(uint32, tag = "4")]
    pub output_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(134)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCompoundMaterialRsp {
    #[prost(message, optional, tag = "1")]
    pub compound_que_data: ::core::option::Option<CompoundQueueData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(135)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeCompoundOutputReq {
    #[prost(uint32, tag = "1")]
    pub compound_group_id: u32,
    #[prost(uint32, tag = "2")]
    pub compound_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(136)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeCompoundOutputRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(137)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompoundDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_compound_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub compound_que_data_list: ::prost::alloc::vec::Vec<CompoundQueueData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(138)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCompoundDataReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(139)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompoundDataRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_compound_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub compound_que_data_list: ::prost::alloc::vec::Vec<CompoundQueueData>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(140)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerTimeNotify {
    #[prost(bool, tag = "1")]
    pub is_paused: bool,
    #[prost(uint64, tag = "2")]
    pub server_time: u64,
    #[prost(uint64, tag = "3")]
    pub player_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(141)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSetPauseReq {
    #[prost(bool, tag = "1")]
    pub is_paused: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(142)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSetPauseRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(143)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSetLanguageReq {
    #[prost(uint32, tag = "1")]
    pub language_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(144)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSetLanguageRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(145)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataResVersionNotify {
    #[prost(string, tag = "1")]
    pub client_md5: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_silence_version_suffix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub res_version_config: ::core::option::Option<ResVersionConfig>,
    #[prost(string, tag = "4")]
    pub client_version_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub client_silence_md5: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub client_data_version: u32,
    #[prost(enumeration = "DataResVersionOpType", tag = "7")]
    pub op_type: i32,
    #[prost(bool, tag = "8")]
    pub is_data_need_relogin: bool,
    #[prost(uint32, tag = "9")]
    pub client_silence_data_version: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyTaskInfo {
    #[prost(bool, tag = "1")]
    pub is_finished: bool,
    #[prost(uint32, tag = "2")]
    pub finish_progress: u32,
    #[prost(uint32, tag = "3")]
    pub daily_task_id: u32,
    #[prost(uint32, tag = "4")]
    pub reward_id: u32,
    #[prost(uint32, tag = "5")]
    pub progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(146)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyTaskDataNotify {
    #[prost(uint32, tag = "1")]
    pub score_reward_id: u32,
    #[prost(bool, tag = "2")]
    pub is_taken_score_reward: bool,
    #[prost(uint32, tag = "3")]
    pub finished_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(147)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyTaskProgressNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<DailyTaskInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(148)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyTaskScoreRewardNotify {
    #[prost(uint32, tag = "1")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(149)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldOwnerDailyTaskNotify {
    #[prost(message, repeated, tag = "1")]
    pub task_list: ::prost::alloc::vec::Vec<DailyTaskInfo>,
    #[prost(uint32, tag = "2")]
    pub finished_daily_task_num: u32,
    #[prost(uint32, tag = "3")]
    pub filter_city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(150)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddRandTaskInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub rand_task_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(151)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveRandTaskInfoNotify {
    #[prost(enumeration = "FinishReason", tag = "1")]
    pub reason: i32,
    #[prost(bool, tag = "2")]
    pub is_succ: bool,
    #[prost(uint32, tag = "3")]
    pub rand_task_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(152)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakePlayerLevelRewardReq {
    #[prost(uint32, tag = "1")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(153)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakePlayerLevelRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub reward_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(154)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLevelRewardUpdateNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub level_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GivingRecord {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub material_cnt_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub giving_id: u32,
    #[prost(bool, tag = "4")]
    pub is_finished: bool,
    #[prost(bool, tag = "5")]
    pub is_gadget_giving: bool,
    #[prost(uint32, tag = "6")]
    pub group_id: u32,
    #[prost(uint32, tag = "7")]
    pub last_group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(155)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GivingRecordNotify {
    #[prost(message, repeated, tag = "1")]
    pub giving_record_list: ::prost::alloc::vec::Vec<GivingRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(156)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GivingRecordChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub giving_record: ::core::option::Option<GivingRecord>,
    #[prost(bool, tag = "2")]
    pub is_deactive: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(157)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemGivingReq {
    #[prost(message, repeated, tag = "1")]
    pub item_param_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(map = "uint64, uint32", tag = "2")]
    pub item_guid_count_map: ::std::collections::HashMap<u64, u32>,
    #[prost(enumeration = "ItemGivingType", tag = "3")]
    pub item_giving_type: i32,
    #[prost(uint32, tag = "4")]
    pub giving_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(158)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ItemGivingRsp {
    #[prost(uint32, tag = "1")]
    pub giving_group_id: u32,
    #[prost(uint32, tag = "2")]
    pub giving_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(159)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCookArgsReq {
    #[prost(uint32, tag = "1")]
    pub assist_avatar: u32,
    #[prost(uint32, tag = "2")]
    pub recipe_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(160)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCookArgsRsp {
    #[prost(float, tag = "1")]
    pub qte_range_ratio: f32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(161)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLuaShellNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub lua_shell: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(enumeration = "LuaShellType", tag = "3")]
    pub shell_type: i32,
    #[prost(uint32, tag = "4")]
    pub use_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(162)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerDisconnectClientNotify {
    #[prost(uint32, tag = "1")]
    pub data: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(163)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AntiAddictNotify {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub level: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub msg_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(164)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerForceExitReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(165)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerForceExitRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(166)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerInjectFixNotify {
    #[prost(bytes = "vec", tag = "1")]
    pub inject_fix: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskVar {
    #[prost(int32, repeated, tag = "1")]
    pub value_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "2")]
    pub key: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(167)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskVarNotify {
    #[prost(message, repeated, tag = "1")]
    pub task_var_list: ::prost::alloc::vec::Vec<TaskVar>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(168)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientLockGameTimeNotify {
    #[prost(bool, tag = "1")]
    pub is_lock: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(169)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNextResourceInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(170)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNextResourceInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub next_res_version_config: ::core::option::Option<ResVersionConfig>,
    #[prost(string, tag = "2")]
    pub next_resource_url: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(171)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdjustWorldLevelReq {
    #[prost(uint32, tag = "1")]
    pub expect_world_level: u32,
    #[prost(uint32, tag = "2")]
    pub cur_world_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(172)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdjustWorldLevelRsp {
    #[prost(uint32, tag = "1")]
    pub after_world_level: u32,
    #[prost(uint32, tag = "2")]
    pub cd_over_time: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(173)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyTaskFilterCityReq {
    #[prost(uint32, tag = "1")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(174)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DailyTaskFilterCityRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(175)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DailyTaskUnlockedCitiesNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub unlocked_city_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExclusiveRuleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub object_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub rule_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(176)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExclusiveRuleNotify {
    #[prost(message, repeated, tag = "1")]
    pub rule_info_list: ::prost::alloc::vec::Vec<ExclusiveRuleInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(177)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompoundUnlockNotify {
    #[prost(uint32, tag = "1")]
    pub compound_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationSkillRequest {
    #[prost(uint32, tag = "1")]
    pub skill_depot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationReliquaryRequest {
    #[prost(uint32, tag = "1")]
    pub equip_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationElementReliquaryRequest {
    #[prost(uint32, tag = "1")]
    pub equip_type: u32,
    #[prost(uint32, tag = "2")]
    pub element_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(178)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGameplayRecommendationReq {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(oneof = "get_gameplay_recommendation_req::Detail", tags = "2, 3, 4")]
    pub detail: ::core::option::Option<get_gameplay_recommendation_req::Detail>,
}
/// Nested message and enum types in `GetGameplayRecommendationReq`.
pub mod get_gameplay_recommendation_req {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "2")]
        SkillRequest(super::GameplayRecommendationSkillRequest),
        #[prost(message, tag = "3")]
        ReliquaryRequest(super::GameplayRecommendationReliquaryRequest),
        #[prost(message, tag = "4")]
        ElementReliquaryRequest(super::GameplayRecommendationElementReliquaryRequest),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationSkillResponse {
    #[prost(uint32, repeated, tag = "1")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub skill_depot_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationReliquaryMainPropData {
    #[prost(uint32, tag = "1")]
    pub permillage: u32,
    #[prost(uint32, tag = "2")]
    pub main_prop_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationReliquaryResponse {
    #[prost(message, repeated, tag = "1")]
    pub main_prop_data_list: ::prost::alloc::vec::Vec<
        GameplayRecommendationReliquaryMainPropData,
    >,
    #[prost(uint32, tag = "2")]
    pub equip_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GameplayRecommendationElementReliquaryResponse {
    #[prost(message, repeated, tag = "1")]
    pub main_prop_data_list: ::prost::alloc::vec::Vec<
        GameplayRecommendationReliquaryMainPropData,
    >,
    #[prost(uint32, tag = "2")]
    pub equip_type: u32,
    #[prost(uint32, tag = "3")]
    pub element_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(179)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGameplayRecommendationRsp {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(oneof = "get_gameplay_recommendation_rsp::Detail", tags = "3, 4, 5")]
    pub detail: ::core::option::Option<get_gameplay_recommendation_rsp::Detail>,
}
/// Nested message and enum types in `GetGameplayRecommendationRsp`.
pub mod get_gameplay_recommendation_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "3")]
        SkillResponse(super::GameplayRecommendationSkillResponse),
        #[prost(message, tag = "4")]
        ReliquaryResponse(super::GameplayRecommendationReliquaryResponse),
        #[prost(message, tag = "5")]
        ElementReliquaryResponse(super::GameplayRecommendationElementReliquaryResponse),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(180)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeBackGivingItemReq {
    #[prost(uint32, tag = "1")]
    pub giving_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(181)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeBackGivingItemRsp {
    #[prost(uint32, tag = "1")]
    pub giving_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(182)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerNicknameAuditDataNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ContentAuditInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(183)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerNicknameNotify {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(184)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NicknameAuditConfigNotify {
    #[prost(uint32, tag = "1")]
    pub submit_limit: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(185)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadNicknameAuditReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(186)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadNicknameAuditRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(187)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCompoundMaterialBoostReq {
    #[prost(bool, tag = "1")]
    pub is_boost_all: bool,
    #[prost(uint32, tag = "2")]
    pub consume_material_id: u32,
    #[prost(uint32, tag = "3")]
    pub target_compound_group_id: u32,
    #[prost(uint32, tag = "4")]
    pub consume_material_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(188)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerCompoundMaterialBoostRsp {
    #[prost(message, repeated, tag = "1")]
    pub take_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub compound_que_data_list: ::prost::alloc::vec::Vec<CompoundQueueData>,
    #[prost(enumeration = "CompoundBoostTakeStatusType", tag = "3")]
    pub take_status: i32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(189)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerGameTimeByLuaNotify {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub game_time: u32,
    #[prost(uint32, tag = "3")]
    pub sim_speed: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(190)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerIpRegionNotify {
    #[prost(string, tag = "1")]
    pub ip_code: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(191)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientSetGameTimeReq {
    #[prost(bool, tag = "1")]
    pub is_force_set: bool,
    #[prost(uint32, tag = "2")]
    pub client_game_time: u32,
    #[prost(uint32, tag = "3")]
    pub game_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(192)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientSetGameTimeRsp {
    #[prost(uint32, tag = "1")]
    pub client_game_time: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub game_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(193)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGameTimeLockedQuestListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(194)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGameTimeLockedQuestListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub game_time_locked_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1201)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityPropNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub prop_map: ::std::collections::HashMap<u32, PropValue>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1202)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifeStateChangeNotify {
    #[prost(string, tag = "1")]
    pub attack_tag: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(uint32, tag = "3")]
    pub life_state: u32,
    #[prost(uint32, tag = "4")]
    pub source_entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub move_reliable_seq: u32,
    #[prost(enumeration = "PlayerDieType", tag = "6")]
    pub die_type: i32,
    #[prost(uint32, tag = "7")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1203)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityFightPropNotify {
    #[prost(map = "uint32, float", tag = "1")]
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1204)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityFightPropUpdateNotify {
    #[prost(map = "uint32, float", tag = "1")]
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1205)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarFightPropNotify {
    #[prost(map = "uint32, float", tag = "1")]
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1206)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarFightPropUpdateNotify {
    #[prost(map = "uint32, float", tag = "1")]
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1207)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityFightPropChangeReasonNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub prop_type: u32,
    #[prost(enumeration = "ChangeEnergyReason", tag = "3")]
    pub change_energy_reason: i32,
    #[prost(enumeration = "PropChangeReason", tag = "4")]
    pub reason: i32,
    #[prost(enumeration = "ChangeHpReason", tag = "5")]
    pub change_hp_reason: i32,
    #[prost(float, tag = "6")]
    pub prop_delta: f32,
    #[prost(uint32, tag = "7")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1208)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarLifeStateChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(string, tag = "2")]
    pub attack_tag: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub life_state: u32,
    #[prost(uint32, tag = "4")]
    pub source_entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub move_reliable_seq: u32,
    #[prost(enumeration = "PlayerDieType", tag = "6")]
    pub die_type: i32,
    #[prost(uint64, tag = "7")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarPropChangeReasonNotify {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub prop_type: u32,
    #[prost(float, tag = "3")]
    pub old_value: f32,
    #[prost(float, tag = "4")]
    pub cur_value: f32,
    #[prost(enumeration = "PropChangeReason", tag = "5")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1210)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerPropChangeReasonNotify {
    #[prost(float, tag = "1")]
    pub old_value: f32,
    #[prost(float, tag = "2")]
    pub cur_value: f32,
    #[prost(uint32, tag = "3")]
    pub prop_type: u32,
    #[prost(enumeration = "PropChangeReason", tag = "4")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1211)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarPropNotify {
    #[prost(map = "uint32, int64", tag = "1")]
    pub prop_map: ::std::collections::HashMap<u32, i64>,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1212)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkNewNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub mark_new_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestListNotify {
    #[prost(message, repeated, tag = "1")]
    pub quest_list: ::prost::alloc::vec::Vec<Quest>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestListUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub quest_list: ::prost::alloc::vec::Vec<Quest>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(403)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestDelNotify {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChildQuest {
    #[prost(uint32, tag = "1")]
    pub quest_config_id: u32,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
    #[prost(uint32, tag = "3")]
    pub state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParentQuestRandomInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub factor_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub template_id: u32,
    #[prost(uint32, tag = "3")]
    pub entrance_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InferenceWordInfo {
    #[prost(uint32, tag = "1")]
    pub word_id: u32,
    #[prost(uint32, tag = "2")]
    pub unlock_by_word_id: u32,
    #[prost(bool, tag = "3")]
    pub is_associate: bool,
    #[prost(bool, tag = "4")]
    pub is_submit: bool,
    #[prost(bool, tag = "5")]
    pub is_interpret: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InferencePageInfo {
    #[prost(message, repeated, tag = "1")]
    pub unlock_word_list: ::prost::alloc::vec::Vec<InferenceWordInfo>,
    #[prost(uint32, tag = "2")]
    pub page_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParentQuest {
    #[prost(int32, repeated, tag = "1")]
    pub quest_var: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "2")]
    pub child_quest_list: ::prost::alloc::vec::Vec<ChildQuest>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub time_var_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, repeated, tag = "4")]
    pub inference_page_list: ::prost::alloc::vec::Vec<InferencePageInfo>,
    #[prost(message, optional, tag = "5")]
    pub random_info: ::core::option::Option<ParentQuestRandomInfo>,
    #[prost(uint32, tag = "6")]
    pub parent_quest_state: u32,
    #[prost(uint32, tag = "7")]
    pub parent_quest_id: u32,
    #[prost(bool, tag = "8")]
    pub is_random: bool,
    #[prost(bool, tag = "9")]
    pub is_finished: bool,
    #[prost(uint32, tag = "10")]
    pub accept_time: u32,
    #[prost(uint32, tag = "11")]
    pub quest_var_seq: u32,
    #[prost(uint64, tag = "12")]
    pub video_key: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(404)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinishedParentQuestNotify {
    #[prost(message, repeated, tag = "1")]
    pub parent_quest_list: ::prost::alloc::vec::Vec<ParentQuest>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(405)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinishedParentQuestUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub parent_quest_list: ::prost::alloc::vec::Vec<ParentQuest>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddQuestContentProgressReq {
    #[prost(uint32, tag = "1")]
    pub param: u32,
    #[prost(uint32, tag = "2")]
    pub content_type: u32,
    #[prost(uint32, tag = "3")]
    pub add_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddQuestContentProgressRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub content_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(408)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestCreateEntityReq {
    #[prost(message, optional, tag = "1")]
    pub entity: ::core::option::Option<CreateEntityInfo>,
    #[prost(bool, tag = "2")]
    pub is_rewind: bool,
    #[prost(uint32, tag = "3")]
    pub parent_quest_id: u32,
    #[prost(uint32, tag = "4")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestCreateEntityRsp {
    #[prost(message, optional, tag = "1")]
    pub entity: ::core::option::Option<CreateEntityInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(bool, tag = "3")]
    pub is_rewind: bool,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub quest_id: u32,
    #[prost(uint32, tag = "6")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(410)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestDestroyEntityReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(411)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestDestroyEntityRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub quest_id: u32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChapterStateNotify {
    #[prost(message, optional, tag = "1")]
    pub need_player_level: ::core::option::Option<NeedPlayerLevel>,
    #[prost(message, optional, tag = "2")]
    pub need_begin_time: ::core::option::Option<NeedBeginTime>,
    #[prost(uint32, tag = "3")]
    pub chapter_id: u32,
    #[prost(enumeration = "ChapterState", tag = "4")]
    pub chapter_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NeedPlayerLevel {
    #[prost(bool, tag = "1")]
    pub is_limit: bool,
    #[prost(uint32, tag = "2")]
    pub config_need_player_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NeedBeginTime {
    #[prost(uint32, tag = "1")]
    pub config_need_begin_time: u32,
    #[prost(bool, tag = "2")]
    pub is_limit: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(413)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestProgressUpdateNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub finish_progress_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub fail_progress_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestVarOp {
    #[prost(bool, tag = "1")]
    pub is_add: bool,
    #[prost(int32, tag = "2")]
    pub value: i32,
    #[prost(uint32, tag = "3")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(414)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestUpdateQuestVarReq {
    #[prost(message, repeated, tag = "1")]
    pub quest_var_op_list: ::prost::alloc::vec::Vec<QuestVarOp>,
    #[prost(uint32, tag = "2")]
    pub parent_quest_id: u32,
    #[prost(uint32, tag = "3")]
    pub parent_quest_var_seq: u32,
    #[prost(uint32, tag = "4")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(415)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestUpdateQuestVarRsp {
    #[prost(uint32, tag = "1")]
    pub parent_quest_id: u32,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
    #[prost(uint32, tag = "3")]
    pub parent_quest_var_seq: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(416)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestUpdateQuestVarNotify {
    #[prost(int32, repeated, tag = "1")]
    pub quest_var: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "2")]
    pub parent_quest_var_seq: u32,
    #[prost(uint32, tag = "3")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(417)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestDestroyNpcReq {
    #[prost(uint32, tag = "1")]
    pub npc_id: u32,
    #[prost(uint32, tag = "2")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(418)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestDestroyNpcRsp {
    #[prost(uint32, tag = "1")]
    pub npc_id: u32,
    #[prost(uint32, tag = "2")]
    pub parent_quest_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BargainSnapshot {
    #[prost(uint32, tag = "1")]
    pub price_low_limit: u32,
    #[prost(uint32, tag = "2")]
    pub expected_price: u32,
    #[prost(uint32, tag = "3")]
    pub bargain_id: u32,
    #[prost(int32, tag = "4")]
    pub cur_mood: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(419)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BargainStartNotify {
    #[prost(message, optional, tag = "1")]
    pub snapshot: ::core::option::Option<BargainSnapshot>,
    #[prost(uint32, tag = "2")]
    pub bargain_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(420)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BargainOfferPriceReq {
    #[prost(uint32, tag = "1")]
    pub price: u32,
    #[prost(uint32, tag = "2")]
    pub bargain_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(421)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BargainOfferPriceRsp {
    #[prost(uint32, tag = "1")]
    pub result_param: u32,
    #[prost(enumeration = "BargainResultType", tag = "2")]
    pub bargain_result: i32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(int32, tag = "4")]
    pub cur_mood: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(422)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BargainTerminateNotify {
    #[prost(uint32, tag = "1")]
    pub bargain_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(423)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBargainDataReq {
    #[prost(uint32, tag = "1")]
    pub bargain_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(424)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBargainDataRsp {
    #[prost(message, optional, tag = "1")]
    pub snapshot: ::core::option::Option<BargainSnapshot>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub bargain_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(425)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllActivatedBargainDataReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(426)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllActivatedBargainDataRsp {
    #[prost(message, repeated, tag = "1")]
    pub snapshot_list: ::prost::alloc::vec::Vec<BargainSnapshot>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(427)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerCondMeetQuestListUpdateNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub del_quest_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub add_quest_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestGlobalVar {
    #[prost(int32, tag = "1")]
    pub value: i32,
    #[prost(uint32, tag = "2")]
    pub key: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(428)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestGlobalVarNotify {
    #[prost(message, repeated, tag = "1")]
    pub var_list: ::prost::alloc::vec::Vec<QuestGlobalVar>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(429)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestTransmitReq {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(430)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestTransmitRsp {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(431)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonalLineAllDataReq {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockedPersonallineData {
    #[prost(uint32, tag = "1")]
    pub personal_line_id: u32,
    #[prost(enumeration = "LockReason", tag = "2")]
    pub lock_reason: i32,
    #[prost(oneof = "locked_personalline_data::Param", tags = "3, 4, 5")]
    pub param: ::core::option::Option<locked_personalline_data::Param>,
}
/// Nested message and enum types in `LockedPersonallineData`.
pub mod locked_personalline_data {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(uint32, tag = "3")]
        ChapterId(u32),
        #[prost(uint32, tag = "4")]
        Level(u32),
        #[prost(message, tag = "5")]
        QuestParam(super::QuestParam),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestParam {
    #[prost(uint32, tag = "1")]
    pub chapter_id: u32,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(432)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalLineAllDataRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub can_be_unlocked_personal_line_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub ongoing_personal_line_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub locked_personal_line_list: ::prost::alloc::vec::Vec<LockedPersonallineData>,
    #[prost(uint32, tag = "4")]
    pub legendary_key_count: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(uint32, tag = "6")]
    pub cur_finished_daily_task_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(433)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemLegendaryKeyReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(434)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemLegendaryKeyRsp {
    #[prost(uint32, tag = "1")]
    pub legendary_key_count: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(435)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockPersonalLineReq {
    #[prost(uint32, tag = "1")]
    pub personal_line_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(436)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockPersonalLineRsp {
    #[prost(uint32, tag = "1")]
    pub personal_line_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(oneof = "unlock_personal_line_rsp::Param", tags = "3, 4")]
    pub param: ::core::option::Option<unlock_personal_line_rsp::Param>,
}
/// Nested message and enum types in `UnlockPersonalLineRsp`.
pub mod unlock_personal_line_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(uint32, tag = "3")]
        Level(u32),
        #[prost(uint32, tag = "4")]
        ChapterId(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(437)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelFinishParentQuestNotify {
    #[prost(uint32, tag = "1")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(438)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestUpdateQuestTimeVarNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub time_var_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(439)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalLineNewUnlockNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub personal_line_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(440)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NpcTalkStateNotify {
    #[prost(bool, tag = "1")]
    pub is_ban: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(441)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetQuestLackingResourceReq {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(442)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQuestLackingResourceRsp {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub lacked_npc_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub lacked_place_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub lacked_place_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub lacked_npc_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub quest_id: u32,
    #[prost(int32, tag = "6")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(443)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetParentQuestVideoKeyReq {
    #[prost(uint32, tag = "1")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(444)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetParentQuestVideoKeyRsp {
    #[prost(uint32, tag = "1")]
    pub parent_quest_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub video_key: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(445)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParentQuestInferenceDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub inference_page_list: ::prost::alloc::vec::Vec<InferencePageInfo>,
    #[prost(uint32, tag = "2")]
    pub parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(446)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterpretInferenceWordReq {
    #[prost(uint32, tag = "1")]
    pub page_id: u32,
    #[prost(uint32, tag = "2")]
    pub word_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(447)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterpretInferenceWordRsp {
    #[prost(uint32, tag = "1")]
    pub word_id: u32,
    #[prost(uint32, tag = "2")]
    pub page_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(448)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssociateInferenceWordReq {
    #[prost(uint32, tag = "1")]
    pub page_id: u32,
    #[prost(uint32, tag = "2")]
    pub associate_word_id: u32,
    #[prost(uint32, tag = "3")]
    pub base_word_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(449)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssociateInferenceWordRsp {
    #[prost(uint32, tag = "1")]
    pub page_id: u32,
    #[prost(uint32, tag = "2")]
    pub base_word_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub associate_word_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(450)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitInferenceWordReq {
    #[prost(uint32, tag = "1")]
    pub page_id: u32,
    #[prost(uint32, tag = "2")]
    pub word_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(451)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitInferenceWordRsp {
    #[prost(uint32, tag = "1")]
    pub word_id: u32,
    #[prost(uint32, tag = "2")]
    pub page_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub conclusion_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(452)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestRenameAvatarReq {
    #[prost(string, tag = "1")]
    pub avatar_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_check: bool,
    #[prost(uint32, tag = "3")]
    pub rename_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(453)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestRenameAvatarRsp {
    #[prost(string, tag = "1")]
    pub avatar_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub rename_id: u32,
    #[prost(bool, tag = "4")]
    pub is_check: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4121)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RechargeReq {
    #[prost(message, optional, tag = "1")]
    pub concert_product: ::core::option::Option<ShopConcertProduct>,
    #[prost(message, optional, tag = "2")]
    pub mcoin_product: ::core::option::Option<ShopMcoinProduct>,
    #[prost(message, optional, tag = "3")]
    pub play_product: ::core::option::Option<PlayProduct>,
    #[prost(message, optional, tag = "4")]
    pub card_product: ::core::option::Option<ShopCardProduct>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4122)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RechargeRsp {
    #[prost(string, tag = "1")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_show_minors_hint: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4123)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderFinishNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(string, tag = "2")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub card_product_remain_days: u32,
    #[prost(uint32, tag = "4")]
    pub order_id: u32,
    #[prost(uint32, tag = "5")]
    pub add_mcoin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4124)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardProductRewardNotify {
    #[prost(string, tag = "1")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub hcoin: u32,
    #[prost(uint32, tag = "3")]
    pub remain_days: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductPriceTier {
    #[prost(string, tag = "1")]
    pub price_tier: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub product_id: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResinCardData {
    #[prost(uint32, tag = "1")]
    pub last_daily_reward_time: u32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub remain_reward_days: u32,
    #[prost(uint32, tag = "4")]
    pub expire_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4125)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRechargeDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub product_price_tier_list: ::prost::alloc::vec::Vec<ProductPriceTier>,
    #[prost(uint32, tag = "2")]
    pub card_product_remain_days: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4126)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OrderDisplayNotify {
    #[prost(uint32, tag = "1")]
    pub order_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4127)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportTrackingIoInfoNotify {
    #[prost(string, tag = "1")]
    pub appid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rydevicetype: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub client_tz: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub mac: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub deviceid: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4128)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeResinCardDailyRewardReq {
    #[prost(uint32, tag = "1")]
    pub product_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4129)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeResinCardDailyRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_vec: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub product_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4130)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResinCardDataUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub card_data_list: ::prost::alloc::vec::Vec<ResinCardData>,
    #[prost(uint32, tag = "2")]
    pub today_start_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegionalPlayVar {
    #[prost(uint32, tag = "1")]
    pub r#type: u32,
    #[prost(float, tag = "2")]
    pub base_value: f32,
    #[prost(float, tag = "3")]
    pub value: f32,
    #[prost(float, tag = "4")]
    pub max_value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6237)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionalPlayInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub var_list: ::prost::alloc::vec::Vec<RegionalPlayVar>,
    #[prost(string, tag = "2")]
    pub play_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_enabled: bool,
    #[prost(bool, tag = "4")]
    pub is_in_region: bool,
    #[prost(uint32, tag = "5")]
    pub play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeathZoneInfo {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6238)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeathZoneInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub death_zone_info_list: ::prost::alloc::vec::Vec<DeathZoneInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6239)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDeathZoneNotify {
    #[prost(uint32, tag = "1")]
    pub cur_death_zone_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegionSearch {
    #[prost(uint32, tag = "1")]
    pub region_search_id: u32,
    #[prost(uint32, tag = "2")]
    pub progress: u32,
    #[prost(bool, tag = "3")]
    pub is_entered: bool,
    #[prost(enumeration = "RegionSearchState", tag = "4")]
    pub state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionSearchInfo {
    #[prost(message, repeated, tag = "1")]
    pub region_search_list: ::prost::alloc::vec::Vec<RegionSearch>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(bool, tag = "3")]
    pub is_entered: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5606)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionSearchNotify {
    #[prost(message, repeated, tag = "1")]
    pub region_search_list: ::prost::alloc::vec::Vec<RegionSearchInfo>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5607)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegionSearchChangeRegionNotify {
    #[prost(uint32, tag = "1")]
    pub region_id: u32,
    #[prost(enumeration = "RegionEvent", tag = "2")]
    pub event: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5608)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeRegionSearchRewardReq {
    #[prost(uint32, tag = "1")]
    pub search_id: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5609)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeRegionSearchRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub search_id: u32,
    #[prost(uint32, tag = "3")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5610)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRegionSearchReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5706)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalUidOpNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub param_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub duration: u32,
    #[prost(uint32, tag = "4")]
    pub param_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerMessageNotify {
    #[prost(uint32, tag = "1")]
    pub index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CityReputationQuestInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub taken_parent_quest_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub finished_parent_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CityReputationRequestInfo {
    #[prost(message, repeated, tag = "1")]
    pub request_info_list: ::prost::alloc::vec::Vec<RequestInfo>,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestInfo {
    #[prost(bool, tag = "1")]
    pub is_taken_reward: bool,
    #[prost(uint32, tag = "2")]
    pub quest_id: u32,
    #[prost(uint32, tag = "3")]
    pub request_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CityReputationExploreInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub taken_explore_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub explore_percent: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CityReputationHuntInfo {
    #[prost(uint32, tag = "1")]
    pub cur_week_finish_num: u32,
    #[prost(bool, tag = "2")]
    pub has_reward: bool,
    #[prost(bool, tag = "3")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CityReputationInfo {
    #[prost(message, optional, tag = "1")]
    pub explore_info: ::core::option::Option<CityReputationExploreInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub taken_level_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "3")]
    pub hunt_info: ::core::option::Option<CityReputationHuntInfo>,
    #[prost(message, optional, tag = "4")]
    pub quest_info: ::core::option::Option<CityReputationQuestInfo>,
    #[prost(message, optional, tag = "5")]
    pub request_info: ::core::option::Option<CityReputationRequestInfo>,
    #[prost(uint32, tag = "6")]
    pub level: u32,
    #[prost(uint32, tag = "7")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "8")]
    pub total_accept_request_num: u32,
    #[prost(uint32, tag = "9")]
    pub exp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2801)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCityReputationInfoReq {
    #[prost(uint32, tag = "1")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2802)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCityReputationInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub city_reputation_info: ::core::option::Option<CityReputationInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2803)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeCityReputationLevelRewardReq {
    #[prost(uint32, tag = "1")]
    pub city_id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2804)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeCityReputationLevelRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
    #[prost(uint32, tag = "4")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2805)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CityReputationLevelupNotify {
    #[prost(uint32, tag = "1")]
    pub city_id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2806)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeCityReputationParentQuestReq {
    #[prost(uint32, repeated, tag = "1")]
    pub parent_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2807)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeCityReputationParentQuestRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub parent_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2808)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcceptCityReputationRequestReq {
    #[prost(uint32, tag = "1")]
    pub city_id: u32,
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2809)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcceptCityReputationRequestRsp {
    #[prost(uint32, tag = "1")]
    pub request_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2810)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelCityReputationRequestReq {
    #[prost(uint32, tag = "1")]
    pub request_id: u32,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2811)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelCityReputationRequestRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2812)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCityReputationMapInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2813)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCityReputationMapInfoRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub unlock_hunting_city_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub reward_city_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(bool, tag = "4")]
    pub is_new_request: bool,
    #[prost(bool, tag = "5")]
    pub is_new_hunting: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2814)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeCityReputationExploreRewardReq {
    #[prost(uint32, repeated, tag = "1")]
    pub explore_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2815)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeCityReputationExploreRewardRsp {
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, repeated, tag = "2")]
    pub explore_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CityReputationSimpleInfo {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2816)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CityReputationDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub simple_info_list: ::prost::alloc::vec::Vec<CityReputationSimpleInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReunionSignInInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub reward_day_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub last_sign_in_time: u32,
    #[prost(uint32, tag = "3")]
    pub sign_in_count: u32,
    #[prost(uint32, tag = "4")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReunionWatcherInfo {
    #[prost(uint32, tag = "1")]
    pub reward_unlock_time: u32,
    #[prost(uint32, tag = "2")]
    pub total_progress: u32,
    #[prost(bool, tag = "3")]
    pub is_taken_reward: bool,
    #[prost(uint32, tag = "4")]
    pub watcher_id: u32,
    #[prost(uint32, tag = "5")]
    pub cur_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReunionMissionInfo {
    #[prost(message, repeated, tag = "1")]
    pub watcher_list: ::prost::alloc::vec::Vec<ReunionWatcherInfo>,
    #[prost(bool, repeated, tag = "2")]
    pub is_taken_reward_list: ::prost::alloc::vec::Vec<bool>,
    #[prost(message, repeated, tag = "3")]
    pub cur_day_watcher_list: ::prost::alloc::vec::Vec<ReunionWatcherInfo>,
    #[prost(uint32, tag = "4")]
    pub cur_score: u32,
    #[prost(uint32, tag = "5")]
    pub next_refresh_time: u32,
    #[prost(bool, tag = "6")]
    pub is_finished: bool,
    #[prost(bool, tag = "7")]
    pub is_taken_reward: bool,
    #[prost(uint32, tag = "8")]
    pub mission_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReunionPrivilegeInfo {
    #[prost(uint32, tag = "1")]
    pub cur_day_count: u32,
    #[prost(uint32, tag = "2")]
    pub total_count: u32,
    #[prost(uint32, tag = "3")]
    pub privilege_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReunionBriefInfo {
    #[prost(message, optional, tag = "1")]
    pub privilege_info: ::core::option::Option<ReunionPrivilegeInfo>,
    #[prost(enumeration = "ReunionReportedType", repeated, tag = "2")]
    pub reported_type_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub privilege_id: u32,
    #[prost(uint32, tag = "5")]
    pub first_day_start_time: u32,
    #[prost(uint32, tag = "6")]
    pub first_gift_reward_id: u32,
    #[prost(uint32, tag = "7")]
    pub mission_id: u32,
    #[prost(bool, tag = "8")]
    pub is_taken_first_gift: bool,
    #[prost(bool, tag = "9")]
    pub mission_has_reward: bool,
    #[prost(bool, tag = "10")]
    pub sign_in_has_reward: bool,
    #[prost(uint32, tag = "11")]
    pub sign_in_config_id: u32,
    #[prost(uint32, tag = "12")]
    pub start_time: u32,
    #[prost(uint32, tag = "13")]
    pub finish_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5008)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReunionBriefInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5009)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReunionBriefInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub reunion_brief_info: ::core::option::Option<ReunionBriefInfo>,
    #[prost(bool, tag = "2")]
    pub is_activate: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5010)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeReunionFirstGiftRewardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5011)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeReunionFirstGiftRewardRsp {
    #[prost(int32, tag = "1")]
    pub reward_id: i32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5012)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetReunionSignInInfoReq {
    #[prost(uint32, tag = "1")]
    pub sign_in_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5013)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReunionSignInInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub sign_in_info: ::core::option::Option<ReunionSignInInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5014)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeReunionSignInRewardReq {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(uint32, tag = "2")]
    pub reward_day: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5015)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeReunionSignInRewardRsp {
    #[prost(message, optional, tag = "1")]
    pub sign_in_info: ::core::option::Option<ReunionSignInInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5016)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetReunionMissionInfoReq {
    #[prost(uint32, tag = "1")]
    pub mission_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5017)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReunionMissionInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub mission_info: ::core::option::Option<ReunionMissionInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5018)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeReunionWatcherRewardReq {
    #[prost(uint32, tag = "1")]
    pub mission_id: u32,
    #[prost(uint32, tag = "2")]
    pub watcher_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5019)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeReunionWatcherRewardRsp {
    #[prost(uint32, tag = "1")]
    pub mission_id: u32,
    #[prost(uint32, tag = "2")]
    pub watcher_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5020)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateReunionWatcherNotify {
    #[prost(message, optional, tag = "1")]
    pub watcher_info: ::core::option::Option<ReunionWatcherInfo>,
    #[prost(uint32, tag = "2")]
    pub mission_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5021)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeReunionMissionRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_index: u32,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
    #[prost(uint32, tag = "3")]
    pub mission_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5022)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakeReunionMissionRewardRsp {
    #[prost(message, optional, tag = "1")]
    pub mission_info: ::core::option::Option<ReunionMissionInfo>,
    #[prost(uint32, tag = "2")]
    pub reward_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub reward_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5023)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetReunionPrivilegeInfoReq {
    #[prost(uint32, tag = "1")]
    pub privilege_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5024)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetReunionPrivilegeInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub privilege_info: ::core::option::Option<ReunionPrivilegeInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5025)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReunionSettleNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5026)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReunionActivateNotify {
    #[prost(message, optional, tag = "1")]
    pub reunion_brief_info: ::core::option::Option<ReunionBriefInfo>,
    #[prost(bool, tag = "2")]
    pub is_activate: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5027)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReunionPrivilegeChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub privilege_info: ::core::option::Option<ReunionPrivilegeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5028)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReunionDailyRefreshNotify {
    #[prost(message, optional, tag = "1")]
    pub reunion_brief_info: ::core::option::Option<ReunionBriefInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5029)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReunionReportedTypeReq {
    #[prost(enumeration = "ReunionReportedType", tag = "1")]
    pub reported_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5030)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReunionReportedTypeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerRoutineInfo {
    #[prost(uint32, tag = "1")]
    pub finished_num: u32,
    #[prost(uint32, tag = "2")]
    pub routine_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3501)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRoutineDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub routine_info_list: ::prost::alloc::vec::Vec<PlayerRoutineInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldRoutineInfo {
    #[prost(uint32, tag = "1")]
    pub finish_progress: u32,
    #[prost(bool, tag = "2")]
    pub is_finished: bool,
    #[prost(uint32, tag = "3")]
    pub routine_id: u32,
    #[prost(uint32, tag = "4")]
    pub progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldRoutineTypeInfo {
    #[prost(message, repeated, tag = "1")]
    pub world_routine_info_list: ::prost::alloc::vec::Vec<WorldRoutineInfo>,
    #[prost(uint32, tag = "2")]
    pub routine_type: u32,
    #[prost(uint32, tag = "3")]
    pub next_refresh_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3502)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldAllRoutineTypeNotify {
    #[prost(message, repeated, tag = "1")]
    pub world_routine_type_list: ::prost::alloc::vec::Vec<WorldRoutineTypeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3503)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldRoutineTypeRefreshNotify {
    #[prost(message, optional, tag = "1")]
    pub world_routine_type: ::core::option::Option<WorldRoutineTypeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldRoutineChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub routine_info: ::core::option::Option<WorldRoutineInfo>,
    #[prost(uint32, tag = "2")]
    pub routine_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3505)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldRoutineTypeCloseNotify {
    #[prost(uint32, tag = "1")]
    pub routine_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(201)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerEnterSceneNotify {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub prev_pos: ::core::option::Option<Vector>,
    #[prost(string, tag = "3")]
    pub scene_transaction: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "4")]
    pub scene_tag_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub scene_id: u32,
    #[prost(uint32, tag = "6")]
    pub world_type: u32,
    #[prost(uint32, tag = "7")]
    pub enter_reason: u32,
    #[prost(uint32, tag = "8")]
    pub target_uid: u32,
    #[prost(uint32, tag = "9")]
    pub prev_scene_id: u32,
    #[prost(uint32, tag = "10")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "11")]
    pub world_level: u32,
    #[prost(bool, tag = "12")]
    pub is_first_login_enter_scene: bool,
    #[prost(bool, tag = "13")]
    pub is_skip_ui: bool,
    #[prost(uint32, tag = "14")]
    pub enter_scene_token: u32,
    #[prost(enumeration = "EnterType", tag = "15")]
    pub r#type: i32,
    #[prost(uint64, tag = "16")]
    pub scene_begin_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeaveSceneReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeaveSceneRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneInitFinishReq {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneInitFinishRsp {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(206)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityAppearNotify {
    #[prost(message, repeated, tag = "1")]
    pub entity_list: ::prost::alloc::vec::Vec<SceneEntityInfo>,
    #[prost(enumeration = "VisionType", tag = "2")]
    pub appear_type: i32,
    #[prost(uint32, tag = "3")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(207)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityDisappearNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub entity_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "VisionType", tag = "2")]
    pub disappear_type: i32,
    #[prost(uint32, tag = "3")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(208)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityMoveReq {
    #[prost(message, optional, tag = "1")]
    pub motion_info: ::core::option::Option<MotionInfo>,
    #[prost(uint32, tag = "2")]
    pub reliable_seq: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub scene_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(209)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityMoveRsp {
    #[prost(message, optional, tag = "1")]
    pub fail_motion: ::core::option::Option<MotionInfo>,
    #[prost(uint32, tag = "2")]
    pub reliable_seq: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub scene_time: u32,
    #[prost(uint32, tag = "5")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(210)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneAvatarStaminaStepReq {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(bool, tag = "2")]
    pub use_client_rot: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(211)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneAvatarStaminaStepRsp {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(bool, tag = "2")]
    pub use_client_rot: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(212)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityMoveNotify {
    #[prost(message, optional, tag = "1")]
    pub motion_info: ::core::option::Option<MotionInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_time: u32,
    #[prost(uint32, tag = "3")]
    pub reliable_seq: u32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VehicleLocationInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(float, tag = "4")]
    pub cur_hp: f32,
    #[prost(uint32, tag = "5")]
    pub entity_id: u32,
    #[prost(float, tag = "6")]
    pub max_hp: f32,
    #[prost(uint32, tag = "7")]
    pub owner_uid: u32,
    #[prost(uint32, tag = "8")]
    pub gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(213)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayerLocationNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_loc_list: ::prost::alloc::vec::Vec<PlayerLocationInfo>,
    #[prost(message, repeated, tag = "2")]
    pub vehicle_loc_list: ::prost::alloc::vec::Vec<VehicleLocationInfo>,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(214)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetScenePointReq {
    #[prost(bool, tag = "1")]
    pub is_relogin: bool,
    #[prost(uint32, tag = "2")]
    pub belong_uid: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CityInfo {
    #[prost(uint32, tag = "1")]
    pub crystal_num: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(215)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScenePointRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub not_explored_dungeon_entry_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub to_be_explore_dungeon_entry_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub hide_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub not_interact_dungeon_entry_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub group_unlimit_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "6")]
    pub unhide_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "7")]
    pub unlock_area_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "8")]
    pub locked_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "9")]
    pub unlocked_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "10")]
    pub retcode: i32,
    #[prost(uint32, tag = "11")]
    pub belong_uid: u32,
    #[prost(uint32, tag = "12")]
    pub scene_id: u32,
    #[prost(bool, tag = "13")]
    pub is_relogin: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(216)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterTransPointRegionNotify {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(217)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitTransPointRegionNotify {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(218)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePointUnlockNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub unhide_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub locked_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub hide_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(219)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneTransToPointReq {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(220)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneTransToPointRsp {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(221)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityJumpNotify {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(enumeration = "EntityJumpNotifyType", tag = "4")]
    pub jump_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(222)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSceneAreaReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub belong_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(223)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSceneAreaRsp {
    #[prost(message, repeated, tag = "1")]
    pub city_info_list: ::prost::alloc::vec::Vec<CityInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub area_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(224)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneAreaUnlockNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub area_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(225)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneEntityDrownReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(226)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneEntityDrownRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(227)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneCreateEntityReq {
    #[prost(message, optional, tag = "1")]
    pub entity: ::core::option::Option<CreateEntityInfo>,
    #[prost(bool, tag = "2")]
    pub is_destroy_when_disconnect: bool,
    #[prost(enumeration = "CreateReason", tag = "3")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(228)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneCreateEntityRsp {
    #[prost(message, optional, tag = "1")]
    pub entity: ::core::option::Option<CreateEntityInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(229)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneDestroyEntityReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(230)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneDestroyEntityRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(231)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneForceUnlockNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub force_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_add: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(232)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneForceLockNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub force_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(233)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterWorldAreaReq {
    #[prost(uint32, tag = "1")]
    pub area_type: u32,
    #[prost(uint32, tag = "2")]
    pub area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(234)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterWorldAreaRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub area_type: u32,
    #[prost(uint32, tag = "3")]
    pub area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(235)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityForceSyncReq {
    #[prost(message, optional, tag = "1")]
    pub motion_info: ::core::option::Option<MotionInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_time: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(236)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityForceSyncRsp {
    #[prost(message, optional, tag = "1")]
    pub fail_motion: ::core::option::Option<MotionInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub scene_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(237)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAreaExplorePointReq {
    #[prost(uint32, repeated, tag = "1")]
    pub area_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(238)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAreaExplorePointRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub area_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub explore_point_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(239)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientTransmitReq {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(enumeration = "TransmitReason", tag = "3")]
    pub reason: i32,
    #[prost(uint32, tag = "4")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(240)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientTransmitRsp {
    #[prost(enumeration = "TransmitReason", tag = "1")]
    pub reason: i32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(241)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterSceneWeatherAreaNotify {
    #[prost(uint32, tag = "1")]
    pub weather_gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(242)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExitSceneWeatherAreaNotify {
    #[prost(uint32, tag = "1")]
    pub weather_gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(243)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneAreaWeatherNotify {
    #[prost(map = "uint32, string", tag = "1")]
    pub weather_value_map: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
    #[prost(float, tag = "2")]
    pub trans_duration: f32,
    #[prost(uint32, tag = "3")]
    pub weather_gadget_id: u32,
    #[prost(uint32, tag = "4")]
    pub weather_area_id: u32,
    #[prost(uint32, tag = "5")]
    pub climate_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayerInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub online_player_info: ::core::option::Option<OnlinePlayerInfo>,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
    #[prost(uint32, tag = "4")]
    pub peer_id: u32,
    #[prost(bool, tag = "5")]
    pub is_connected: bool,
    #[prost(uint32, tag = "6")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(244)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayerInfoNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<ScenePlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLocationInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerWorldLocationInfo {
    #[prost(message, optional, tag = "1")]
    pub player_loc: ::core::option::Option<PlayerLocationInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(245)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldPlayerLocationNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_loc_list: ::prost::alloc::vec::Vec<PlayerLocationInfo>,
    #[prost(message, repeated, tag = "2")]
    pub player_world_loc_list: ::prost::alloc::vec::Vec<PlayerWorldLocationInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(246)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginCameraSceneLookNotify {
    #[prost(message, optional, tag = "1")]
    pub follow_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub look_pos: ::core::option::Option<Vector>,
    #[prost(string, repeated, tag = "3")]
    pub other_params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub blend_type: u32,
    #[prost(bool, tag = "5")]
    pub is_allow_input: bool,
    #[prost(bool, tag = "6")]
    pub is_set_screen_xy: bool,
    #[prost(bool, tag = "7")]
    pub is_abs_follow_pos: bool,
    #[prost(bool, tag = "8")]
    pub is_set_follow_pos: bool,
    #[prost(enumeration = "KeepRotType", tag = "9")]
    pub keep_rot_type: i32,
    #[prost(float, tag = "10")]
    pub screen_y: f32,
    #[prost(float, tag = "11")]
    pub custom_radius: f32,
    #[prost(uint32, tag = "12")]
    pub disable_protect: u32,
    #[prost(float, tag = "13")]
    pub screen_x: f32,
    #[prost(uint32, tag = "14")]
    pub entity_id: u32,
    #[prost(bool, tag = "15")]
    pub is_force: bool,
    #[prost(bool, tag = "16")]
    pub is_change_play_mode: bool,
    #[prost(bool, tag = "17")]
    pub is_recover_keep_current: bool,
    #[prost(bool, tag = "18")]
    pub is_force_walk: bool,
    #[prost(float, tag = "19")]
    pub duration: f32,
    #[prost(float, tag = "20")]
    pub blend_duration: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(247)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndCameraSceneLookNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(248)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarkEntityInMinMapNotify {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub monster_id: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(249)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnmarkEntityInMinMapNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(250)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteGroupTriggerReq {
    #[prost(string, tag = "1")]
    pub source_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub source_entity_id: u32,
    #[prost(int32, tag = "3")]
    pub param1: i32,
    #[prost(int32, tag = "4")]
    pub param2: i32,
    #[prost(uint32, tag = "5")]
    pub target_entity_id: u32,
    #[prost(int32, tag = "6")]
    pub param3: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(251)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteGroupTriggerRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(252)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LevelupCityReq {
    #[prost(uint32, tag = "1")]
    pub area_id: u32,
    #[prost(uint32, tag = "2")]
    pub item_num: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(253)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LevelupCityRsp {
    #[prost(message, optional, tag = "1")]
    pub city_info: ::core::option::Option<CityInfo>,
    #[prost(uint32, tag = "2")]
    pub area_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoutePointChangeInfo {
    #[prost(float, tag = "1")]
    pub wait_time: f32,
    #[prost(uint32, tag = "2")]
    pub point_index: u32,
    #[prost(float, tag = "3")]
    pub target_velocity: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneRouteChangeInfo {
    #[prost(message, repeated, tag = "1")]
    pub point_list: ::prost::alloc::vec::Vec<RoutePointChangeInfo>,
    #[prost(uint32, tag = "2")]
    pub route_id: u32,
    #[prost(bool, tag = "3")]
    pub is_forward: bool,
    #[prost(uint32, tag = "4")]
    pub r#type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(254)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneRouteChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub route_list: ::prost::alloc::vec::Vec<SceneRouteChangeInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_time: u32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(255)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformStartRouteNotify {
    #[prost(message, optional, tag = "1")]
    pub platform: ::core::option::Option<PlatformInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_time: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(256)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformStopRouteNotify {
    #[prost(message, optional, tag = "1")]
    pub platform: ::core::option::Option<PlatformInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_time: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(257)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformChangeRouteNotify {
    #[prost(message, optional, tag = "1")]
    pub platform: ::core::option::Option<PlatformInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_time: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(258)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayerSoundNotify {
    #[prost(string, tag = "1")]
    pub sound_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub play_pos: ::core::option::Option<Vector>,
    #[prost(enumeration = "PlaySoundType", tag = "3")]
    pub play_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(259)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonalSceneJumpReq {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(260)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonalSceneJumpRsp {
    #[prost(message, optional, tag = "1")]
    pub dest_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub dest_scene_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(261)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SealBattleBeginNotify {
    #[prost(enumeration = "SealBattleType", tag = "1")]
    pub battle_type: i32,
    #[prost(uint32, tag = "2")]
    pub seal_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub seal_max_progress: u32,
    #[prost(uint32, tag = "4")]
    pub seal_radius: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(262)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SealBattleEndNotify {
    #[prost(bool, tag = "1")]
    pub is_win: bool,
    #[prost(uint32, tag = "2")]
    pub seal_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(263)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SealBattleProgressNotify {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
    #[prost(uint32, tag = "2")]
    pub progress: u32,
    #[prost(uint32, tag = "3")]
    pub seal_entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub max_progress: u32,
    #[prost(uint32, tag = "5")]
    pub seal_radius: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(264)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientPauseNotify {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarEnterSceneInfo {
    #[prost(message, repeated, tag = "1")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(uint32, repeated, tag = "2")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "3")]
    pub avatar_ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(message, optional, tag = "4")]
    pub weapon_ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(uint64, tag = "5")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "6")]
    pub avatar_entity_id: u32,
    #[prost(uint32, tag = "7")]
    pub weapon_entity_id: u32,
    #[prost(uint64, tag = "8")]
    pub weapon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamEnterSceneInfo {
    #[prost(message, optional, tag = "1")]
    pub team_ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(message, optional, tag = "2")]
    pub ability_control_block: ::core::option::Option<AbilityControlBlock>,
    #[prost(uint32, tag = "3")]
    pub team_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MpLevelEntityInfo {
    #[prost(message, optional, tag = "1")]
    pub ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub authority_peer_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(265)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerEnterSceneInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub team_enter_info: ::core::option::Option<TeamEnterSceneInfo>,
    #[prost(message, optional, tag = "2")]
    pub mp_level_entity_info: ::core::option::Option<MpLevelEntityInfo>,
    #[prost(message, repeated, tag = "3")]
    pub avatar_enter_info: ::prost::alloc::vec::Vec<AvatarEnterSceneInfo>,
    #[prost(uint32, tag = "4")]
    pub cur_avatar_entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub enter_scene_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(266)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JoinPlayerSceneReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(267)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JoinPlayerSceneRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(268)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneKickPlayerReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(269)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneKickPlayerRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(270)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneKickPlayerNotify {
    #[prost(uint32, tag = "1")]
    pub kicker_uid: u32,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(271)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HitClientTrivialNotify {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub owner_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(272)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackMyWorldReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(273)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackMyWorldRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(274)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeeMonsterReq {
    #[prost(uint32, tag = "1")]
    pub monster_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(275)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeeMonsterRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(276)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddSeenMonsterNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub monster_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(277)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllSeenMonsterNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub monster_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(278)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneTimeNotify {
    #[prost(bool, tag = "1")]
    pub is_paused: bool,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint64, tag = "3")]
    pub scene_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(279)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterSceneReadyReq {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(280)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterSceneReadyRsp {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(281)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterScenePeerNotify {
    #[prost(uint32, tag = "1")]
    pub dest_scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub enter_scene_token: u32,
    #[prost(uint32, tag = "3")]
    pub peer_id: u32,
    #[prost(uint32, tag = "4")]
    pub host_peer_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(282)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterSceneDoneReq {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(283)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterSceneDoneRsp {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(284)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldPlayerDieNotify {
    #[prost(enumeration = "PlayerDieType", tag = "1")]
    pub die_type: i32,
    #[prost(uint32, tag = "2")]
    pub murderer_entity_id: u32,
    #[prost(oneof = "world_player_die_notify::Entity", tags = "3, 4")]
    pub entity: ::core::option::Option<world_player_die_notify::Entity>,
}
/// Nested message and enum types in `WorldPlayerDieNotify`.
pub mod world_player_die_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Entity {
        #[prost(uint32, tag = "3")]
        MonsterId(u32),
        #[prost(uint32, tag = "4")]
        GadgetId(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(285)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldPlayerReviveReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(286)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldPlayerReviveRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(287)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JoinPlayerFailNotify {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(288)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSceneWeatherAreaReq {
    #[prost(map = "uint32, string", tag = "1")]
    pub weather_value_map: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
    #[prost(uint32, tag = "2")]
    pub weather_gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(289)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetSceneWeatherAreaRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(290)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteGadgetLuaReq {
    #[prost(int32, tag = "1")]
    pub param3: i32,
    #[prost(int32, tag = "2")]
    pub param2: i32,
    #[prost(uint32, tag = "3")]
    pub source_entity_id: u32,
    #[prost(int32, tag = "4")]
    pub param1: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(291)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteGadgetLuaRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutSceneExtraParam {
    #[prost(double, repeated, tag = "1")]
    pub detail_param_list: ::prost::alloc::vec::Vec<f64>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(292)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutSceneBeginNotify {
    #[prost(message, repeated, tag = "1")]
    pub extra_param_list: ::prost::alloc::vec::Vec<CutSceneExtraParam>,
    #[prost(bool, tag = "2")]
    pub is_wait_others: bool,
    #[prost(uint32, tag = "3")]
    pub cutscene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(353)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CutSceneFinishNotify {
    #[prost(uint32, tag = "1")]
    pub cutscene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(293)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CutSceneEndNotify {
    #[prost(uint32, tag = "1")]
    pub cutscene_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(294)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientScriptEventNotify {
    #[prost(int32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "2")]
    pub event_type: u32,
    #[prost(uint32, tag = "3")]
    pub target_entity_id: u32,
    #[prost(uint32, tag = "4")]
    pub source_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(295)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntitiesMovesReq {
    #[prost(message, repeated, tag = "1")]
    pub entity_move_info_list: ::prost::alloc::vec::Vec<EntityMoveInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMoveFailInfo {
    #[prost(message, optional, tag = "1")]
    pub fail_motion: ::core::option::Option<MotionInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub reliable_seq: u32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub scene_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(296)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntitiesMovesRsp {
    #[prost(message, repeated, tag = "1")]
    pub entity_move_fail_info_list: ::prost::alloc::vec::Vec<EntityMoveFailInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3001)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntitiesMoveCombineNotify {
    #[prost(message, repeated, tag = "1")]
    pub entity_move_info_list: ::prost::alloc::vec::Vec<EntityMoveInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockTransPointReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockTransPointRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneWeatherForecastReq {
    #[prost(uint32, tag = "1")]
    pub weather_area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3003)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneWeatherForecastRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub forecast_climate_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub next_climate_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkMapReq {
    #[prost(message, optional, tag = "1")]
    pub mark: ::core::option::Option<MapMarkPoint>,
    #[prost(message, optional, tag = "2")]
    pub old: ::core::option::Option<MapMarkPoint>,
    #[prost(enumeration = "Operation", tag = "3")]
    pub op: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3203)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkMapRsp {
    #[prost(message, repeated, tag = "1")]
    pub mark_list: ::prost::alloc::vec::Vec<MapMarkPoint>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3004)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllMarkPointNotify {
    #[prost(message, repeated, tag = "1")]
    pub mark_list: ::prost::alloc::vec::Vec<MapMarkPoint>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3401)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldDataNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub world_prop_map: ::std::collections::HashMap<u32, PropValue>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3204)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityMoveRoomNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub dest_room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3302)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldPlayerInfoNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub player_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub player_widget_info_list: ::prost::alloc::vec::Vec<PlayerWidgetInfo>,
    #[prost(message, repeated, tag = "3")]
    pub player_info_list: ::prost::alloc::vec::Vec<OnlinePlayerInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PostEnterSceneReq {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3402)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PostEnterSceneRsp {
    #[prost(uint32, tag = "1")]
    pub enter_scene_token: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub time: u32,
    #[prost(bool, tag = "3")]
    pub is_read: bool,
    #[prost(uint32, tag = "4")]
    pub sequence: u32,
    #[prost(uint32, tag = "5")]
    pub to_uid: u32,
    #[prost(oneof = "chat_info::Content", tags = "6, 7, 8")]
    pub content: ::core::option::Option<chat_info::Content>,
}
/// Nested message and enum types in `ChatInfo`.
pub mod chat_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(string, tag = "6")]
        Text(::prost::alloc::string::String),
        #[prost(uint32, tag = "7")]
        Icon(u32),
        #[prost(message, tag = "8")]
        SystemHint(super::SystemHint),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemHint {
    #[prost(uint32, tag = "1")]
    pub r#type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3303)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerChatReq {
    #[prost(message, optional, tag = "1")]
    pub chat_info: ::core::option::Option<ChatInfo>,
    #[prost(uint32, tag = "2")]
    pub channel_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3304)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerChatRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub chat_forbidden_endtime: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3206)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerChatNotify {
    #[prost(message, optional, tag = "1")]
    pub chat_info: ::core::option::Option<ChatInfo>,
    #[prost(uint32, tag = "2")]
    pub channel_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerChatCdNotify {
    #[prost(uint32, tag = "1")]
    pub over_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatHistoryNotify {
    #[prost(message, repeated, tag = "1")]
    pub chat_info: ::prost::alloc::vec::Vec<ChatInfo>,
    #[prost(uint32, tag = "2")]
    pub channel_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3305)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub scene_tag_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, repeated, tag = "2")]
    pub level_config_name_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3306)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonEntryToBeExploreNotify {
    #[prost(uint32, tag = "1")]
    pub dungeon_entry_config_id: u32,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_entry_scene_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDungeonEntryExploreConditionReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub dungeon_entry_config_id: u32,
    #[prost(uint32, tag = "3")]
    pub dungeon_entry_scene_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DungeonEntryCond {
    #[prost(uint32, tag = "1")]
    pub param1: u32,
    #[prost(enumeration = "DungeonEntryBlockReason", tag = "2")]
    pub cond_reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDungeonEntryExploreConditionRsp {
    #[prost(message, optional, tag = "1")]
    pub dungeon_entry_cond: ::core::option::Option<DungeonEntryCond>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3403)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnfreezeGroupLimitNotify {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEntityClientDataNotify {
    #[prost(message, optional, tag = "1")]
    pub entity_client_data: ::core::option::Option<EntityClientData>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3208)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupSuiteNotify {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub group_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3308)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupUnloadNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub group_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MonsterAiConfigHashNotify {
    #[prost(uint32, tag = "1")]
    pub job_id: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(int32, tag = "3")]
    pub hash_value: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3005)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowTemplateReminderNotify {
    #[prost(int32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "2")]
    pub param_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_revoke: bool,
    #[prost(bool, tag = "4")]
    pub is_need_cache: bool,
    #[prost(uint32, tag = "5")]
    pub template_reminder_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3404)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowCommonTipsNotify {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub close_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3006)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CloseCommonTipsNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeWorldToSingleModeNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3405)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncScenePlayTeamEntityNotify {
    #[prost(message, repeated, tag = "1")]
    pub entity_info_list: ::prost::alloc::vec::Vec<PlayTeamEntityInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3406)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelScenePlayTeamEntityNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub del_entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CylinderRegionSize {
    #[prost(float, tag = "1")]
    pub radius: f32,
    #[prost(float, tag = "2")]
    pub height: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolygonRegionSize {
    #[prost(message, repeated, tag = "1")]
    pub point_list: ::prost::alloc::vec::Vec<VectorPlane>,
    #[prost(float, tag = "2")]
    pub height: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3309)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerEyePointStateNotify {
    #[prost(message, optional, tag = "1")]
    pub eye_point_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub region_config_id: u32,
    #[prost(uint32, tag = "3")]
    pub region_shape: u32,
    #[prost(bool, tag = "4")]
    pub is_use_eye_point: bool,
    #[prost(bool, tag = "5")]
    pub is_filter_stream_pos: bool,
    #[prost(uint32, tag = "6")]
    pub region_entity_id: u32,
    #[prost(uint32, tag = "7")]
    pub region_group_id: u32,
    #[prost(int32, tag = "8")]
    pub fix_lod_level: i32,
    #[prost(oneof = "player_eye_point_state_notify::RegionSize", tags = "9, 10, 11, 12")]
    pub region_size: ::core::option::Option<player_eye_point_state_notify::RegionSize>,
}
/// Nested message and enum types in `PlayerEyePointStateNotify`.
pub mod player_eye_point_state_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RegionSize {
        #[prost(float, tag = "9")]
        SphereRadius(f32),
        #[prost(message, tag = "10")]
        CubicSize(super::Vector),
        #[prost(message, tag = "11")]
        CylinderSize(super::CylinderRegionSize),
        #[prost(message, tag = "12")]
        PolygonSize(super::PolygonRegionSize),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3007)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMapMarkTipsReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3008)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMapMarkTipsRsp {
    #[prost(message, repeated, tag = "1")]
    pub mark_tips_list: ::prost::alloc::vec::Vec<MapMarkTipsInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeWorldToSingleModeReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeWorldToSingleModeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub quit_mp_valid_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWorldMpInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWorldMpInfoRsp {
    #[prost(bool, tag = "1")]
    pub is_in_mp_mode: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub quit_mp_valid_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityConfigHashEntry {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(int32, tag = "2")]
    pub hash_value: i32,
    #[prost(uint32, tag = "3")]
    pub job_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3106)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityConfigHashNotify {
    #[prost(message, repeated, tag = "1")]
    pub combat_entry_list: ::prost::alloc::vec::Vec<EntityConfigHashEntry>,
    #[prost(message, repeated, tag = "2")]
    pub ability_entry_list: ::prost::alloc::vec::Vec<EntityConfigHashEntry>,
    #[prost(message, repeated, tag = "3")]
    pub avatar_entry_list: ::prost::alloc::vec::Vec<EntityConfigHashEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3009)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceDragAvatarNotify {
    #[prost(message, optional, tag = "1")]
    pub motion_info: ::core::option::Option<MotionInfo>,
    #[prost(uint64, tag = "2")]
    pub delta_time_ms: u64,
    #[prost(bool, tag = "3")]
    pub is_first_valid: bool,
    #[prost(uint64, tag = "4")]
    pub last_move_time_ms: u64,
    #[prost(uint32, tag = "5")]
    pub scene_time: u32,
    #[prost(uint32, tag = "6")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3010)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterPointArrayRouteUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub monster_route: ::core::option::Option<MonsterRoute>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3408)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForceDragBackTransferNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3312)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetScenePerformanceReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3011)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetScenePerformanceRsp {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub gather_num: u32,
    #[prost(uint32, tag = "3")]
    pub group_num: u32,
    #[prost(uint32, tag = "4")]
    pub entity_num: u32,
    #[prost(uint32, tag = "5")]
    pub monster_num: u32,
    #[prost(uint32, tag = "6")]
    pub gather_num_insight: u32,
    #[prost(int32, tag = "7")]
    pub retcode: i32,
    #[prost(uint32, tag = "8")]
    pub gadget_num: u32,
    #[prost(uint32, tag = "9")]
    pub dynamic_group_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3107)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneAudioNotify {
    #[prost(float, repeated, tag = "1")]
    pub param2: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, repeated, tag = "2")]
    pub param1: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, repeated, tag = "3")]
    pub param3: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub source_uid: u32,
    #[prost(int32, tag = "5")]
    pub r#type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HitTreeNotify {
    #[prost(message, optional, tag = "1")]
    pub tree_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub drop_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub tree_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3012)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityTagChangeNotify {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(bool, tag = "3")]
    pub is_add: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3108)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarFollowRouteNotify {
    #[prost(message, optional, tag = "1")]
    pub route: ::core::option::Option<Route>,
    #[prost(string, tag = "2")]
    pub client_params: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub start_scene_time_ms: u32,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub template_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3313)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub entity_list: ::prost::alloc::vec::Vec<SceneEntityInfo>,
    #[prost(enumeration = "VisionType", tag = "2")]
    pub appear_type: i32,
    #[prost(uint32, tag = "3")]
    pub param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3013)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientHashDebugNotify {
    #[prost(uint32, tag = "1")]
    pub job_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerWorldSceneInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub scene_tag_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_locked: bool,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3410)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerWorldSceneInfoListNotify {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<PlayerWorldSceneInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3411)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LuaEnvironmentEffectNotify {
    #[prost(string, tag = "1")]
    pub effect_alias: ::prost::alloc::string::String,
    #[prost(float, repeated, tag = "2")]
    pub float_param_list: ::prost::alloc::vec::Vec<f32>,
    #[prost(int32, repeated, tag = "3")]
    pub int_param_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "4")]
    pub r#type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3314)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientLoadingCostumeVerificationNotify {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(uint32, tag = "2")]
    pub costume_id: u32,
    #[prost(uint64, tag = "3")]
    pub prefab_hash: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3315)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowClientGuideNotify {
    #[prost(string, tag = "1")]
    pub guide_name: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3109)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShowClientTutorialNotify {
    #[prost(uint32, tag = "1")]
    pub tutorial_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3316)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMapAreaReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3317)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMapAreaRsp {
    #[prost(message, repeated, tag = "1")]
    pub map_area_info_list: ::prost::alloc::vec::Vec<MapAreaInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3110)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapAreaChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub map_area_info_list: ::prost::alloc::vec::Vec<MapAreaInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeaveWorldNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3014)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GuestBeginEnterSceneNotify {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3112)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GuestPostEnterSceneNotify {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3318)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LevelTagDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub level_tag_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3319)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopReminderNotify {
    #[prost(uint32, tag = "1")]
    pub reminder_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3113)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AreaPlayInfoNotify {
    #[prost(uint32, tag = "1")]
    pub detail_play_type: u32,
    #[prost(enumeration = "AreaPlayType", tag = "2")]
    pub area_play_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3320)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroupReplacedReq {
    #[prost(uint32, repeated, tag = "1")]
    pub group_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3210)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroupReplacedRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub replaced_group_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeathZoneObserveNotify {
    #[prost(uint32, tag = "1")]
    pub source_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub target_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HitTreeInfo {
    #[prost(message, optional, tag = "1")]
    pub tree_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub tree_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3015)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorldChestOpenNotify {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3413)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetQuickHitTreeReq {
    #[prost(message, repeated, tag = "1")]
    pub hit_tree_info_list: ::prost::alloc::vec::Vec<HitTreeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3016)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetQuickHitTreeRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3414)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginCameraSceneLookWithTemplateNotify {
    #[prost(message, optional, tag = "1")]
    pub look_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub follow_pos: ::core::option::Option<Vector>,
    #[prost(string, repeated, tag = "3")]
    pub other_params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub template_id: u32,
    #[prost(enumeration = "FollowType", tag = "5")]
    pub follow_type: i32,
    #[prost(uint32, tag = "6")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3017)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshEntityAuthNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub entity_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3211)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayerBackgroundAvatarRefreshNotify {
    #[prost(message, repeated, tag = "1")]
    pub entity_list: ::prost::alloc::vec::Vec<SceneEntityInfo>,
    #[prost(uint32, tag = "2")]
    pub param: u32,
    #[prost(enumeration = "VisionType", tag = "3")]
    pub appear_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3018)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ooghegijmld {
    #[prost(uint32, repeated, tag = "1")]
    pub scene_tag_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub source_scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(3114)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisplayGroupRegionNotify {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub shape: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub config_id: u32,
    #[prost(oneof = "display_group_region_notify::RegionSize", tags = "5, 6, 7, 8")]
    pub region_size: ::core::option::Option<display_group_region_notify::RegionSize>,
}
/// Nested message and enum types in `DisplayGroupRegionNotify`.
pub mod display_group_region_notify {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RegionSize {
        #[prost(float, tag = "5")]
        SphereRadius(f32),
        #[prost(message, tag = "6")]
        CubicSize(super::Vector),
        #[prost(message, tag = "7")]
        CylinderSize(super::CylinderRegionSize),
        #[prost(message, tag = "8")]
        PolygonSize(super::PolygonRegionSize),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub progress_stage_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub mode: u32,
    #[prost(uint32, tag = "3")]
    pub play_type: u32,
    #[prost(uint32, tag = "4")]
    pub r#type: u32,
    #[prost(uint32, tag = "5")]
    pub play_id: u32,
    #[prost(uint32, tag = "6")]
    pub progress: u32,
    #[prost(uint32, tag = "7")]
    pub start_time: u32,
    #[prost(uint32, tag = "8")]
    pub prepare_end_time: u32,
    #[prost(uint32, tag = "9")]
    pub duration: u32,
    #[prost(uint32, tag = "10")]
    pub state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4418)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub battle_info: ::core::option::Option<ScenePlayBattleInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4419)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayOwnerCheckReq {
    #[prost(bool, tag = "1")]
    pub is_skip_match: bool,
    #[prost(uint32, tag = "2")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4315)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayOwnerCheckRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub play_id: u32,
    #[prost(bool, tag = "3")]
    pub is_skip_match: bool,
    #[prost(uint32, tag = "4")]
    pub wrong_uid: u32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4420)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayOwnerStartInviteReq {
    #[prost(bool, tag = "1")]
    pub is_skip_match: bool,
    #[prost(uint32, tag = "2")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4421)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayOwnerStartInviteRsp {
    #[prost(bool, tag = "1")]
    pub is_skip_match: bool,
    #[prost(uint32, tag = "2")]
    pub play_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4316)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayOwnerInviteNotify {
    #[prost(uint32, tag = "1")]
    pub play_id: u32,
    #[prost(uint32, tag = "2")]
    pub invite_cd: u32,
    #[prost(bool, tag = "3")]
    pub is_remain_reward: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4422)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayGuestReplyInviteReq {
    #[prost(uint32, tag = "1")]
    pub play_id: u32,
    #[prost(bool, tag = "2")]
    pub is_agree: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4317)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayGuestReplyInviteRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_agree: bool,
    #[prost(uint32, tag = "3")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4423)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayGuestReplyNotify {
    #[prost(bool, tag = "1")]
    pub is_agree: bool,
    #[prost(uint32, tag = "2")]
    pub guest_uid: u32,
    #[prost(uint32, tag = "3")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4318)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayInviteResultNotify {
    #[prost(bool, tag = "1")]
    pub is_all_agree: bool,
    #[prost(uint32, tag = "2")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayInfo {
    #[prost(uint32, tag = "1")]
    pub play_type: u32,
    #[prost(uint32, tag = "2")]
    pub entry_id: u32,
    #[prost(uint32, tag = "3")]
    pub play_id: u32,
    #[prost(bool, tag = "4")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4424)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayInfoListNotify {
    #[prost(message, repeated, tag = "1")]
    pub play_info_list: ::prost::alloc::vec::Vec<ScenePlayInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4425)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleInterruptNotify {
    #[prost(uint32, tag = "1")]
    pub play_type: u32,
    #[prost(uint32, tag = "2")]
    pub interrupt_state: u32,
    #[prost(uint32, tag = "3")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleSettlePlayerInfo {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "3")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub card_list: ::prost::alloc::vec::Vec<ExhibitionDisplayInfo>,
    #[prost(uint32, tag = "5")]
    pub uid: u32,
    #[prost(uint32, tag = "6")]
    pub head_image: u32,
    #[prost(uint32, tag = "7")]
    pub statistic_id: u32,
    #[prost(int64, tag = "8")]
    pub param: i64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleSettleRewardInfo {
    #[prost(message, repeated, tag = "1")]
    pub reward_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4319)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleResultNotify {
    #[prost(message, repeated, tag = "1")]
    pub settle_reward_info_list: ::prost::alloc::vec::Vec<
        ScenePlayBattleSettleRewardInfo,
    >,
    #[prost(message, repeated, tag = "2")]
    pub settle_player_info_list: ::prost::alloc::vec::Vec<
        ScenePlayBattleSettlePlayerInfo,
    >,
    #[prost(uint32, tag = "3")]
    pub play_id: u32,
    #[prost(bool, tag = "4")]
    pub is_win: bool,
    #[prost(uint32, tag = "5")]
    pub cost_time: u32,
    #[prost(uint32, tag = "6")]
    pub play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4320)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleUidOpNotify {
    #[prost(string, tag = "1")]
    pub param_str: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "2")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub param_target_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub entity_id: u32,
    #[prost(uint32, tag = "6")]
    pub play_id: u32,
    #[prost(uint32, tag = "7")]
    pub param_duration: u32,
    #[prost(uint32, tag = "8")]
    pub param_index: u32,
    #[prost(uint32, tag = "9")]
    pub op: u32,
    #[prost(uint32, tag = "10")]
    pub play_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4426)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePlayBattleInfoListNotify {
    #[prost(message, repeated, tag = "1")]
    pub battle_info_list: ::prost::alloc::vec::Vec<ScenePlayBattleInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4321)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePlayOutofRegionNotify {
    #[prost(uint32, tag = "1")]
    pub play_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShareCdInfo {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(uint32, tag = "2")]
    pub share_cd_id: u32,
    #[prost(uint64, tag = "3")]
    pub cd_start_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9001)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllShareCdDataNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub share_cd_info_map: ::std::collections::HashMap<u32, ShareCdInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopGoods {
    #[prost(message, optional, tag = "1")]
    pub goods_item: ::core::option::Option<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub cost_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, repeated, tag = "3")]
    pub pre_goods_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub secondary_sheet_id: u32,
    #[prost(uint32, tag = "5")]
    pub bought_num: u32,
    #[prost(uint32, tag = "6")]
    pub max_level: u32,
    #[prost(uint32, tag = "7")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "8")]
    pub discount_end_time: u32,
    #[prost(uint32, tag = "9")]
    pub min_level: u32,
    #[prost(uint32, tag = "10")]
    pub disable_type: u32,
    #[prost(uint32, tag = "11")]
    pub discount_begin_time: u32,
    #[prost(uint32, tag = "12")]
    pub mcoin: u32,
    #[prost(uint32, tag = "13")]
    pub end_time: u32,
    #[prost(uint32, tag = "14")]
    pub goods_id: u32,
    #[prost(uint32, tag = "15")]
    pub hcoin: u32,
    #[prost(uint32, tag = "16")]
    pub begin_time: u32,
    #[prost(uint32, tag = "17")]
    pub single_limit: u32,
    #[prost(uint32, tag = "18")]
    pub discount_id: u32,
    #[prost(uint32, tag = "19")]
    pub buy_limit: u32,
    #[prost(uint32, tag = "20")]
    pub scoin: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shop {
    #[prost(message, repeated, tag = "1")]
    pub goods_list: ::prost::alloc::vec::Vec<ShopGoods>,
    #[prost(message, repeated, tag = "2")]
    pub mcoin_product_list: ::prost::alloc::vec::Vec<ShopMcoinProduct>,
    #[prost(message, repeated, tag = "3")]
    pub card_product_list: ::prost::alloc::vec::Vec<ShopCardProduct>,
    #[prost(message, repeated, tag = "4")]
    pub concert_product_list: ::prost::alloc::vec::Vec<ShopConcertProduct>,
    #[prost(uint32, tag = "5")]
    pub next_refresh_time: u32,
    #[prost(uint32, tag = "6")]
    pub shop_type: u32,
    #[prost(uint32, tag = "7")]
    pub city_reputation_level: u32,
    #[prost(uint32, tag = "8")]
    pub city_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(701)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetShopReq {
    #[prost(uint32, tag = "1")]
    pub shop_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(702)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShopRsp {
    #[prost(message, optional, tag = "1")]
    pub shop: ::core::option::Option<Shop>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(703)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuyGoodsReq {
    #[prost(message, optional, tag = "1")]
    pub goods: ::core::option::Option<ShopGoods>,
    #[prost(uint32, tag = "2")]
    pub shop_type: u32,
    #[prost(uint32, tag = "3")]
    pub buy_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(704)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuyGoodsRsp {
    #[prost(message, repeated, tag = "1")]
    pub goods_list: ::prost::alloc::vec::Vec<ShopGoods>,
    #[prost(message, optional, tag = "2")]
    pub goods: ::core::option::Option<ShopGoods>,
    #[prost(uint32, tag = "3")]
    pub buy_count: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub shop_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(705)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetShopmallDataReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(706)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShopmallDataRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub shop_type_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityShopSheetInfo {
    #[prost(uint32, tag = "1")]
    pub begin_time: u32,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
    #[prost(uint32, tag = "3")]
    pub sheet_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(707)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetActivityShopSheetInfoReq {
    #[prost(uint32, tag = "1")]
    pub shop_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(708)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActivityShopSheetInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub sheet_info_list: ::prost::alloc::vec::Vec<ActivityShopSheetInfo>,
    #[prost(uint32, tag = "2")]
    pub shop_type: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuyGoodsParam {
    #[prost(message, optional, tag = "1")]
    pub goods: ::core::option::Option<ShopGoods>,
    #[prost(uint32, tag = "2")]
    pub buy_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(709)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchBuyGoodsReq {
    #[prost(message, repeated, tag = "1")]
    pub buy_goods_list: ::prost::alloc::vec::Vec<BuyGoodsParam>,
    #[prost(uint32, tag = "2")]
    pub shop_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(710)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchBuyGoodsRsp {
    #[prost(message, repeated, tag = "1")]
    pub goods_list: ::prost::alloc::vec::Vec<ShopGoods>,
    #[prost(message, repeated, tag = "2")]
    pub buy_goods_list: ::prost::alloc::vec::Vec<BuyGoodsParam>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub shop_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpActivityTagBriefInfo {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(uint32, tag = "2")]
    pub op_activity_type: u32,
    #[prost(bool, tag = "3")]
    pub has_reward: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2501)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpActivityStateNotify {
    #[prost(message, repeated, tag = "1")]
    pub opened_op_activity_info_list: ::prost::alloc::vec::Vec<OpActivityTagBriefInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub finished_bonus_activity_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInData {
    #[prost(message, repeated, tag = "1")]
    pub reward_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, tag = "2")]
    pub day_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInInfo {
    #[prost(message, repeated, tag = "1")]
    pub signin_data_list: ::prost::alloc::vec::Vec<SignInData>,
    #[prost(uint32, repeated, tag = "2")]
    pub reward_day_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub begin_time: u32,
    #[prost(uint32, tag = "4")]
    pub schedule_id: u32,
    #[prost(bool, tag = "5")]
    pub is_cond_satisfied: bool,
    #[prost(uint32, tag = "6")]
    pub sign_in_count: u32,
    #[prost(uint32, tag = "7")]
    pub end_time: u32,
    #[prost(uint32, tag = "8")]
    pub last_sign_in_time: u32,
    #[prost(uint32, tag = "9")]
    pub config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2502)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignInInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2503)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub sign_in_info_list: ::prost::alloc::vec::Vec<SignInInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2504)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSignInRewardReq {
    #[prost(uint32, tag = "1")]
    pub reward_day: u32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2505)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSignInRewardRsp {
    #[prost(message, optional, tag = "1")]
    pub sign_in_info: ::core::option::Option<SignInInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BonusActivityInfo {
    #[prost(uint32, tag = "1")]
    pub bonus_activity_id: u32,
    #[prost(uint32, tag = "2")]
    pub state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2506)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BonusActivityUpdateNotify {
    #[prost(message, repeated, tag = "1")]
    pub bonus_activity_info_list: ::prost::alloc::vec::Vec<BonusActivityInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2507)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BonusActivityInfoReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2508)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BonusActivityInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub bonus_activity_info_list: ::prost::alloc::vec::Vec<BonusActivityInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2509)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBonusActivityRewardReq {
    #[prost(uint32, tag = "1")]
    pub bonus_activity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2510)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBonusActivityRewardRsp {
    #[prost(message, optional, tag = "1")]
    pub bonus_activity_info_list: ::core::option::Option<BonusActivityInfo>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockAvatarTalentReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub talent_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1002)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockAvatarTalentRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub talent_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarUnlockTalentNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "3")]
    pub skill_depot_id: u32,
    #[prost(uint32, tag = "4")]
    pub talent_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1004)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarSkillDepotChangeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub proud_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub skill_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub proud_skill_extra_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub talent_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, tag = "5")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "6")]
    pub entity_id: u32,
    #[prost(uint32, tag = "7")]
    pub skill_depot_id: u32,
    #[prost(uint32, tag = "8")]
    pub core_proud_skill_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1005)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigTalentPointConvertReq {
    #[prost(uint64, repeated, tag = "1")]
    pub item_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1006)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BigTalentPointConvertRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1007)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarSkillMaxChargeCountNotify {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub skill_id: u32,
    #[prost(uint32, tag = "3")]
    pub max_charge_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1008)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarSkillInfoNotify {
    #[prost(map = "uint32, message", tag = "1")]
    pub skill_map: ::std::collections::HashMap<u32, AvatarSkillInfo>,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1009)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProudSkillUpgradeReq {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub proud_skill_id: u32,
    #[prost(uint32, tag = "3")]
    pub old_proud_skill_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1010)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProudSkillUpgradeRsp {
    #[prost(uint32, tag = "1")]
    pub proud_skill_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1011)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProudSkillChangeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub proud_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub skill_depot_id: u32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
    #[prost(uint64, tag = "4")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1012)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarSkillUpgradeReq {
    #[prost(uint32, tag = "1")]
    pub old_level: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_skill_id: u32,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1013)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarSkillUpgradeRsp {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub cur_level: u32,
    #[prost(uint32, tag = "3")]
    pub old_level: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub avatar_skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1014)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarSkillChangeNotify {
    #[prost(uint64, tag = "1")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub old_level: u32,
    #[prost(uint32, tag = "4")]
    pub cur_level: u32,
    #[prost(uint32, tag = "5")]
    pub skill_depot_id: u32,
    #[prost(uint32, tag = "6")]
    pub avatar_skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1015)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProudSkillExtraLevelNotify {
    #[prost(uint32, tag = "1")]
    pub talent_type: u32,
    #[prost(uint32, tag = "2")]
    pub extra_level: u32,
    #[prost(uint32, tag = "3")]
    pub talent_index: u32,
    #[prost(uint64, tag = "4")]
    pub avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1016)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CanUseSkillNotify {
    #[prost(bool, tag = "1")]
    pub is_can_use_skill: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarTeamResonanceInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub del_team_resonance_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub add_team_resonance_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, tag = "3")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "4")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(1017)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamResonanceChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub info_list: ::prost::alloc::vec::Vec<AvatarTeamResonanceInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SocialShowAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "3")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocialDetail {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "2")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ip_code: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub show_avatar_info_list: ::prost::alloc::vec::Vec<SocialShowAvatarInfo>,
    #[prost(uint32, repeated, tag = "7")]
    pub show_name_card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "8")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub birthday: ::core::option::Option<Birthday>,
    #[prost(uint32, repeated, tag = "10")]
    pub reserved_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "11")]
    pub param: u32,
    #[prost(uint32, tag = "12")]
    pub tower_floor_index: u32,
    #[prost(uint32, tag = "13")]
    pub finish_achievement_num: u32,
    #[prost(uint32, tag = "14")]
    pub name_card_id: u32,
    #[prost(bool, tag = "15")]
    pub is_friend: bool,
    #[prost(bool, tag = "16")]
    pub is_in_blacklist: bool,
    #[prost(bool, tag = "17")]
    pub is_chat_no_disturb: bool,
    #[prost(bool, tag = "18")]
    pub is_show_avatar: bool,
    #[prost(uint32, tag = "19")]
    pub level: u32,
    #[prost(uint32, tag = "20")]
    pub tower_level_index: u32,
    #[prost(bool, tag = "21")]
    pub is_mp_mode_available: bool,
    #[prost(enumeration = "FriendEnterHomeOption", tag = "22")]
    pub friend_enter_home_option: i32,
    #[prost(uint32, tag = "23")]
    pub world_level: u32,
    #[prost(enumeration = "FriendOnlineState", tag = "24")]
    pub online_state: i32,
    #[prost(uint32, tag = "25")]
    pub uid: u32,
    #[prost(uint32, tag = "26")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FriendBrief {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub show_avatar_info_list: ::prost::alloc::vec::Vec<SocialShowAvatarInfo>,
    #[prost(string, tag = "4")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(uint32, tag = "7")]
    pub level: u32,
    #[prost(enumeration = "FriendOnlineState", tag = "8")]
    pub online_state: i32,
    #[prost(enumeration = "FriendEnterHomeOption", tag = "9")]
    pub friend_enter_home_option: i32,
    #[prost(uint32, tag = "10")]
    pub world_level: u32,
    #[prost(uint32, tag = "11")]
    pub last_active_time: u32,
    #[prost(uint32, tag = "12")]
    pub chat_sequence: u32,
    #[prost(uint32, tag = "13")]
    pub uid: u32,
    #[prost(uint32, tag = "14")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "15")]
    pub name_card_id: u32,
    #[prost(uint32, tag = "16")]
    pub mp_player_num: u32,
    #[prost(enumeration = "PlatformType", tag = "17")]
    pub platform_type: i32,
    #[prost(uint32, tag = "18")]
    pub param: u32,
    #[prost(bool, tag = "19")]
    pub is_mp_mode_available: bool,
    #[prost(bool, tag = "20")]
    pub is_psn_source: bool,
    #[prost(bool, tag = "21")]
    pub is_game_source: bool,
    #[prost(bool, tag = "22")]
    pub is_chat_no_disturb: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatEmojiCollectionData {
    #[prost(uint32, repeated, tag = "1")]
    pub emoji_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPlayerFriendListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4002)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerFriendListRsp {
    #[prost(message, repeated, tag = "1")]
    pub ask_friend_list: ::prost::alloc::vec::Vec<FriendBrief>,
    #[prost(message, repeated, tag = "2")]
    pub friend_list: ::prost::alloc::vec::Vec<FriendBrief>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4003)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AskAddFriendReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4004)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AskAddFriendRsp {
    #[prost(uint32, tag = "1")]
    pub param: u32,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4005)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DealAddFriendReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(enumeration = "DealAddFriendResultType", tag = "2")]
    pub deal_add_friend_result: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4006)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DealAddFriendRsp {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "DealAddFriendResultType", tag = "3")]
    pub deal_add_friend_result: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4007)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPlayerSocialDetailReq {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4008)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerSocialDetailRsp {
    #[prost(message, optional, tag = "1")]
    pub detail_data: ::core::option::Option<SocialDetail>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4009)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteFriendReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4010)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteFriendRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4011)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetPlayerBirthdayReq {
    #[prost(message, optional, tag = "1")]
    pub birthday: ::core::option::Option<Birthday>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4012)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetPlayerBirthdayRsp {
    #[prost(message, optional, tag = "1")]
    pub birthday: ::core::option::Option<Birthday>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4013)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPlayerSignatureReq {
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4014)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPlayerSignatureRsp {
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4015)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetPlayerHeadImageReq {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4016)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetPlayerHeadImageRsp {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4017)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePs4FriendListNotify {
    #[prost(string, repeated, tag = "1")]
    pub psn_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4018)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteFriendNotify {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4019)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddFriendNotify {
    #[prost(message, optional, tag = "1")]
    pub target_friend_brief: ::core::option::Option<FriendBrief>,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4020)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AskAddFriendNotify {
    #[prost(message, optional, tag = "1")]
    pub target_friend_brief: ::core::option::Option<FriendBrief>,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4021)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetNameCardReq {
    #[prost(uint32, tag = "1")]
    pub name_card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4022)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetNameCardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub name_card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4023)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllUnlockNameCardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4024)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllUnlockNameCardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub name_card_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4025)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddBlacklistReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4026)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddBlacklistRsp {
    #[prost(message, optional, tag = "1")]
    pub target_friend_brief: ::core::option::Option<FriendBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4027)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveBlacklistReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4028)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveBlacklistRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4029)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockNameCardNotify {
    #[prost(uint32, tag = "1")]
    pub name_card_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4030)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRecentMpPlayerListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4031)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRecentMpPlayerListRsp {
    #[prost(message, repeated, tag = "1")]
    pub recent_mp_player_brief_list: ::prost::alloc::vec::Vec<FriendBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4032)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SocialDataNotify {
    #[prost(bool, tag = "1")]
    pub is_have_first_share: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4033)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeFirstShareRewardReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4034)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TakeFirstShareRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4035)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePs4BlockListReq {
    #[prost(string, repeated, tag = "1")]
    pub psn_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4036)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdatePs4BlockListRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4037)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPlayerBlacklistReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4038)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerBlacklistRsp {
    #[prost(message, repeated, tag = "1")]
    pub blacklist: ::prost::alloc::vec::Vec<FriendBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4039)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerReportReq {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_home_module_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub target_uid: u32,
    #[prost(enumeration = "ReportSubtype", tag = "4")]
    pub subtype: i32,
    #[prost(uint32, tag = "5")]
    pub target_home_module_id: u32,
    #[prost(enumeration = "ReportReasonType", tag = "6")]
    pub reason: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4040)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerReportRsp {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
    #[prost(uint32, tag = "2")]
    pub cd_time: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4041)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFriendRemarkNameReq {
    #[prost(string, tag = "1")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4042)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFriendRemarkNameRsp {
    #[prost(string, tag = "1")]
    pub remark_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
    #[prost(bool, tag = "4")]
    pub is_clear_remark: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4043)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePlayerShowAvatarListReq {
    #[prost(uint32, repeated, tag = "1")]
    pub show_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_show_avatar: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4044)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePlayerShowAvatarListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub show_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_show_avatar: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4045)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFriendShowAvatarInfoReq {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4046)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFriendShowAvatarInfoRsp {
    #[prost(message, repeated, tag = "1")]
    pub show_avatar_info_list: ::prost::alloc::vec::Vec<ShowAvatarInfo>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4047)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePlayerShowNameCardListReq {
    #[prost(uint32, repeated, tag = "1")]
    pub show_name_card_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4048)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePlayerShowNameCardListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub show_name_card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4049)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFriendShowNameCardInfoReq {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4050)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFriendShowNameCardInfoRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub show_name_card_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4051)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForceAddPlayerFriendReq {
    #[prost(uint32, tag = "1")]
    pub target_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4052)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceAddPlayerFriendRsp {
    #[prost(message, optional, tag = "1")]
    pub target_friend_brief: ::core::option::Option<FriendBrief>,
    #[prost(uint32, tag = "2")]
    pub target_uid: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4053)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProfilePictureChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4054)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PsnFriendListNotify {
    #[prost(message, repeated, tag = "1")]
    pub psn_friend_list: ::prost::alloc::vec::Vec<FriendBrief>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4055)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PsnBlackListNotify {
    #[prost(message, repeated, tag = "1")]
    pub psn_blacklist: ::prost::alloc::vec::Vec<FriendBrief>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4056)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPlayerAskFriendListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4057)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPlayerAskFriendListRsp {
    #[prost(message, repeated, tag = "1")]
    pub ask_friend_list: ::prost::alloc::vec::Vec<FriendBrief>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4058)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetChatEmojiCollectionReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4059)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChatEmojiCollectionRsp {
    #[prost(message, optional, tag = "1")]
    pub chat_emoji_collection_data: ::core::option::Option<ChatEmojiCollectionData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4060)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetChatEmojiCollectionReq {
    #[prost(message, optional, tag = "1")]
    pub chat_emoji_collection_data: ::core::option::Option<ChatEmojiCollectionData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4061)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetChatEmojiCollectionRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4062)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePs4FriendListReq {
    #[prost(string, repeated, tag = "1")]
    pub psn_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4063)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePs4FriendListRsp {
    #[prost(string, repeated, tag = "1")]
    pub psn_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4064)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FriendInfoChangeNotify {
    #[prost(string, tag = "1")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4065)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerSignatureAuditDataNotify {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ContentAuditInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4066)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerSignatureNotify {
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4067)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignatureAuditConfigNotify {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(uint32, tag = "2")]
    pub submit_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4068)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadSignatureAuditReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4069)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadSignatureAuditRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiSnapshotEntitySkillCycle {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub trydoskill: bool,
    #[prost(bool, tag = "3")]
    pub failed: bool,
    #[prost(bool, tag = "4")]
    pub selected: bool,
    #[prost(uint32, tag = "5")]
    pub skill_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiSnapshotEntityData {
    #[prost(message, repeated, tag = "1")]
    pub finished_skill_cycles: ::prost::alloc::vec::Vec<AiSnapshotEntitySkillCycle>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub hitting_avatars: ::std::collections::HashMap<u32, u32>,
    #[prost(float, tag = "3")]
    pub tick_time: f32,
    #[prost(float, tag = "4")]
    pub moved_distance: f32,
    #[prost(uint32, tag = "5")]
    pub ai_target_id: u32,
    #[prost(uint32, tag = "6")]
    pub attack_target_id: u32,
    #[prost(float, tag = "7")]
    pub distance_to_player: f32,
    #[prost(uint32, tag = "8")]
    pub threat_target_id: u32,
    #[prost(float, tag = "9")]
    pub real_time: f32,
    #[prost(uint32, tag = "10")]
    pub tactic: u32,
    #[prost(uint32, tag = "11")]
    pub threat_list_size: u32,
    #[prost(uint32, tag = "12")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiSnapshotInfo {
    #[prost(message, repeated, tag = "1")]
    pub ai_snapshots: ::prost::alloc::vec::Vec<AiSnapshotEntityData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6101)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonQueryPathReq {
    #[prost(message, optional, tag = "1")]
    pub source_pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub destination_pos: ::core::option::Option<Vector>,
    #[prost(bool, tag = "3")]
    pub refined: bool,
    #[prost(bool, tag = "4")]
    pub use_full_neighbor: bool,
    #[prost(int32, tag = "5")]
    pub fuzzy_range: i32,
    #[prost(enumeration = "FilterType", tag = "6")]
    pub filter_type: i32,
    #[prost(uint32, tag = "7")]
    pub scene_id: u32,
    #[prost(int32, tag = "8")]
    pub query_id: i32,
    #[prost(enumeration = "ToTheMoonQueryPathReqOptionType", tag = "9")]
    pub query_type: i32,
    #[prost(enumeration = "AStarMethod", tag = "10")]
    pub astar_method: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6102)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToTheMoonQueryPathRsp {
    #[prost(int32, repeated, tag = "1")]
    pub level: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "2")]
    pub corners: ::prost::alloc::vec::Vec<Vector>,
    #[prost(int64, repeated, tag = "3")]
    pub index: ::prost::alloc::vec::Vec<i64>,
    #[prost(int32, tag = "4")]
    pub query_id: i32,
    #[prost(int32, tag = "5")]
    pub retcode: i32,
    #[prost(enumeration = "ToTheMoonQueryPathRspPathStatusType", tag = "6")]
    pub query_status: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonPingNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonEnterSceneReq {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(uint32, tag = "2")]
    pub version: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonEnterSceneRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonObstacleInfo {
    #[prost(message, optional, tag = "1")]
    pub half_extents: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub rotation: ::core::option::Option<MathQuaternion>,
    #[prost(enumeration = "ToTheMoonObstacleInfoShapeType", tag = "4")]
    pub r#type: i32,
    #[prost(int32, tag = "5")]
    pub handle_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6106)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonAddObstacleReq {
    #[prost(message, optional, tag = "1")]
    pub obstacle: ::core::option::Option<ToTheMoonObstacleInfo>,
    #[prost(uint32, tag = "2")]
    pub scene_id: u32,
    #[prost(int32, tag = "3")]
    pub query_id: i32,
    #[prost(bool, tag = "4")]
    pub use_edge: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynamicSvoNode {
    #[prost(message, optional, tag = "1")]
    pub refer_pos: ::core::option::Option<Vector>,
    #[prost(int32, tag = "2")]
    pub area: i32,
    #[prost(int64, tag = "3")]
    pub index: i64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicLayerNodes {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<DynamicSvoNode>,
    #[prost(int32, tag = "2")]
    pub level: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicNodes {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<DynamicLayerNodes>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6107)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToTheMoonAddObstacleRsp {
    #[prost(message, optional, tag = "1")]
    pub dynamic_nodes: ::core::option::Option<DynamicNodes>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(int32, tag = "3")]
    pub query_id: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6108)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToTheMoonRemoveObstacleReq {
    #[prost(int32, tag = "1")]
    pub query_id: i32,
    #[prost(int32, tag = "2")]
    pub handle: i32,
    #[prost(uint32, tag = "3")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6109)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToTheMoonRemoveObstacleRsp {
    #[prost(message, optional, tag = "1")]
    pub dynamic_nodes: ::core::option::Option<DynamicNodes>,
    #[prost(int32, tag = "2")]
    pub query_id: i32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6110)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToTheMoonObstaclesModifyNotify {
    #[prost(int32, repeated, tag = "1")]
    pub remove_obstacle_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "2")]
    pub add_obstacles: ::prost::alloc::vec::Vec<ToTheMoonObstacleInfo>,
    #[prost(bool, tag = "3")]
    pub use_edge: bool,
    #[prost(uint32, tag = "4")]
    pub scene_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Kkcdicnmnph {
    #[prost(bool, tag = "1")]
    pub is_need_sync_ping: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerTeam {
    #[prost(uint64, repeated, tag = "1")]
    pub avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "2")]
    pub tower_team_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerLevelRecord {
    #[prost(uint32, repeated, tag = "1")]
    pub satisfied_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerFloorRecord {
    #[prost(message, repeated, tag = "1")]
    pub passed_level_record_list: ::prost::alloc::vec::Vec<TowerLevelRecord>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub passed_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "3")]
    pub floor_id: u32,
    #[prost(uint32, tag = "4")]
    pub floor_star_reward_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerCurLevelRecord {
    #[prost(message, repeated, tag = "1")]
    pub tower_team_list: ::prost::alloc::vec::Vec<TowerTeam>,
    #[prost(uint32, repeated, tag = "2")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub cur_floor_id: u32,
    #[prost(uint32, tag = "4")]
    pub cur_level_index: u32,
    #[prost(bool, tag = "5")]
    pub is_empty: bool,
    #[prost(bool, tag = "6")]
    pub is_upper_part: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2401)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerBriefDataNotify {
    #[prost(uint32, tag = "1")]
    pub tower_schedule_id: u32,
    #[prost(bool, tag = "2")]
    pub is_finished_entrance_floor: bool,
    #[prost(uint32, tag = "3")]
    pub last_floor_index: u32,
    #[prost(uint32, tag = "4")]
    pub total_star_num: u32,
    #[prost(uint32, tag = "5")]
    pub schedule_start_time: u32,
    #[prost(uint32, tag = "6")]
    pub last_level_index: u32,
    #[prost(uint32, tag = "7")]
    pub next_schedule_change_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2402)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerFloorRecordChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub tower_floor_record_list: ::prost::alloc::vec::Vec<TowerFloorRecord>,
    #[prost(bool, tag = "2")]
    pub is_finished_entrance_floor: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2403)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerCurLevelRecordChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub cur_level_record: ::core::option::Option<TowerCurLevelRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2404)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerDailyRewardProgressChangeNotify {
    #[prost(uint32, tag = "1")]
    pub daily_level_index: u32,
    #[prost(uint32, tag = "2")]
    pub daily_floor_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2405)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerTeamSelectReq {
    #[prost(message, repeated, tag = "1")]
    pub tower_team_list: ::prost::alloc::vec::Vec<TowerTeam>,
    #[prost(uint32, tag = "2")]
    pub floor_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2406)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerTeamSelectRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2407)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerAllDataReq {
    #[prost(bool, tag = "1")]
    pub is_interact: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerMonthlyBrief {
    #[prost(uint32, tag = "1")]
    pub best_level_index: u32,
    #[prost(uint32, tag = "2")]
    pub total_star_count: u32,
    #[prost(uint32, tag = "3")]
    pub best_floor_index: u32,
    #[prost(uint32, tag = "4")]
    pub tower_schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2408)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerAllDataRsp {
    #[prost(message, optional, tag = "1")]
    pub cur_level_record: ::core::option::Option<TowerCurLevelRecord>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub floor_open_time_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub skip_floor_granted_reward_item_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, repeated, tag = "4")]
    pub tower_floor_record_list: ::prost::alloc::vec::Vec<TowerFloorRecord>,
    #[prost(message, optional, tag = "5")]
    pub last_schedule_monthly_brief: ::core::option::Option<TowerMonthlyBrief>,
    #[prost(message, optional, tag = "6")]
    pub monthly_brief: ::core::option::Option<TowerMonthlyBrief>,
    #[prost(uint32, tag = "7")]
    pub next_schedule_change_time: u32,
    #[prost(uint32, tag = "8")]
    pub daily_level_index: u32,
    #[prost(uint32, tag = "9")]
    pub commemorative_reward_id: u32,
    #[prost(bool, tag = "10")]
    pub is_finished_entrance_floor: bool,
    #[prost(bool, tag = "11")]
    pub is_first_interact: bool,
    #[prost(uint32, tag = "12")]
    pub tower_schedule_id: u32,
    #[prost(uint32, tag = "13")]
    pub schedule_start_time: u32,
    #[prost(uint32, tag = "14")]
    pub valid_tower_record_num: u32,
    #[prost(uint32, tag = "15")]
    pub daily_floor_id: u32,
    #[prost(uint32, tag = "16")]
    pub skip_to_floor_index: u32,
    #[prost(int32, tag = "17")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2409)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerEnterLevelReq {
    #[prost(uint32, tag = "1")]
    pub enter_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2410)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerEnterLevelRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub tower_buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub level_index: u32,
    #[prost(uint32, tag = "3")]
    pub floor_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2411)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerBuffSelectReq {
    #[prost(uint32, tag = "1")]
    pub tower_buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2412)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerBuffSelectRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub tower_buff_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2413)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerSurrenderReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2414)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerSurrenderRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2415)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerGetFloorStarRewardReq {
    #[prost(uint32, tag = "1")]
    pub floor_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2416)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerGetFloorStarRewardRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub floor_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2417)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerLevelEndNotify {
    #[prost(message, repeated, tag = "1")]
    pub reward_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(uint32, repeated, tag = "2")]
    pub finished_star_cond_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
    #[prost(uint32, tag = "4")]
    pub continue_state: u32,
    #[prost(uint32, tag = "5")]
    pub next_floor_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerLevelStarCondData {
    #[prost(uint32, tag = "1")]
    pub cond_value: u32,
    #[prost(uint32, tag = "2")]
    pub star_cond_index: u32,
    #[prost(bool, tag = "3")]
    pub is_fail: bool,
    #[prost(bool, tag = "4")]
    pub is_pause: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2418)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerLevelStarCondNotify {
    #[prost(message, repeated, tag = "1")]
    pub cond_data_list: ::prost::alloc::vec::Vec<TowerLevelStarCondData>,
    #[prost(uint32, tag = "2")]
    pub level_index: u32,
    #[prost(uint32, tag = "3")]
    pub floor_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2419)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerMiddleLevelChangeTeamNotify {}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerFightRecordPair {
    #[prost(uint32, tag = "1")]
    pub data: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerMonthlyCombatRecord {
    #[prost(message, optional, tag = "1")]
    pub highest_dps_avatar_pair: ::core::option::Option<TowerFightRecordPair>,
    #[prost(message, repeated, tag = "2")]
    pub most_reveal_avatar_list: ::prost::alloc::vec::Vec<TowerFightRecordPair>,
    #[prost(message, optional, tag = "3")]
    pub most_take_damage_avatar_pair: ::core::option::Option<TowerFightRecordPair>,
    #[prost(message, optional, tag = "4")]
    pub most_cast_normal_skill_avatar_pair: ::core::option::Option<TowerFightRecordPair>,
    #[prost(message, optional, tag = "5")]
    pub most_kill_avatar_pair: ::core::option::Option<TowerFightRecordPair>,
    #[prost(message, optional, tag = "6")]
    pub most_cast_energy_skill_avatar_pair: ::core::option::Option<TowerFightRecordPair>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerMonthlyDetail {
    #[prost(message, optional, tag = "1")]
    pub monthly_combat_record: ::core::option::Option<TowerMonthlyCombatRecord>,
    #[prost(message, optional, tag = "2")]
    pub monthly_brief: ::core::option::Option<TowerMonthlyBrief>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2420)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TowerRecordHandbookReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2421)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TowerRecordHandbookRsp {
    #[prost(message, repeated, tag = "1")]
    pub monthly_detail_list: ::prost::alloc::vec::Vec<TowerMonthlyDetail>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcMusicNote {
    #[prost(uint32, tag = "1")]
    pub end_time: u32,
    #[prost(uint32, tag = "2")]
    pub start_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcMusicTrack {
    #[prost(message, repeated, tag = "1")]
    pub music_note_list: ::prost::alloc::vec::Vec<UgcMusicNote>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcMusicRecord {
    #[prost(message, repeated, tag = "1")]
    pub music_track_list: ::prost::alloc::vec::Vec<UgcMusicTrack>,
    #[prost(uint32, tag = "2")]
    pub music_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcMusicBriefInfo {
    #[prost(string, tag = "1")]
    pub creator_nickname: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "2")]
    pub after_note_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub before_note_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub save_page_type: u32,
    #[prost(bool, tag = "5")]
    pub is_played: bool,
    #[prost(bool, tag = "6")]
    pub is_published: bool,
    #[prost(bool, tag = "7")]
    pub is_psn_platform: bool,
    #[prost(bool, tag = "8")]
    pub is_changed_after_publish: bool,
    #[prost(uint32, tag = "9")]
    pub note_count: u32,
    #[prost(uint32, tag = "10")]
    pub play_time: u32,
    #[prost(uint32, tag = "11")]
    pub max_score: u32,
    #[prost(uint64, tag = "12")]
    pub ugc_guid: u64,
    #[prost(uint64, tag = "13")]
    pub import_from_ugc_guid: u64,
    #[prost(uint32, tag = "14")]
    pub version: u32,
    #[prost(uint32, tag = "15")]
    pub publish_time: u32,
    #[prost(uint32, tag = "16")]
    pub save_idx: u32,
    #[prost(uint32, tag = "17")]
    pub save_time: u32,
    #[prost(uint32, tag = "18")]
    pub real_time_edit_time: u32,
    #[prost(uint32, tag = "19")]
    pub time_line_edit_time: u32,
    #[prost(uint32, tag = "20")]
    pub self_max_score: u32,
    #[prost(uint32, tag = "21")]
    pub music_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6305)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetUgcReq {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(enumeration = "RecordUsage", tag = "2")]
    pub ugc_record_usage: i32,
    #[prost(bool, tag = "3")]
    pub is_require_brief: bool,
    #[prost(enumeration = "GetUgcType", tag = "4")]
    pub get_ugc_type: i32,
    #[prost(uint32, tag = "5")]
    pub schedule_id: u32,
    #[prost(enumeration = "UgcType", tag = "6")]
    pub ugc_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6306)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUgcRsp {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "UgcType", tag = "3")]
    pub ugc_type: i32,
    #[prost(enumeration = "RecordUsage", tag = "4")]
    pub ugc_record_usage: i32,
    #[prost(oneof = "get_ugc_rsp::Record", tags = "5")]
    pub record: ::core::option::Option<get_ugc_rsp::Record>,
    #[prost(oneof = "get_ugc_rsp::Brief", tags = "6")]
    pub brief: ::core::option::Option<get_ugc_rsp::Brief>,
}
/// Nested message and enum types in `GetUgcRsp`.
pub mod get_ugc_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Record {
        #[prost(message, tag = "5")]
        MusicRecord(super::UgcMusicRecord),
    }
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Brief {
        #[prost(message, tag = "6")]
        MusicBriefInfo(super::UgcMusicBriefInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6307)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetUgcBriefInfoReq {
    #[prost(enumeration = "UgcType", tag = "1")]
    pub ugc_type: i32,
    #[prost(uint64, tag = "2")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6308)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUgcBriefInfoRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(enumeration = "UgcType", tag = "2")]
    pub ugc_type: i32,
    #[prost(uint64, tag = "3")]
    pub ugc_guid: u64,
    #[prost(oneof = "get_ugc_brief_info_rsp::Brief", tags = "4")]
    pub brief: ::core::option::Option<get_ugc_brief_info_rsp::Brief>,
}
/// Nested message and enum types in `GetUgcBriefInfoRsp`.
pub mod get_ugc_brief_info_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Brief {
        #[prost(message, tag = "4")]
        MusicBriefInfo(super::UgcMusicBriefInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6309)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveUgcReq {
    #[prost(enumeration = "UgcType", tag = "1")]
    pub ugc_type: i32,
    #[prost(uint32, tag = "2")]
    pub schedule_id: u32,
    #[prost(oneof = "save_ugc_req::Record", tags = "3")]
    pub record: ::core::option::Option<save_ugc_req::Record>,
    #[prost(oneof = "save_ugc_req::Brief", tags = "4")]
    pub brief: ::core::option::Option<save_ugc_req::Brief>,
}
/// Nested message and enum types in `SaveUgcReq`.
pub mod save_ugc_req {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Record {
        #[prost(message, tag = "3")]
        MusicRecord(super::UgcMusicRecord),
    }
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Brief {
        #[prost(message, tag = "4")]
        MusicBriefInfo(super::UgcMusicBriefInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6310)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SaveUgcRsp {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "UgcType", tag = "3")]
    pub ugc_type: i32,
    #[prost(bool, tag = "4")]
    pub is_new_ugc: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6311)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishUgcReq {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(enumeration = "UgcType", tag = "2")]
    pub ugc_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6312)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishUgcRsp {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "UgcType", tag = "3")]
    pub ugc_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6313)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckUgcUpdateReq {
    #[prost(enumeration = "UgcType", tag = "1")]
    pub ugc_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6314)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckUgcUpdateRsp {
    #[prost(uint64, repeated, tag = "1")]
    pub update_ugc_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(enumeration = "UgcType", tag = "2")]
    pub ugc_type: i32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6315)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcNotify {
    #[prost(bool, tag = "1")]
    pub is_ugc_feature_closed: bool,
    #[prost(bool, tag = "2")]
    pub is_ugc_publish_ban: bool,
    #[prost(bool, tag = "3")]
    pub is_ugc_publish_feature_closed: bool,
    #[prost(bool, tag = "4")]
    pub is_ugc_link_button_feature_closed: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6316)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckUgcStateReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6317)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckUgcStateRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6318)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicGameUgcNotify {
    #[prost(message, repeated, tag = "1")]
    pub ugc_search_list: ::prost::alloc::vec::Vec<UgcMusicBriefInfo>,
    #[prost(message, repeated, tag = "2")]
    pub ugc_record_list: ::prost::alloc::vec::Vec<UgcMusicBriefInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6319)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelUgcReq {
    #[prost(uint64, tag = "1")]
    pub ugc_guid: u64,
    #[prost(enumeration = "UgcType", tag = "2")]
    pub ugc_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6320)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelUgcRsp {
    #[prost(enumeration = "UgcType", tag = "1")]
    pub ugc_type: i32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub ugc_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Copagjplldl {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
    #[prost(uint32, tag = "4")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcGadgetItemInfo {
    #[prost(uint32, tag = "1")]
    pub item_num: u32,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcChestGadget {
    #[prost(message, repeated, tag = "1")]
    pub chest_drop_item_info_list: ::prost::alloc::vec::Vec<UgcGadgetItemInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcShopGadget {
    #[prost(message, repeated, tag = "1")]
    pub shop_item_info_list: ::prost::alloc::vec::Vec<UgcGadgetItemInfo>,
    #[prost(uint32, tag = "2")]
    pub random_item_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcGadget {
    #[prost(message, optional, tag = "1")]
    pub basic_info: ::core::option::Option<Copagjplldl>,
    #[prost(bool, tag = "2")]
    pub is_default_hide: bool,
    #[prost(uint32, tag = "3")]
    pub default_gadget_state_id: u32,
    #[prost(oneof = "ugc_gadget::Param", tags = "4, 5")]
    pub param: ::core::option::Option<ugc_gadget::Param>,
}
/// Nested message and enum types in `UgcGadget`.
pub mod ugc_gadget {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(message, tag = "4")]
        ChestInfo(super::UgcChestGadget),
        #[prost(message, tag = "5")]
        ShopInfo(super::UgcShopGadget),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcMonster {
    #[prost(message, optional, tag = "1")]
    pub basic_info: ::core::option::Option<Copagjplldl>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcMonsterGroup {
    #[prost(uint32, repeated, tag = "1")]
    pub monster_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "2")]
    pub basic_info: ::core::option::Option<Copagjplldl>,
    #[prost(uint32, tag = "3")]
    pub monster_level_id: u32,
    #[prost(bool, tag = "4")]
    pub is_default_hide: bool,
    #[prost(bool, tag = "5")]
    pub is_drop_coin: bool,
    #[prost(bool, tag = "6")]
    pub is_drop_exp: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerConditionGadgetStateChange {
    #[prost(uint32, tag = "1")]
    pub gadget_guid: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerConditionMonsterGroupDeactive {
    #[prost(uint32, tag = "1")]
    pub monster_group_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerConditionMonsterWaveDeactive {
    #[prost(uint32, tag = "1")]
    pub monster_wave_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerConditionGadgetDeactive {
    #[prost(uint32, tag = "1")]
    pub gadget_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerCondition {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(oneof = "ugc_trigger_condition::Param", tags = "2, 3, 4, 5")]
    pub param: ::core::option::Option<ugc_trigger_condition::Param>,
}
/// Nested message and enum types in `UgcTriggerCondition`.
pub mod ugc_trigger_condition {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(message, tag = "2")]
        GadgetStateChange(super::UgcTriggerConditionGadgetStateChange),
        #[prost(message, tag = "3")]
        MonsterGroupDeactive(super::UgcTriggerConditionMonsterGroupDeactive),
        #[prost(message, tag = "4")]
        MonsterWaveDeactive(super::UgcTriggerConditionMonsterWaveDeactive),
        #[prost(message, tag = "5")]
        GadgetDeactive(super::UgcTriggerConditionGadgetDeactive),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerActionChangeGadgetState {
    #[prost(uint32, tag = "1")]
    pub gadget_state: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerActionActiveGadget {
    #[prost(uint32, tag = "1")]
    pub gadget_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerActionDeactiveGadget {
    #[prost(uint32, tag = "1")]
    pub gadget_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerActionActiveMonsterGroup {
    #[prost(uint32, tag = "1")]
    pub monster_group_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerActionActiveMonsterWave {
    #[prost(uint32, tag = "1")]
    pub monster_wave_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerActionDeactiveMonsterWaveCurrentGroup {
    #[prost(uint32, tag = "1")]
    pub monster_wave_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTriggerAction {
    #[prost(uint32, tag = "1")]
    pub config_id: u32,
    #[prost(oneof = "ugc_trigger_action::Param", tags = "2, 3, 4, 5, 6, 7")]
    pub param: ::core::option::Option<ugc_trigger_action::Param>,
}
/// Nested message and enum types in `UgcTriggerAction`.
pub mod ugc_trigger_action {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(message, tag = "2")]
        ChangeGadgetState(super::UgcTriggerActionChangeGadgetState),
        #[prost(message, tag = "3")]
        ActiveGadget(super::UgcTriggerActionActiveGadget),
        #[prost(message, tag = "4")]
        DeactiveGadget(super::UgcTriggerActionDeactiveGadget),
        #[prost(message, tag = "5")]
        ActiveMonsterGroup(super::UgcTriggerActionActiveMonsterGroup),
        #[prost(message, tag = "6")]
        ActiveMonsterWave(super::UgcTriggerActionActiveMonsterWave),
        #[prost(message, tag = "7")]
        DeactiveMonsterWaveCurrentGroup(
            super::UgcTriggerActionDeactiveMonsterWaveCurrentGroup,
        ),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcTrigger {
    #[prost(message, repeated, tag = "1")]
    pub condition_list: ::prost::alloc::vec::Vec<UgcTriggerCondition>,
    #[prost(message, repeated, tag = "2")]
    pub action_list: ::prost::alloc::vec::Vec<UgcTriggerAction>,
    #[prost(uint32, tag = "3")]
    pub guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonRoomSetting {
    #[prost(uint32, tag = "1")]
    pub target_kill_monster_num: u32,
    #[prost(uint32, tag = "2")]
    pub target_coin_num: u32,
    #[prost(bool, tag = "3")]
    pub is_apply_coin_num: bool,
    #[prost(bool, tag = "4")]
    pub is_apply_room_settle: bool,
    #[prost(bool, tag = "5")]
    pub is_apply_kill_monster: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcMonsterWave {
    #[prost(message, optional, tag = "1")]
    pub basic_info: ::core::option::Option<Copagjplldl>,
    #[prost(uint32, repeated, tag = "2")]
    pub monster_group_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_drop_exp: bool,
    #[prost(bool, tag = "4")]
    pub is_default_hide: bool,
    #[prost(bool, tag = "5")]
    pub is_drop_coin: bool,
    #[prost(uint32, tag = "6")]
    pub wave_count: u32,
    #[prost(uint32, tag = "7")]
    pub wave_interval: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcSuite {
    #[prost(uint32, repeated, tag = "1")]
    pub trigger_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub monster_wave_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "3")]
    pub basic_info: ::core::option::Option<Copagjplldl>,
    #[prost(uint32, repeated, tag = "4")]
    pub gadget_guid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub monster_group_guid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonRoomDeployment {
    #[prost(message, repeated, tag = "1")]
    pub suite_list: ::prost::alloc::vec::Vec<UgcSuite>,
    #[prost(message, repeated, tag = "2")]
    pub trigger_list: ::prost::alloc::vec::Vec<UgcTrigger>,
    #[prost(message, repeated, tag = "3")]
    pub gadget_list: ::prost::alloc::vec::Vec<UgcGadget>,
    #[prost(message, repeated, tag = "4")]
    pub monster_wave_list: ::prost::alloc::vec::Vec<UgcMonsterWave>,
    #[prost(message, repeated, tag = "5")]
    pub monster_list: ::prost::alloc::vec::Vec<UgcMonster>,
    #[prost(message, repeated, tag = "6")]
    pub monster_group_list: ::prost::alloc::vec::Vec<UgcMonsterGroup>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonRoomEntryInfoData {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(bool, tag = "2")]
    pub is_host: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonRoomDisplayData {
    #[prost(uint32, repeated, tag = "1")]
    pub elite_monster_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "2")]
    pub end_pos_list: ::prost::alloc::vec::Vec<Vector>,
    #[prost(message, repeated, tag = "3")]
    pub entry_info_list: ::prost::alloc::vec::Vec<UgcDungeonRoomEntryInfoData>,
    #[prost(bool, tag = "4")]
    pub is_has_monster: bool,
    #[prost(bool, tag = "5")]
    pub is_has_avatar_shop: bool,
    #[prost(bool, tag = "6")]
    pub is_has_buff_shop: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonRoom {
    #[prost(message, optional, tag = "1")]
    pub display_data: ::core::option::Option<UgcDungeonRoomDisplayData>,
    #[prost(message, optional, tag = "2")]
    pub room_setting: ::core::option::Option<UgcDungeonRoomSetting>,
    #[prost(message, optional, tag = "3")]
    pub room_deployment: ::core::option::Option<UgcDungeonRoomDeployment>,
    #[prost(uint32, tag = "4")]
    pub room_config_id: u32,
    #[prost(bool, tag = "5")]
    pub is_add: bool,
    #[prost(uint32, tag = "6")]
    pub room_slot_index: u32,
    #[prost(uint32, tag = "7")]
    pub total_cost: u32,
    #[prost(uint32, tag = "8")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonSetting {
    #[prost(uint32, repeated, tag = "1")]
    pub score_condition_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub allow_ugc_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub max_player_num: u32,
    #[prost(uint32, tag = "4")]
    pub mdpmjadanld: u32,
    #[prost(uint32, tag = "5")]
    pub max_allow_death_count: u32,
    #[prost(uint32, tag = "6")]
    pub total_seconds: u32,
    #[prost(uint32, tag = "7")]
    pub target_score: u32,
    #[prost(uint32, tag = "8")]
    pub preset_type: u32,
    #[prost(bool, tag = "9")]
    pub is_ban_skill: bool,
    #[prost(enumeration = "UgcDungeonSettleType", tag = "10")]
    pub settle_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeon {
    #[prost(message, optional, tag = "1")]
    pub dungeon_setting: ::core::option::Option<UgcDungeonSetting>,
    #[prost(message, repeated, tag = "2")]
    pub room_list: ::prost::alloc::vec::Vec<UgcDungeonRoom>,
    #[prost(uint32, tag = "3")]
    pub dungeon_id: u32,
    #[prost(uint64, tag = "4")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonRoomBrief {
    #[prost(message, optional, tag = "1")]
    pub room_setting: ::core::option::Option<UgcDungeonRoomSetting>,
    #[prost(message, optional, tag = "2")]
    pub display_data: ::core::option::Option<UgcDungeonRoomDisplayData>,
    #[prost(uint32, tag = "3")]
    pub room_id: u32,
    #[prost(uint32, tag = "4")]
    pub room_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSocialData {
    #[prost(uint32, tag = "1")]
    pub starred_count: u32,
    #[prost(uint32, tag = "2")]
    pub play_count: u32,
    #[prost(uint32, tag = "3")]
    pub like_count: u32,
    #[prost(uint32, tag = "4")]
    pub win_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonBrief {
    #[prost(message, optional, tag = "1")]
    pub social_data: ::core::option::Option<UgcDungeonSocialData>,
    #[prost(string, tag = "2")]
    pub share_code: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub room_brief_list: ::prost::alloc::vec::Vec<UgcDungeonRoomBrief>,
    #[prost(string, tag = "4")]
    pub creator_nickname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub dungeon_setting: ::core::option::Option<UgcDungeonSetting>,
    #[prost(uint32, repeated, tag = "6")]
    pub tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "7")]
    pub creator_uid: u32,
    #[prost(uint32, tag = "8")]
    pub dungeon_state: u32,
    #[prost(bool, tag = "9")]
    pub is_can_publish: bool,
    #[prost(bool, tag = "10")]
    pub is_allow_import: bool,
    #[prost(bool, tag = "11")]
    pub is_have_published: bool,
    #[prost(bool, tag = "12")]
    pub is_psn_platform: bool,
    #[prost(uint32, tag = "13")]
    pub latest_save_time: u32,
    #[prost(uint64, tag = "14")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "15")]
    pub first_publish_time: u32,
    #[prost(uint32, tag = "16")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "17")]
    pub publish_time: u32,
    #[prost(enumeration = "Glnoheblmjp", tag = "18")]
    pub edit_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonCandidateTeamAvatarInfo {
    #[prost(enumeration = "UgcDungeonCandidateAvatarType", tag = "1")]
    pub avatar_type: i32,
    #[prost(uint32, tag = "2")]
    pub ugc_avatar_id: u32,
    #[prost(uint32, tag = "3")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9101)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterUgcDungeonReq {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<UgcDungeonCandidateTeamAvatarInfo>,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
    #[prost(uint64, tag = "3")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "4")]
    pub dungeon_id: u32,
    #[prost(enumeration = "EnterUgcDungeonType", tag = "5")]
    pub enter_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9201)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterUgcDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(enumeration = "EnterUgcDungeonType", tag = "2")]
    pub enter_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9202)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonCandidateTeamCreateReq {
    #[prost(uint32, tag = "1")]
    pub dungeon_id: u32,
    #[prost(enumeration = "EnterUgcDungeonType", tag = "2")]
    pub enter_type: i32,
    #[prost(uint64, tag = "3")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9203)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonCandidateTeamCreateRsp {
    #[prost(message, optional, tag = "1")]
    pub ugc_dungeon: ::core::option::Option<UgcDungeon>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(enumeration = "EnterUgcDungeonType", tag = "3")]
    pub enter_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9204)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddNewUgcDungeonReq {
    #[prost(message, optional, tag = "1")]
    pub dungeon_setting: ::core::option::Option<UgcDungeonSetting>,
    #[prost(uint32, tag = "2")]
    pub dungeon_id: u32,
    #[prost(uint32, tag = "3")]
    pub room_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9102)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddNewUgcDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9205)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveUgcDungeonDataReq {
    #[prost(message, optional, tag = "1")]
    pub dungeon_setting: ::core::option::Option<UgcDungeonSetting>,
    #[prost(message, repeated, tag = "2")]
    pub room_list: ::prost::alloc::vec::Vec<UgcDungeonRoom>,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
    #[prost(bool, tag = "4")]
    pub is_update_setting: bool,
    #[prost(bool, tag = "5")]
    pub is_update_room: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9103)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SaveUgcDungeonDataRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub next_can_save_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9206)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub my_ugc_brief_list: ::prost::alloc::vec::Vec<UgcDungeonBrief>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9104)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelUgcDungeonReq {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9105)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelUgcDungeonRsp {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9207)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeUgcDungeonEditRoomReq {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeUgcDungeonEditRoomRsp {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EditUgcDungeonReq {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9106)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EditUgcDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9107)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditUgcDungeonSettingNotify {
    #[prost(message, optional, tag = "1")]
    pub ugc_dungeon: ::core::option::Option<UgcDungeon>,
    #[prost(uint32, repeated, tag = "2")]
    pub new_room_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9108)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditUgcDungeonNotify {
    #[prost(message, optional, tag = "1")]
    pub ugc_dungeon: ::core::option::Option<UgcDungeon>,
    #[prost(uint32, repeated, tag = "2")]
    pub new_room_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub cur_room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9109)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveUgcDungeonDeploymentReq {
    #[prost(message, optional, tag = "1")]
    pub room_data: ::core::option::Option<UgcDungeonRoom>,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9210)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SaveUgcDungeonDeploymentRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9110)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonExitStuckReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9211)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonExitStuckRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9111)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9112)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomPlayerInfo {
    #[prost(enumeration = "UgcDungeonSwitchRoomInviteState", tag = "1")]
    pub state: i32,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomInviteInfo {
    #[prost(message, repeated, tag = "1")]
    pub player_info_list: ::prost::alloc::vec::Vec<UgcDungeonSwitchRoomPlayerInfo>,
    #[prost(uint32, tag = "2")]
    pub expire_timestamp: u32,
    #[prost(uint32, tag = "3")]
    pub invite_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9113)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomInviteInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub invite_info: ::core::option::Option<UgcDungeonSwitchRoomInviteInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9114)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomInviteReplyReq {
    #[prost(bool, tag = "1")]
    pub is_accept: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9115)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomInviteReplyRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9212)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonPlayAllDataNotify {
    #[prost(message, optional, tag = "1")]
    pub ugc_dungeon: ::core::option::Option<UgcDungeon>,
    #[prost(message, optional, tag = "2")]
    pub ugc_brief_data: ::core::option::Option<UgcDungeonBrief>,
    #[prost(uint32, tag = "3")]
    pub cur_score: u32,
    #[prost(uint32, tag = "4")]
    pub enter_type: u32,
    #[prost(uint32, tag = "5")]
    pub left_death_count: u32,
    #[prost(uint32, tag = "6")]
    pub cur_room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonPlayerPersonalScore {
    #[prost(message, optional, tag = "1")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(uint32, tag = "2")]
    pub chest_score: u32,
    #[prost(uint32, tag = "3")]
    pub uid: u32,
    #[prost(uint32, tag = "4")]
    pub coin_score: u32,
    #[prost(uint32, tag = "5")]
    pub monster_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9213)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonSettleNotify {
    #[prost(message, repeated, tag = "1")]
    pub personal_score_list: ::prost::alloc::vec::Vec<UgcDungeonPlayerPersonalScore>,
    #[prost(bool, tag = "2")]
    pub is_starred: bool,
    #[prost(bool, tag = "3")]
    pub is_can_publish: bool,
    #[prost(bool, tag = "4")]
    pub is_final_succ: bool,
    #[prost(bool, tag = "5")]
    pub is_my_ugc_dungeon: bool,
    #[prost(bool, tag = "6")]
    pub is_liked: bool,
    #[prost(bool, tag = "7")]
    pub is_own_player: bool,
    #[prost(uint32, tag = "8")]
    pub enter_type: u32,
    #[prost(uint32, tag = "9")]
    pub room_settle_score: u32,
    #[prost(uint32, tag = "10")]
    pub used_time: u32,
    #[prost(uint32, tag = "11")]
    pub start_player_count: u32,
    #[prost(uint32, tag = "12")]
    pub total_score: u32,
    #[prost(uint32, tag = "13")]
    pub gallery_reason: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9214)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomInviteReplyNotify {
    #[prost(bool, tag = "1")]
    pub is_accept: bool,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9215)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonSwitchRoomInviteResultNotify {
    #[prost(bool, tag = "1")]
    pub is_succ: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9116)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartUgcDungeonReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9216)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartUgcDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9217)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hjbianejebc {
    #[prost(message, repeated, tag = "1")]
    pub avatar_info_list: ::prost::alloc::vec::Vec<UgcDungeonCandidateTeamAvatarInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9218)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Epckagoohef {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9219)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonBackToEditReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9220)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonBackToEditRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9221)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcSetUpAvatarTeamReq {
    #[prost(uint64, repeated, tag = "1")]
    pub team_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub cur_avatar_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9117)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcSetUpAvatarTeamRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9222)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonScoreNotify {
    #[prost(uint32, tag = "1")]
    pub cur_score: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9223)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonAvatarTeamInfoNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub avail_avatar_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, tag = "2")]
    pub allow_avatar_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9118)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonLeftDeathCountNotify {
    #[prost(uint32, tag = "1")]
    pub left_death_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9224)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonImportReq {
    #[prost(enumeration = "UgcDungeonImportOpType", tag = "1")]
    pub op_type: i32,
    #[prost(enumeration = "UgcDungeonImportSourceType", tag = "2")]
    pub source_type: i32,
    #[prost(uint32, tag = "3")]
    pub room_id: u32,
    #[prost(uint64, tag = "4")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9119)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonImportRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonPlayRecord {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "2")]
    pub score: u32,
    #[prost(enumeration = "UgcDungeonSettleType", tag = "3")]
    pub settle_type: i32,
    #[prost(uint32, tag = "4")]
    pub used_time: u32,
    #[prost(uint32, tag = "5")]
    pub version: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9120)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonPlayRecordNotify {
    #[prost(message, repeated, tag = "1")]
    pub play_record_list: ::prost::alloc::vec::Vec<UgcDungeonPlayRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcItemInfo {
    #[prost(uint32, tag = "1")]
    pub item_num: u32,
    #[prost(uint32, tag = "2")]
    pub item_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcRuntimePackInfo {
    #[prost(message, repeated, tag = "1")]
    pub item_info_list: ::prost::alloc::vec::Vec<UgcItemInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9121)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcGetShopGadgetInfoReq {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub shop_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9225)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcGetShopGadgetInfoRsp {
    #[prost(message, optional, tag = "1")]
    pub shop_pack_info: ::core::option::Option<UgcRuntimePackInfo>,
    #[prost(message, repeated, tag = "2")]
    pub shop_edit_item_info_list: ::prost::alloc::vec::Vec<UgcItemInfo>,
    #[prost(uint32, tag = "3")]
    pub shop_guid: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9122)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerBuyItemInShopReq {
    #[prost(message, repeated, tag = "1")]
    pub buy_item_info_list: ::prost::alloc::vec::Vec<UgcItemInfo>,
    #[prost(uint32, tag = "2")]
    pub shop_guid: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9226)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerBuyItemInShopRsp {
    #[prost(message, repeated, tag = "1")]
    pub buy_item_info_list: ::prost::alloc::vec::Vec<UgcItemInfo>,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub shop_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9227)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerBuyTowerReq {
    #[prost(uint32, tag = "1")]
    pub target_tower_id: u32,
    #[prost(uint32, tag = "2")]
    pub target_tower_state: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub tower_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9228)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerBuyTowerRsp {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub tower_guid: u32,
    #[prost(uint32, tag = "3")]
    pub target_tower_state: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
    #[prost(uint32, tag = "5")]
    pub target_tower_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9229)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcShopGadgetInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub shop_pack_info: ::core::option::Option<UgcRuntimePackInfo>,
    #[prost(uint32, tag = "2")]
    pub shop_guid: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9230)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerRuntimePackInfoNotify {
    #[prost(message, optional, tag = "1")]
    pub player_pack_info: ::core::option::Option<UgcRuntimePackInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9123)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerItemAddNotify {
    #[prost(message, repeated, tag = "1")]
    pub item_info_list: ::prost::alloc::vec::Vec<UgcItemInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9124)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerAssembleBuffReq {
    #[prost(uint32, repeated, tag = "1")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9125)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerAssembleBuffRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9126)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerBuffNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub buff_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9127)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerOpenChestReq {
    #[prost(uint32, tag = "1")]
    pub chest_guid: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9231)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerOpenChestRsp {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub chest_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9232)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcPlayerAddItemOverStackNotify {
    #[prost(message, repeated, tag = "1")]
    pub over_stack_item_info_list: ::prost::alloc::vec::Vec<UgcItemInfo>,
    #[prost(int32, tag = "2")]
    pub error_code: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9233)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerTeamLevelNotify {
    #[prost(uint32, tag = "1")]
    pub pre_team_level: u32,
    #[prost(uint32, tag = "2")]
    pub cur_level_need_exp: u32,
    #[prost(uint32, tag = "3")]
    pub cur_level_exp: u32,
    #[prost(uint32, tag = "4")]
    pub team_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9128)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerTowerLevelUpReq {
    #[prost(uint32, tag = "1")]
    pub target_level_config_id: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9129)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerTowerLevelUpRsp {
    #[prost(uint32, tag = "1")]
    pub target_level_config_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9130)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTowerLevelUpNotify {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub entity: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9131)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTowerBoughtSuccNotify {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub bought_tower_id: u32,
    #[prost(uint32, tag = "3")]
    pub tower_guid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9234)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerTowerRemoveReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9235)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerTowerRemoveRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9236)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcPlayerTowerRemoveNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9132)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nffaadbddnf {
    #[prost(string, tag = "1")]
    pub dungeon_transaction: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9133)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonMonsterWaveNextWaveNotify {
    #[prost(uint32, tag = "1")]
    pub next_wave_interval: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9134)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonOpStarredDungeonReq {
    #[prost(bool, tag = "1")]
    pub is_add: bool,
    #[prost(uint64, tag = "2")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9237)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonOpStarredDungeonRsp {
    #[prost(bool, tag = "1")]
    pub is_add: bool,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint64, tag = "3")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9135)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonOpStarredRoomReq {
    #[prost(bool, tag = "1")]
    pub is_add: bool,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
    #[prost(uint64, tag = "3")]
    pub dungeon_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9238)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonOpStarredRoomRsp {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_add: bool,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9136)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUgcDungeonBriefListReq {
    #[prost(string, tag = "1")]
    pub share_code: ::prost::alloc::string::String,
    #[prost(enumeration = "GetUgcDungeonBriefType", tag = "2")]
    pub get_brief_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9137)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUgcDungeonBriefListRsp {
    #[prost(message, repeated, tag = "1")]
    pub brief_list: ::prost::alloc::vec::Vec<UgcDungeonBrief>,
    #[prost(message, repeated, tag = "2")]
    pub starred_room_list: ::prost::alloc::vec::Vec<UgcDungeonStarredRoomData>,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(enumeration = "GetUgcDungeonBriefType", tag = "4")]
    pub get_brief_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9239)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishUgcDungeonReq {
    #[prost(uint32, repeated, tag = "1")]
    pub tag_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_allow_import: bool,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9240)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishUgcDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9241)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangePublishedUgcDungeonSettingReq {
    #[prost(uint64, tag = "1")]
    pub guid: u64,
    #[prost(bool, tag = "2")]
    pub is_allow_import: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9138)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangePublishedUgcDungeonSettingRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(bool, tag = "2")]
    pub is_allow_import: bool,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9139)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishUgcDungeonResultNotify {
    #[prost(bool, tag = "1")]
    pub is_pass_audit: bool,
    #[prost(uint32, tag = "2")]
    pub result: u32,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9140)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LikeUgcDungeonReq {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(bool, tag = "2")]
    pub is_like: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9141)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LikeUgcDungeonRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9142)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonOfficialUploadNotify {
    #[prost(string, tag = "1")]
    pub file_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub json_str: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub official_guid: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9301)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcDungeonStarredDungeonAndRoomNotify {
    #[prost(uint64, repeated, tag = "1")]
    pub starred_dungeon_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "2")]
    pub starred_room_list: ::prost::alloc::vec::Vec<UgcDungeonStarredRoomData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9143)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditUgcDungeonBriefNotify {
    #[prost(message, optional, tag = "1")]
    pub dungeon_brief: ::core::option::Option<UgcDungeonBrief>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9242)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Kecoiiejmkk {
    #[prost(uint32, tag = "1")]
    pub ban_expire_timestamp: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9243)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonFeatureSwitchNotify {
    #[prost(bool, tag = "1")]
    pub maelbholljl: bool,
    #[prost(bool, tag = "2")]
    pub ockafkemphd: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9244)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckUgcDungeonFeatureSwitchReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(9144)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckUgcDungeonFeatureSwitchRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2201)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatcherAllDataNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub watcher_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2202)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatcherChangeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub new_watcher_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub removed_watcher_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2203)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WatcherEventNotify {
    #[prost(uint32, tag = "1")]
    pub add_progress: u32,
    #[prost(uint32, tag = "2")]
    pub watcher_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2204)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatcherEventTypeNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub watcher_trigger_type: u32,
    #[prost(uint32, tag = "3")]
    pub add_progress: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2205)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WatcherEventStageNotify {
    #[prost(uint32, tag = "1")]
    pub stage: u32,
    #[prost(uint32, tag = "2")]
    pub add_progress: u32,
    #[prost(uint32, tag = "3")]
    pub watcher_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PushTipsData {
    #[prost(uint32, tag = "1")]
    pub push_tips_id: u32,
    #[prost(uint32, tag = "2")]
    pub state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2206)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushTipsAllDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub push_tips_list: ::prost::alloc::vec::Vec<PushTipsData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2207)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushTipsChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub push_tips_list: ::prost::alloc::vec::Vec<PushTipsData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2208)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PushTipsReadFinishReq {
    #[prost(uint32, tag = "1")]
    pub push_tips_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2209)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PushTipsReadFinishRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub push_tips_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2210)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPushTipsRewardReq {
    #[prost(uint32, repeated, tag = "1")]
    pub push_tips_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(2211)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPushTipsRewardRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub push_tips_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnchorPointData {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub end_time: u32,
    #[prost(uint32, tag = "4")]
    pub scene_id: u32,
    #[prost(uint32, tag = "5")]
    pub anchor_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4209)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorPointDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub anchor_point_list: ::prost::alloc::vec::Vec<AnchorPointData>,
    #[prost(uint32, tag = "2")]
    pub next_usable_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4210)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnchorPointOpReq {
    #[prost(uint32, tag = "1")]
    pub anchor_point_id: u32,
    #[prost(uint32, tag = "2")]
    pub anchor_point_op_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4211)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnchorPointOpRsp {
    #[prost(uint32, tag = "1")]
    pub anchor_point_op_type: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub anchor_point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LunchBoxData {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub slot_material_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4212)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUpLunchBoxWidgetReq {
    #[prost(message, optional, tag = "1")]
    pub lunch_box_data: ::core::option::Option<LunchBoxData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4213)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUpLunchBoxWidgetRsp {
    #[prost(message, optional, tag = "1")]
    pub lunch_box_data: ::core::option::Option<LunchBoxData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OneoffGatherPointDetectorData {
    #[prost(message, optional, tag = "1")]
    pub hint_center_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(uint32, tag = "4")]
    pub material_id: u32,
    #[prost(bool, tag = "5")]
    pub is_all_collected: bool,
    #[prost(bool, tag = "6")]
    pub is_hint_valid: bool,
    #[prost(uint32, tag = "7")]
    pub hint_radius: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientCollectorData {
    #[prost(uint32, tag = "1")]
    pub curr_points: u32,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
    #[prost(uint32, tag = "3")]
    pub max_points: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureMapDetectorData {
    #[prost(message, optional, tag = "1")]
    pub center_pos: ::core::option::Option<Vector>,
    #[prost(message, repeated, tag = "2")]
    pub spot_list: ::prost::alloc::vec::Vec<Vector>,
    #[prost(uint32, tag = "3")]
    pub radius: u32,
    #[prost(uint32, tag = "4")]
    pub region_id: u32,
    #[prost(bool, tag = "5")]
    pub is_region_detected: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkyCrystalDetectorData {
    #[prost(message, optional, tag = "1")]
    pub hint_center_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub group_id: u32,
    #[prost(bool, tag = "4")]
    pub is_hint_valid: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkyCrystalDetectorQuickUseResult {
    #[prost(message, optional, tag = "1")]
    pub sky_crystal_detector_data: ::core::option::Option<SkyCrystalDetectorData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeatherWizardData {
    #[prost(uint32, tag = "1")]
    pub shield_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushWidgetData {
    #[prost(bool, tag = "1")]
    pub is_need_destroy: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetCameraInfo {
    #[prost(uint32, tag = "1")]
    pub target_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetThunderBirdFeatherInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub entity_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetSorushInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(bool, tag = "3")]
    pub is_enter_vehicle: bool,
    #[prost(bool, tag = "4")]
    pub is_can_shot_transfer: bool,
    #[prost(bool, tag = "5")]
    pub is_destroy_vehicle: bool,
    #[prost(uint32, tag = "6")]
    pub slot: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4214)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickUseWidgetReq {
    #[prost(bool, tag = "1")]
    pub is_force_ignore_cd: bool,
    #[prost(oneof = "quick_use_widget_req::Param", tags = "2, 3, 4, 5, 6")]
    pub param: ::core::option::Option<quick_use_widget_req::Param>,
}
/// Nested message and enum types in `QuickUseWidgetReq`.
pub mod quick_use_widget_req {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(message, tag = "2")]
        LocationInfo(super::WidgetCreateLocationInfo),
        #[prost(message, tag = "3")]
        CameraInfo(super::WidgetCameraInfo),
        #[prost(message, tag = "4")]
        CreatorInfo(super::WidgetCreatorInfo),
        #[prost(message, tag = "5")]
        ThunderBirdFeatherInfo(super::WidgetThunderBirdFeatherInfo),
        #[prost(message, tag = "6")]
        SorushInfo(super::WidgetSorushInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4215)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuickUseWidgetRsp {
    #[prost(uint32, tag = "1")]
    pub material_id: u32,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(oneof = "quick_use_widget_rsp::Param", tags = "3, 4, 5")]
    pub param: ::core::option::Option<quick_use_widget_rsp::Param>,
}
/// Nested message and enum types in `QuickUseWidgetRsp`.
pub mod quick_use_widget_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(message, tag = "3")]
        DetectorData(super::OneoffGatherPointDetectorData),
        #[prost(message, tag = "4")]
        ClientCollectorData(super::ClientCollectorData),
        #[prost(message, tag = "5")]
        SkyCrystalDetectorQuickUseResult(super::SkyCrystalDetectorQuickUseResult),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetCoolDownData {
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(uint64, tag = "3")]
    pub cool_down_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4216)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetCoolDownNotify {
    #[prost(message, repeated, tag = "1")]
    pub group_cool_down_data_list: ::prost::alloc::vec::Vec<WidgetCoolDownData>,
    #[prost(message, repeated, tag = "2")]
    pub normal_cool_down_data_list: ::prost::alloc::vec::Vec<WidgetCoolDownData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4217)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetReportReq {
    #[prost(bool, tag = "1")]
    pub is_client_collect: bool,
    #[prost(bool, tag = "2")]
    pub is_clear_sky_crystal_hint: bool,
    #[prost(bool, tag = "3")]
    pub is_clear_hint: bool,
    #[prost(uint32, tag = "4")]
    pub material_id: u32,
    #[prost(uint32, tag = "5")]
    pub weather_wizard_shield_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4218)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetReportRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4219)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientCollectorDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub client_collector_data_list: ::prost::alloc::vec::Vec<ClientCollectorData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4220)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneoffGatherPointDetectorDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub oneoff_gather_point_detector_data_list: ::prost::alloc::vec::Vec<
        OneoffGatherPointDetectorData,
    >,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4221)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkyCrystalDetectorDataUpdateNotify {
    #[prost(message, optional, tag = "1")]
    pub sky_crystal_detector_data: ::core::option::Option<SkyCrystalDetectorData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4222)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureMapDetectorDataNotify {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TreasureMapDetectorData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetSlotData {
    #[prost(uint32, tag = "1")]
    pub material_id: u32,
    #[prost(uint32, tag = "2")]
    pub cd_over_time: u32,
    #[prost(bool, tag = "3")]
    pub is_active: bool,
    #[prost(enumeration = "WidgetSlotTag", tag = "4")]
    pub tag: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4322)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWidgetSlotReq {
    #[prost(enumeration = "WidgetSlotTag", repeated, tag = "1")]
    pub tag_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
    #[prost(enumeration = "WidgetSlotOp", tag = "3")]
    pub op: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4223)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWidgetSlotRsp {
    #[prost(enumeration = "WidgetSlotTag", repeated, tag = "1")]
    pub tag_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "WidgetSlotOp", tag = "2")]
    pub op: i32,
    #[prost(uint32, tag = "3")]
    pub material_id: u32,
    #[prost(int32, tag = "4")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4224)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetSlotChangeNotify {
    #[prost(message, optional, tag = "1")]
    pub slot: ::core::option::Option<WidgetSlotData>,
    #[prost(enumeration = "WidgetSlotOp", tag = "2")]
    pub op: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4225)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWidgetSlotReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4226)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWidgetSlotRsp {
    #[prost(message, repeated, tag = "1")]
    pub slot_list: ::prost::alloc::vec::Vec<WidgetSlotData>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4227)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllWidgetDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub oneoff_gather_point_detector_data_list: ::prost::alloc::vec::Vec<
        OneoffGatherPointDetectorData,
    >,
    #[prost(message, optional, tag = "2")]
    pub lunch_box_data: ::core::option::Option<LunchBoxData>,
    #[prost(uint32, repeated, tag = "3")]
    pub material_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub slot_list: ::prost::alloc::vec::Vec<WidgetSlotData>,
    #[prost(message, repeated, tag = "5")]
    pub cool_down_group_data_list: ::prost::alloc::vec::Vec<WidgetCoolDownData>,
    #[prost(message, repeated, tag = "6")]
    pub client_collector_data_list: ::prost::alloc::vec::Vec<ClientCollectorData>,
    #[prost(message, optional, tag = "7")]
    pub sorush_widget_data: ::core::option::Option<SorushWidgetData>,
    #[prost(uint32, repeated, tag = "8")]
    pub background_active_widget_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "9")]
    pub weather_wizard_data: ::core::option::Option<WeatherWizardData>,
    #[prost(message, repeated, tag = "10")]
    pub anchor_point_list: ::prost::alloc::vec::Vec<AnchorPointData>,
    #[prost(message, optional, tag = "11")]
    pub sky_crystal_detector_data: ::core::option::Option<SkyCrystalDetectorData>,
    #[prost(message, repeated, tag = "12")]
    pub normal_cool_down_data_list: ::prost::alloc::vec::Vec<WidgetCoolDownData>,
    #[prost(uint32, tag = "13")]
    pub ehhhnebojil: u32,
    #[prost(uint32, tag = "14")]
    pub next_anchor_point_usable_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4228)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseWidgetCreateGadgetReq {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "3")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4229)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseWidgetCreateGadgetRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4230)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseWidgetRetractGadgetReq {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4231)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseWidgetRetractGadgetRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetGadgetData {
    #[prost(uint32, repeated, tag = "1")]
    pub gadget_entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub gadget_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4232)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetGadgetAllDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub widget_gadget_data: ::prost::alloc::vec::Vec<WidgetGadgetData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4233)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetGadgetDataNotify {
    #[prost(message, optional, tag = "1")]
    pub widget_gadget_data: ::core::option::Option<WidgetGadgetData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4234)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetGadgetDestroyNotify {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetCreateLocationInfo {
    #[prost(message, optional, tag = "1")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetCreatorInfo {
    #[prost(message, optional, tag = "1")]
    pub location_info: ::core::option::Option<WidgetCreateLocationInfo>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(enumeration = "WidgetCreatorOpType", tag = "3")]
    pub op_type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4235)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetDoBagReq {
    #[prost(uint32, tag = "1")]
    pub material_id: u32,
    #[prost(oneof = "widget_do_bag_req::OpInfo", tags = "2, 3")]
    pub op_info: ::core::option::Option<widget_do_bag_req::OpInfo>,
}
/// Nested message and enum types in `WidgetDoBagReq`.
pub mod widget_do_bag_req {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OpInfo {
        #[prost(message, tag = "2")]
        LocationInfo(super::WidgetCreateLocationInfo),
        #[prost(message, tag = "3")]
        WidgetCreatorInfo(super::WidgetCreatorInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4236)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetDoBagRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4237)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetActiveChangeNotify {
    #[prost(message, repeated, tag = "1")]
    pub widget_data_list: ::prost::alloc::vec::Vec<WidgetSlotData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4238)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetUseAttachAbilityGroupChangeNotify {
    #[prost(uint32, tag = "1")]
    pub material_id: u32,
    #[prost(bool, tag = "2")]
    pub is_attach: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4239)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetCaptureAnimalReq {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(4240)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetCaptureAnimalRsp {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5901)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetUpdateExtraCdReq {
    #[prost(uint32, tag = "1")]
    pub cd_group: u32,
    #[prost(enumeration = "WidgetExtraCdType", tag = "2")]
    pub extra_cd_type: i32,
    #[prost(uint32, tag = "3")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6001)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetUpdateExtraCdRsp {
    #[prost(message, optional, tag = "1")]
    pub cool_data: ::core::option::Option<WidgetCoolDownData>,
    #[prost(enumeration = "WidgetExtraCdType", tag = "2")]
    pub extra_cd_type: i32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
    #[prost(uint32, tag = "4")]
    pub cd_group: u32,
    #[prost(uint32, tag = "5")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FireworksReformParam {
    #[prost(enumeration = "FireworksReformParamType", tag = "1")]
    pub r#type: i32,
    #[prost(int32, tag = "2")]
    pub value: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FireworksReformData {
    #[prost(message, repeated, tag = "1")]
    pub reform_param_list: ::prost::alloc::vec::Vec<FireworksReformParam>,
    #[prost(uint32, tag = "2")]
    pub id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6002)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FireworksReformDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub fireworks_reform_data_list: ::prost::alloc::vec::Vec<FireworksReformData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6003)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReformFireworksReq {
    #[prost(message, optional, tag = "1")]
    pub fireworks_reform_data: ::core::option::Option<FireworksReformData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5902)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReformFireworksRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FireworksLaunchParam {
    #[prost(int32, tag = "1")]
    pub value: i32,
    #[prost(enumeration = "FireworksLaunchParamType", tag = "2")]
    pub r#type: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FireworksLaunchSchemeData {
    #[prost(message, repeated, tag = "1")]
    pub launch_param_list: ::prost::alloc::vec::Vec<FireworksLaunchParam>,
    #[prost(uint32, repeated, tag = "2")]
    pub fireworks_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub scheme_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5903)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaunchFireworksReq {
    #[prost(message, optional, tag = "1")]
    pub scheme_data: ::core::option::Option<FireworksLaunchSchemeData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5904)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LaunchFireworksRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6004)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FireworksLaunchDataNotify {
    #[prost(message, repeated, tag = "1")]
    pub scheme_data_list: ::prost::alloc::vec::Vec<FireworksLaunchSchemeData>,
    #[prost(uint32, tag = "2")]
    pub last_use_scheme_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6005)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeWidgetBackgroundActiveStateReq {
    #[prost(bool, tag = "1")]
    pub is_active: bool,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5905)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeWidgetBackgroundActiveStateRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(uint32, tag = "2")]
    pub material_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5906)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllWidgetBackgroundActiveStateNotify {
    #[prost(uint32, repeated, tag = "1")]
    pub background_active_widget_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerWidgetInfo {
    #[prost(message, repeated, tag = "1")]
    pub slot_list: ::prost::alloc::vec::Vec<WidgetSlotData>,
    #[prost(uint32, tag = "2")]
    pub uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6006)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemotePlayerWidgetNotify {
    #[prost(message, repeated, tag = "1")]
    pub player_widget_info_list: ::prost::alloc::vec::Vec<PlayerWidgetInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6007)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WidgetWeatherWizardDataNotify {
    #[prost(uint32, tag = "1")]
    pub shield_value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5907)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SorushWidgetDataNotify {
    #[prost(message, optional, tag = "1")]
    pub sorush_widget_data: ::core::option::Option<SorushWidgetData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5908)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWidgetQuickSlotListReq {
    #[prost(uint32, repeated, tag = "1")]
    pub material_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub ehhhnebojil: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(5909)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWidgetQuickSlotListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub material_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "2")]
    pub ehhhnebojil: u32,
    #[prost(int32, tag = "3")]
    pub retcode: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6008)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWidgetQuickSlotListReq {}
#[derive(sakura_proto_derive::CmdID)]
#[cmdid(6009)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWidgetQuickSlotListRsp {
    #[prost(uint32, repeated, tag = "1")]
    pub material_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "2")]
    pub retcode: i32,
    #[prost(uint32, tag = "3")]
    pub ehhhnebojil: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamList {
    #[prost(uint32, repeated, tag = "1")]
    pub param_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PropValue {
    #[prost(uint32, tag = "1")]
    pub r#type: u32,
    #[prost(int64, tag = "2")]
    pub val: i64,
    #[prost(oneof = "prop_value::Value", tags = "3, 4")]
    pub value: ::core::option::Option<prop_value::Value>,
}
/// Nested message and enum types in `PropValue`.
pub mod prop_value {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "3")]
        Ival(i64),
        #[prost(float, tag = "4")]
        Fval(f32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Uint32Pair {
    #[prost(uint32, tag = "1")]
    pub key: u32,
    #[prost(uint32, tag = "2")]
    pub value: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionSimpleInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub dispatch_url: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRegionListHttpRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(message, repeated, tag = "2")]
    pub region_list: ::prost::alloc::vec::Vec<RegionSimpleInfo>,
    #[prost(bytes = "vec", tag = "5")]
    pub client_secret_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub client_custom_config_encrypted: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "7")]
    pub enable_login_pc: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceUpdateInfo {
    #[prost(string, tag = "1")]
    pub force_update_url: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopServerInfo {
    #[prost(uint32, tag = "1")]
    pub stop_begin_time: u32,
    #[prost(uint32, tag = "2")]
    pub stop_end_time: u32,
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content_msg: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResVersionConfig {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(bool, tag = "2")]
    pub relogin: bool,
    #[prost(string, tag = "3")]
    pub md5: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub release_total_size: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub version_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub branch: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub next_script_version: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInfo {
    #[prost(string, tag = "1")]
    pub gateserver_ip: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub gateserver_port: u32,
    #[prost(string, tag = "3")]
    pub pay_callback_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub area_type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub resource_url: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub data_url: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub feedback_url: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub bulletin_url: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub resource_url_bak: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub data_url_bak: ::prost::alloc::string::String,
    #[prost(uint32, tag = "11")]
    pub client_data_version: u32,
    #[prost(string, tag = "12")]
    pub handbook_url: ::prost::alloc::string::String,
    #[prost(uint32, tag = "13")]
    pub client_silence_data_version: u32,
    #[prost(string, tag = "14")]
    pub client_data_md5: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub client_silence_data_md5: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub res_version_config: ::core::option::Option<ResVersionConfig>,
    #[prost(bytes = "vec", tag = "17")]
    pub secret_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "18")]
    pub official_community_url: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub client_version_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub client_silence_version_suffix: ::prost::alloc::string::String,
    #[prost(bool, tag = "21")]
    pub use_gateserver_domain_name: bool,
    #[prost(string, tag = "22")]
    pub gateserver_domain_name: ::prost::alloc::string::String,
    #[prost(string, tag = "23")]
    pub user_center_url: ::prost::alloc::string::String,
    #[prost(string, tag = "24")]
    pub account_bind_url: ::prost::alloc::string::String,
    #[prost(string, tag = "25")]
    pub cdkey_url: ::prost::alloc::string::String,
    #[prost(string, tag = "26")]
    pub privacy_policy_url: ::prost::alloc::string::String,
    #[prost(string, tag = "27")]
    pub next_resource_url: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "28")]
    pub next_res_version_config: ::core::option::Option<ResVersionConfig>,
    #[prost(string, tag = "29")]
    pub game_biz: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCurrRegionHttpRsp {
    #[prost(int32, tag = "1")]
    pub retcode: i32,
    #[prost(string, tag = "2")]
    pub msg: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub region_info: ::core::option::Option<RegionInfo>,
    #[prost(bytes = "vec", tag = "11")]
    pub client_secret_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "12")]
    pub region_custom_config_encrypted: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub client_region_custom_config_encrypted: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "14")]
    pub connect_gate_ticket: ::prost::alloc::string::String,
    #[prost(oneof = "query_curr_region_http_rsp::Detail", tags = "4, 5")]
    pub detail: ::core::option::Option<query_curr_region_http_rsp::Detail>,
}
/// Nested message and enum types in `QueryCurrRegionHttpRsp`.
pub mod query_curr_region_http_rsp {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "4")]
        ForceUpdate(super::ForceUpdateInfo),
        #[prost(message, tag = "5")]
        StopServer(super::StopServerInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reliquary {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub exp: u32,
    #[prost(uint32, tag = "3")]
    pub promote_level: u32,
    #[prost(uint32, tag = "4")]
    pub main_prop_id: u32,
    #[prost(uint32, repeated, tag = "5")]
    pub append_prop_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Weapon {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub exp: u32,
    #[prost(uint32, tag = "3")]
    pub promote_level: u32,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub affix_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaterialDeleteInfo {
    #[prost(bool, tag = "1")]
    pub has_delete_config: bool,
    #[prost(oneof = "material_delete_info::DeleteInfo", tags = "2, 3, 4")]
    pub delete_info: ::core::option::Option<material_delete_info::DeleteInfo>,
}
/// Nested message and enum types in `MaterialDeleteInfo`.
pub mod material_delete_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeleteInfo {
        #[prost(message, tag = "2")]
        CountDownDelete(super::CountDownDelete),
        #[prost(message, tag = "3")]
        DateDelete(super::DateTimeDelete),
        #[prost(message, tag = "4")]
        DelayWeekCountDownDelete(super::DelayWeekCountDownDelete),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountDownDelete {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub delete_time_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub config_count_down_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateTimeDelete {
    #[prost(uint32, tag = "1")]
    pub delete_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelayWeekCountDownDelete {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub delete_time_num_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "2")]
    pub config_delay_week: u32,
    #[prost(uint32, tag = "3")]
    pub config_count_down_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Material {
    #[prost(uint32, tag = "1")]
    pub count: u32,
    #[prost(message, optional, tag = "2")]
    pub delete_info: ::core::option::Option<MaterialDeleteInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Equip {
    #[prost(bool, tag = "1")]
    pub is_locked: bool,
    #[prost(oneof = "equip::Detail", tags = "2, 3")]
    pub detail: ::core::option::Option<equip::Detail>,
}
/// Nested message and enum types in `Equip`.
pub mod equip {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "2")]
        Reliquary(super::Reliquary),
        #[prost(message, tag = "3")]
        Weapon(super::Weapon),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Furniture {
    #[prost(uint32, tag = "1")]
    pub count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Item {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
    #[prost(oneof = "item::Detail", tags = "3, 4, 5")]
    pub detail: ::core::option::Option<item::Detail>,
}
/// Nested message and enum types in `Item`.
pub mod item {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "3")]
        Material(super::Material),
        #[prost(message, tag = "4")]
        Equip(super::Equip),
        #[prost(message, tag = "5")]
        Furniture(super::Furniture),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ItemParam {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(uint32, tag = "2")]
    pub count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EquipParam {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(uint32, tag = "2")]
    pub item_num: u32,
    #[prost(uint32, tag = "3")]
    pub item_level: u32,
    #[prost(uint32, tag = "4")]
    pub promote_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reward {
    #[prost(uint32, tag = "1")]
    pub reward_id: u32,
    #[prost(message, repeated, tag = "2")]
    pub item_list: ::prost::alloc::vec::Vec<ItemParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityString {
    #[prost(oneof = "ability_string::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<ability_string::Type>,
}
/// Nested message and enum types in `AbilityString`.
pub mod ability_string {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(string, tag = "1")]
        Str(::prost::alloc::string::String),
        #[prost(uint32, tag = "2")]
        Hash(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityScalarValueEntry {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<AbilityString>,
    #[prost(enumeration = "AbilityScalarType", tag = "2")]
    pub value_type: i32,
    #[prost(oneof = "ability_scalar_value_entry::Value", tags = "3, 4, 5, 6")]
    pub value: ::core::option::Option<ability_scalar_value_entry::Value>,
}
/// Nested message and enum types in `AbilityScalarValueEntry`.
pub mod ability_scalar_value_entry {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(float, tag = "3")]
        FloatValue(f32),
        #[prost(string, tag = "4")]
        StringValue(::prost::alloc::string::String),
        #[prost(int32, tag = "5")]
        IntValue(i32),
        #[prost(uint32, tag = "6")]
        UintValue(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityAppliedAbility {
    #[prost(message, optional, tag = "1")]
    pub ability_name: ::core::option::Option<AbilityString>,
    #[prost(message, optional, tag = "2")]
    pub ability_override: ::core::option::Option<AbilityString>,
    #[prost(message, repeated, tag = "3")]
    pub override_map: ::prost::alloc::vec::Vec<AbilityScalarValueEntry>,
    #[prost(uint32, tag = "4")]
    pub instanced_ability_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityAttachedModifier {
    #[prost(bool, tag = "1")]
    pub is_invalid: bool,
    #[prost(uint32, tag = "2")]
    pub owner_entity_id: u32,
    #[prost(uint32, tag = "3")]
    pub instanced_modifier_id: u32,
    #[prost(bool, tag = "4")]
    pub is_serverbuff_modifier: bool,
    #[prost(int32, tag = "5")]
    pub attach_name_hash: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModifierDurability {
    #[prost(float, tag = "1")]
    pub reduce_ratio: f32,
    #[prost(float, tag = "2")]
    pub remaining_durability: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityAppliedModifier {
    #[prost(int32, tag = "1")]
    pub modifier_local_id: i32,
    #[prost(uint32, tag = "2")]
    pub parent_ability_entity_id: u32,
    #[prost(message, optional, tag = "3")]
    pub parent_ability_name: ::core::option::Option<AbilityString>,
    #[prost(message, optional, tag = "4")]
    pub parent_ability_override: ::core::option::Option<AbilityString>,
    #[prost(uint32, tag = "5")]
    pub instanced_ability_id: u32,
    #[prost(uint32, tag = "6")]
    pub instanced_modifier_id: u32,
    #[prost(float, tag = "7")]
    pub exist_duration: f32,
    #[prost(message, optional, tag = "8")]
    pub attached_instanced_modifier: ::core::option::Option<AbilityAttachedModifier>,
    #[prost(uint32, tag = "9")]
    pub apply_entity_id: u32,
    #[prost(bool, tag = "10")]
    pub is_attached_parent_ability: bool,
    #[prost(message, optional, tag = "11")]
    pub modifier_durability: ::core::option::Option<ModifierDurability>,
    #[prost(uint32, tag = "12")]
    pub sbuff_uid: u32,
    #[prost(bool, tag = "13")]
    pub is_serverbuff_modifier: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MassivePropParam {
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    #[prost(uint32, repeated, tag = "2")]
    pub reaction_info_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, repeated, tag = "3")]
    pub param_list: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, tag = "4")]
    pub sync_flag: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MassivePropSyncInfo {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(message, repeated, tag = "2")]
    pub prop_list: ::prost::alloc::vec::Vec<MassivePropParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutVector2 {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutBrickInfo {
    #[prost(uint32, tag = "1")]
    pub hp: u32,
    #[prost(uint32, tag = "2")]
    pub element_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutPhysicalObjectModifier {
    #[prost(uint32, tag = "1")]
    pub r#type: u32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(int32, tag = "3")]
    pub param1: i32,
    #[prost(int32, tag = "4")]
    pub param2: i32,
    #[prost(int32, tag = "5")]
    pub param3: i32,
    #[prost(int32, tag = "6")]
    pub param4: i32,
    #[prost(int32, tag = "7")]
    pub param5: i32,
    #[prost(int32, tag = "8")]
    pub param6: i32,
    #[prost(bool, tag = "9")]
    pub bool1: bool,
    #[prost(int32, tag = "10")]
    pub duration: i32,
    #[prost(int32, tag = "11")]
    pub end_time: i32,
    #[prost(uint32, tag = "12")]
    pub combo: u32,
    #[prost(uint32, tag = "13")]
    pub peer_id: u32,
    #[prost(uint32, tag = "14")]
    pub skill_type: u32,
    #[prost(uint32, tag = "15")]
    pub level: u32,
    #[prost(uint32, tag = "16")]
    pub choose_player_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BreakoutPhysicalObject {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub index: u32,
    #[prost(bool, tag = "3")]
    pub is_active: bool,
    #[prost(message, optional, tag = "4")]
    pub pos: ::core::option::Option<BreakoutVector2>,
    #[prost(message, optional, tag = "5")]
    pub move_dir: ::core::option::Option<BreakoutVector2>,
    #[prost(int32, tag = "6")]
    pub speed: i32,
    #[prost(uint32, tag = "7")]
    pub init_peer_id: u32,
    #[prost(uint32, tag = "8")]
    pub state: u32,
    #[prost(uint32, tag = "9")]
    pub element_type: u32,
    #[prost(uint32, tag = "10")]
    pub element_reaction_buff: u32,
    #[prost(message, repeated, tag = "11")]
    pub modifier_list: ::prost::alloc::vec::Vec<BreakoutPhysicalObjectModifier>,
    #[prost(int32, tag = "12")]
    pub total_rotation: i32,
    #[prost(message, repeated, tag = "13")]
    pub info_list: ::prost::alloc::vec::Vec<BreakoutBrickInfo>,
    #[prost(uint32, tag = "14")]
    pub last_hit_peer_id: u32,
    #[prost(uint32, tag = "15")]
    pub speed_increase_count: u32,
    #[prost(int32, tag = "16")]
    pub offset: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BreakoutSpawnPoint {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub brick_suite_id: u32,
    #[prost(message, repeated, tag = "3")]
    pub spawned_brick_list: ::prost::alloc::vec::Vec<BreakoutPhysicalObject>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutElementReactionCounter {
    #[prost(uint32, tag = "1")]
    pub element_reaction: u32,
    #[prost(uint32, tag = "2")]
    pub count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BreakoutSyncConnectUidInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, repeated, tag = "2")]
    pub skill_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub skill_level_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BreakoutSnapShot {
    #[prost(uint64, tag = "1")]
    pub client_game_time: u64,
    #[prost(uint64, tag = "2")]
    pub server_game_time: u64,
    #[prost(message, repeated, tag = "3")]
    pub ball_list: ::prost::alloc::vec::Vec<BreakoutPhysicalObject>,
    #[prost(message, repeated, tag = "4")]
    pub physical_object_list: ::prost::alloc::vec::Vec<BreakoutPhysicalObject>,
    #[prost(message, repeated, tag = "5")]
    pub action_list: ::prost::alloc::vec::Vec<BreakoutAction>,
    #[prost(uint32, tag = "6")]
    pub wave_index: u32,
    #[prost(bool, tag = "7")]
    pub is_finish: bool,
    #[prost(uint32, tag = "8")]
    pub score: u32,
    #[prost(uint32, tag = "9")]
    pub combo: u32,
    #[prost(uint32, tag = "10")]
    pub max_combo: u32,
    #[prost(uint32, tag = "11")]
    pub life_count: u32,
    #[prost(uint32, tag = "12")]
    pub wave_suite_index: u32,
    #[prost(message, repeated, tag = "13")]
    pub spawn_point_list: ::prost::alloc::vec::Vec<BreakoutSpawnPoint>,
    #[prost(uint32, tag = "14")]
    pub remaining_boss_hp: u32,
    #[prost(message, repeated, tag = "15")]
    pub brick_element_reaction_list: ::prost::alloc::vec::Vec<
        BreakoutElementReactionCounter,
    >,
    #[prost(message, repeated, tag = "16")]
    pub ball_element_reaction_list: ::prost::alloc::vec::Vec<
        BreakoutElementReactionCounter,
    >,
    #[prost(message, repeated, tag = "17")]
    pub uid_info_list: ::prost::alloc::vec::Vec<BreakoutSyncConnectUidInfo>,
    #[prost(message, repeated, tag = "18")]
    pub dynamic_object_list: ::prost::alloc::vec::Vec<BreakoutPhysicalObject>,
    #[prost(uint32, repeated, tag = "19")]
    pub id_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, tag = "20")]
    pub raw_client_game_time: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BreakoutAction {
    #[prost(enumeration = "BreakoutActionType", tag = "1")]
    pub action_type: i32,
    #[prost(uint64, tag = "2")]
    pub client_game_time: u64,
    #[prost(uint64, tag = "3")]
    pub server_game_time: u64,
    #[prost(bool, tag = "4")]
    pub is_failed: bool,
    #[prost(uint32, tag = "5")]
    pub pre_index: u32,
    #[prost(uint32, tag = "6")]
    pub new_index: u32,
    #[prost(message, optional, tag = "7")]
    pub pos: ::core::option::Option<BreakoutVector2>,
    #[prost(message, optional, tag = "8")]
    pub move_dir: ::core::option::Option<BreakoutVector2>,
    #[prost(int32, tag = "9")]
    pub speed: i32,
    #[prost(uint32, tag = "10")]
    pub peer_id: u32,
    #[prost(uint32, tag = "11")]
    pub element_type: u32,
    #[prost(uint32, tag = "12")]
    pub element_reaction_buff: u32,
    #[prost(uint32, tag = "13")]
    pub speed_increase_count: u32,
    #[prost(bool, tag = "14")]
    pub has_extra_ball: bool,
    #[prost(message, optional, tag = "15")]
    pub extra_ball_dir: ::core::option::Option<BreakoutVector2>,
    #[prost(uint32, tag = "16")]
    pub extra_ball_index: u32,
    #[prost(int32, tag = "17")]
    pub offset: i32,
    #[prost(uint64, tag = "18")]
    pub execution_game_time: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityMixinRecoverInfo {
    #[prost(uint32, tag = "1")]
    pub local_id: u32,
    #[prost(uint32, repeated, tag = "2")]
    pub data_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_serverbuff_modifier: bool,
    #[prost(message, repeated, tag = "4")]
    pub massive_prop_list: ::prost::alloc::vec::Vec<MassivePropSyncInfo>,
    #[prost(message, optional, tag = "5")]
    pub breakout_snap_shot: ::core::option::Option<BreakoutSnapShot>,
    #[prost(oneof = "ability_mixin_recover_info::Source", tags = "6, 7")]
    pub source: ::core::option::Option<ability_mixin_recover_info::Source>,
}
/// Nested message and enum types in `AbilityMixinRecoverInfo`.
pub mod ability_mixin_recover_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(uint32, tag = "6")]
        InstancedAbilityId(u32),
        #[prost(uint32, tag = "7")]
        InstancedModifierId(u32),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilitySyncStateInfo {
    #[prost(bool, tag = "1")]
    pub is_inited: bool,
    #[prost(message, repeated, tag = "2")]
    pub dynamic_value_map: ::prost::alloc::vec::Vec<AbilityScalarValueEntry>,
    #[prost(message, repeated, tag = "3")]
    pub applied_abilities: ::prost::alloc::vec::Vec<AbilityAppliedAbility>,
    #[prost(message, repeated, tag = "4")]
    pub applied_modifiers: ::prost::alloc::vec::Vec<AbilityAppliedModifier>,
    #[prost(message, repeated, tag = "5")]
    pub mixin_recover_infos: ::prost::alloc::vec::Vec<AbilityMixinRecoverInfo>,
    #[prost(message, repeated, tag = "6")]
    pub sgv_dynamic_value_map: ::prost::alloc::vec::Vec<AbilityScalarValueEntry>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityEmbryo {
    #[prost(uint32, tag = "1")]
    pub ability_id: u32,
    #[prost(fixed32, tag = "2")]
    pub ability_name_hash: u32,
    #[prost(fixed32, tag = "3")]
    pub ability_override_name_hash: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbilityControlBlock {
    #[prost(message, repeated, tag = "1")]
    pub ability_embryo_list: ::prost::alloc::vec::Vec<AbilityEmbryo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub z: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VectorPlane {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector3Int {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
    #[prost(int32, tag = "3")]
    pub z: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMoveInfo {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(message, optional, tag = "2")]
    pub motion_info: ::core::option::Option<MotionInfo>,
    #[prost(uint32, tag = "3")]
    pub scene_time: u32,
    #[prost(uint32, tag = "4")]
    pub reliable_seq: u32,
    #[prost(bool, tag = "5")]
    pub is_reliable: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MotionInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub speed: ::core::option::Option<Vector>,
    #[prost(enumeration = "MotionState", tag = "4")]
    pub state: i32,
    #[prost(message, repeated, tag = "5")]
    pub params: ::prost::alloc::vec::Vec<Vector>,
    #[prost(message, optional, tag = "6")]
    pub ref_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "7")]
    pub ref_id: u32,
    #[prost(uint32, tag = "8")]
    pub scene_time: u32,
    #[prost(uint64, tag = "9")]
    pub interval_velocity: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlaceInfo {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub rot: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneWeaponInfo {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub gadget_id: u32,
    #[prost(uint32, tag = "3")]
    pub item_id: u32,
    #[prost(uint64, tag = "4")]
    pub guid: u64,
    #[prost(uint32, tag = "5")]
    pub level: u32,
    #[prost(uint32, tag = "6")]
    pub promote_level: u32,
    #[prost(message, optional, tag = "7")]
    pub ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(map = "uint32, uint32", tag = "8")]
    pub affix_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, optional, tag = "9")]
    pub renderer_changed_info: ::core::option::Option<EntityRendererChangedInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneReliquaryInfo {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
    #[prost(uint32, tag = "3")]
    pub level: u32,
    #[prost(uint32, tag = "4")]
    pub promote_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerBuff {
    #[prost(uint32, tag = "1")]
    pub server_buff_uid: u32,
    #[prost(uint32, tag = "2")]
    pub server_buff_id: u32,
    #[prost(uint32, tag = "3")]
    pub server_buff_type: u32,
    #[prost(uint32, tag = "4")]
    pub instanced_modifier_id: u32,
    #[prost(bool, tag = "5")]
    pub is_modifier_added: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CurVehicleInfo {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub pos: u32,
    #[prost(uint32, tag = "3")]
    pub gadget_id: u32,
    #[prost(message, optional, tag = "4")]
    pub enter_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "5")]
    pub vehicle_type: u32,
    #[prost(message, optional, tag = "6")]
    pub enter_rot: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarExcelInfo {
    #[prost(uint64, tag = "1")]
    pub prefab_path_hash: u64,
    #[prost(uint64, tag = "2")]
    pub prefab_path_remote_hash: u64,
    #[prost(uint64, tag = "3")]
    pub controller_path_hash: u64,
    #[prost(uint64, tag = "4")]
    pub controller_path_remote_hash: u64,
    #[prost(uint64, tag = "5")]
    pub combat_config_hash: u64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "2")]
    pub avatar_id: u32,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
    #[prost(uint32, tag = "4")]
    pub peer_id: u32,
    #[prost(uint32, repeated, tag = "5")]
    pub equip_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "6")]
    pub skill_depot_id: u32,
    #[prost(uint32, repeated, tag = "7")]
    pub talent_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "8")]
    pub weapon: ::core::option::Option<SceneWeaponInfo>,
    #[prost(message, repeated, tag = "9")]
    pub reliquary_list: ::prost::alloc::vec::Vec<SceneReliquaryInfo>,
    #[prost(uint32, tag = "10")]
    pub core_proud_skill_level: u32,
    #[prost(uint32, repeated, tag = "11")]
    pub inherent_proud_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "12")]
    pub skill_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "13")]
    pub proud_skill_extra_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, repeated, tag = "14")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(uint32, repeated, tag = "15")]
    pub team_resonance_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "16")]
    pub wearing_flycloak_id: u32,
    #[prost(uint32, tag = "17")]
    pub born_time: u32,
    #[prost(uint32, tag = "18")]
    pub costume_id: u32,
    #[prost(message, optional, tag = "19")]
    pub cur_vehicle_info: ::core::option::Option<CurVehicleInfo>,
    #[prost(message, optional, tag = "20")]
    pub excel_info: ::core::option::Option<AvatarExcelInfo>,
    #[prost(uint32, tag = "21")]
    pub anim_hash: u32,
    #[prost(uint32, tag = "22")]
    pub trace_effect_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneFishInfo {
    #[prost(uint32, tag = "1")]
    pub fish_id: u32,
    #[prost(uint32, tag = "2")]
    pub fish_pool_entity_id: u32,
    #[prost(message, optional, tag = "3")]
    pub fish_pool_pos: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub fish_pool_gadget_id: u32,
    #[prost(uint32, tag = "5")]
    pub last_shock_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FishtankFishInfo {
    #[prost(float, tag = "1")]
    pub fish_distance_from_water: f32,
    #[prost(float, tag = "2")]
    pub fish_scale: f32,
    #[prost(float, tag = "3")]
    pub initial_rotation_y: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneMonsterInfo {
    #[prost(uint32, tag = "1")]
    pub monster_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
    #[prost(message, repeated, tag = "4")]
    pub weapon_list: ::prost::alloc::vec::Vec<SceneWeaponInfo>,
    #[prost(uint32, tag = "5")]
    pub authority_peer_id: u32,
    #[prost(uint32, repeated, tag = "6")]
    pub affix_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "7")]
    pub is_elite: bool,
    #[prost(uint32, tag = "8")]
    pub owner_entity_id: u32,
    #[prost(uint32, tag = "9")]
    pub summoned_tag: u32,
    #[prost(map = "uint32, uint32", tag = "10")]
    pub summon_tag_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "11")]
    pub pose_id: u32,
    #[prost(enumeration = "MonsterBornType", tag = "12")]
    pub born_type: i32,
    #[prost(uint32, tag = "13")]
    pub block_id: u32,
    #[prost(uint32, tag = "14")]
    pub mark_flag: u32,
    #[prost(uint32, tag = "15")]
    pub title_id: u32,
    #[prost(uint32, tag = "16")]
    pub special_name_id: u32,
    #[prost(uint32, tag = "17")]
    pub attack_target_id: u32,
    #[prost(message, optional, tag = "18")]
    pub monster_route: ::core::option::Option<MonsterRoute>,
    #[prost(uint32, tag = "19")]
    pub ai_config_id: u32,
    #[prost(uint32, tag = "20")]
    pub level_route_id: u32,
    #[prost(uint32, tag = "21")]
    pub init_pose_id: u32,
    #[prost(bool, tag = "22")]
    pub is_light: bool,
    #[prost(uint32, tag = "23")]
    pub kill_num: u32,
    #[prost(oneof = "scene_monster_info::Content", tags = "24, 25")]
    pub content: ::core::option::Option<scene_monster_info::Content>,
}
/// Nested message and enum types in `SceneMonsterInfo`.
pub mod scene_monster_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "24")]
        FishInfo(super::SceneFishInfo),
        #[prost(message, tag = "25")]
        FishtankFishInfo(super::FishtankFishInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneNpcInfo {
    #[prost(uint32, tag = "1")]
    pub npc_id: u32,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
    #[prost(uint32, tag = "3")]
    pub parent_quest_id: u32,
    #[prost(uint32, tag = "4")]
    pub block_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorktopInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub option_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub is_guest_can_operate: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MathQuaternion {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub z: f32,
    #[prost(float, tag = "4")]
    pub w: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformInfo {
    #[prost(uint32, tag = "1")]
    pub route_id: u32,
    #[prost(int32, tag = "2")]
    pub start_index: i32,
    #[prost(uint32, tag = "3")]
    pub start_route_time: u32,
    #[prost(uint32, tag = "4")]
    pub start_scene_time: u32,
    #[prost(message, optional, tag = "5")]
    pub start_pos: ::core::option::Option<Vector>,
    #[prost(bool, tag = "6")]
    pub is_started: bool,
    #[prost(message, optional, tag = "7")]
    pub start_rot: ::core::option::Option<MathQuaternion>,
    #[prost(uint32, tag = "8")]
    pub stop_scene_time: u32,
    #[prost(message, optional, tag = "9")]
    pub pos_offset: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "10")]
    pub rot_offset: ::core::option::Option<MathQuaternion>,
    #[prost(enumeration = "MovingPlatformType", tag = "11")]
    pub moving_platform_type: i32,
    #[prost(bool, tag = "12")]
    pub is_active: bool,
    #[prost(message, optional, tag = "13")]
    pub route: ::core::option::Option<Route>,
    #[prost(uint32, tag = "14")]
    pub point_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoutePoint {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector>,
    #[prost(float, tag = "2")]
    pub arrive_range: f32,
    #[prost(bool, tag = "3")]
    pub has_reach_event: bool,
    #[prost(oneof = "route_point::MoveParams", tags = "4, 5")]
    pub move_params: ::core::option::Option<route_point::MoveParams>,
    #[prost(oneof = "route_point::RotateParams", tags = "6, 7, 8")]
    pub rotate_params: ::core::option::Option<route_point::RotateParams>,
}
/// Nested message and enum types in `RoutePoint`.
pub mod route_point {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum MoveParams {
        #[prost(float, tag = "4")]
        Velocity(f32),
        #[prost(float, tag = "5")]
        Time(f32),
    }
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RotateParams {
        #[prost(message, tag = "6")]
        Rotation(super::Vector),
        #[prost(message, tag = "7")]
        RotationSpeed(super::MathQuaternion),
        #[prost(message, tag = "8")]
        AxisSpeed(super::MathQuaternion),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    #[prost(message, repeated, tag = "1")]
    pub route_points: ::prost::alloc::vec::Vec<RoutePoint>,
    #[prost(uint32, tag = "2")]
    pub route_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterRoute {
    #[prost(message, repeated, tag = "1")]
    pub route_points: ::prost::alloc::vec::Vec<RoutePoint>,
    #[prost(uint32, tag = "2")]
    pub speed_level: u32,
    #[prost(uint32, tag = "3")]
    pub route_type: u32,
    #[prost(float, tag = "4")]
    pub arrive_range: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeatherInfo {
    #[prost(uint32, tag = "1")]
    pub weather_area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub camp_id: u32,
    #[prost(uint32, tag = "2")]
    pub camp_type: u32,
    #[prost(uint64, tag = "3")]
    pub guid: u64,
    #[prost(uint32, tag = "4")]
    pub owner_entity_id: u32,
    #[prost(uint32, tag = "5")]
    pub target_entity_id: u32,
    #[prost(bool, tag = "6")]
    pub async_load: bool,
    #[prost(bool, tag = "7")]
    pub is_peer_id_from_player: bool,
    #[prost(uint32, repeated, tag = "8")]
    pub target_entity_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "9")]
    pub target_lock_point_index_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbilityGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub camp_id: u32,
    #[prost(uint32, tag = "2")]
    pub camp_target_type: u32,
    #[prost(uint32, tag = "3")]
    pub target_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GatherGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(bool, tag = "2")]
    pub is_forbid_guest: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatueGadgetInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub opened_statue_uid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeeklyBossResinDiscountInfo {
    #[prost(uint32, tag = "1")]
    pub discount_num: u32,
    #[prost(uint32, tag = "2")]
    pub discount_num_limit: u32,
    #[prost(uint32, tag = "3")]
    pub resin_cost: u32,
    #[prost(uint32, tag = "4")]
    pub original_resin_cost: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BossChestInfo {
    #[prost(uint32, tag = "1")]
    pub monster_config_id: u32,
    #[prost(uint32, tag = "2")]
    pub resin: u32,
    #[prost(uint32, repeated, tag = "3")]
    pub remain_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub qualify_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, message", tag = "5")]
    pub uid_discount_map: ::std::collections::HashMap<u32, WeeklyBossResinDiscountInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlossomChestInfo {
    #[prost(uint32, tag = "1")]
    pub resin: u32,
    #[prost(uint32, repeated, tag = "2")]
    pub qualify_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub remain_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub dead_time: u32,
    #[prost(uint32, tag = "5")]
    pub blossom_refresh_type: u32,
    #[prost(uint32, tag = "6")]
    pub refresh_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GadgetCrucibleInfo {
    #[prost(uint32, tag = "1")]
    pub mp_play_id: u32,
    #[prost(uint32, tag = "2")]
    pub prepare_end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetPlayInfo {
    #[prost(uint32, tag = "1")]
    pub play_type: u32,
    #[prost(uint32, tag = "2")]
    pub duration: u32,
    #[prost(uint32, repeated, tag = "3")]
    pub progress_stage_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "4")]
    pub start_cd: u32,
    #[prost(uint32, tag = "5")]
    pub start_time: u32,
    #[prost(uint32, tag = "6")]
    pub progress: u32,
    #[prost(oneof = "gadget_play_info::PlayInfo", tags = "7")]
    pub play_info: ::core::option::Option<gadget_play_info::PlayInfo>,
}
/// Nested message and enum types in `GadgetPlayInfo`.
pub mod gadget_play_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum PlayInfo {
        #[prost(message, tag = "7")]
        CrucibleInfo(super::GadgetCrucibleInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MpPlayRewardInfo {
    #[prost(uint32, tag = "1")]
    pub resin: u32,
    #[prost(uint32, repeated, tag = "2")]
    pub remain_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub qualify_uid_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GadgetGeneralRewardInfo {
    #[prost(uint32, tag = "1")]
    pub resin: u32,
    #[prost(uint32, tag = "2")]
    pub dead_time: u32,
    #[prost(uint32, repeated, tag = "3")]
    pub remain_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub qualify_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "5")]
    pub item_param: ::core::option::Option<ItemParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfferingInfo {
    #[prost(uint32, tag = "1")]
    pub offering_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuildingInfo {
    #[prost(uint32, tag = "1")]
    pub building_id: u32,
    #[prost(uint32, tag = "2")]
    pub point_config_id: u32,
    #[prost(uint32, tag = "3")]
    pub cost: u32,
    #[prost(uint32, tag = "4")]
    pub refund: u32,
    #[prost(uint32, tag = "5")]
    pub owner_uid: u32,
    #[prost(uint32, tag = "6")]
    pub current_num: u32,
    #[prost(uint32, tag = "7")]
    pub max_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FoundationInfo {
    #[prost(enumeration = "FoundationStatus", tag = "1")]
    pub status: i32,
    #[prost(uint32, repeated, tag = "2")]
    pub uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub current_building_id: u32,
    #[prost(uint32, tag = "4")]
    pub locked_by_uid: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VehicleMember {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint64, tag = "2")]
    pub avatar_guid: u64,
    #[prost(uint32, tag = "3")]
    pub pos: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VehicleInfo {
    #[prost(message, repeated, tag = "1")]
    pub member_list: ::prost::alloc::vec::Vec<VehicleMember>,
    #[prost(uint32, tag = "2")]
    pub owner_uid: u32,
    #[prost(float, tag = "3")]
    pub cur_stamina: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EchoShellInfo {
    #[prost(uint32, tag = "1")]
    pub shell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScreenInfo {
    #[prost(uint32, tag = "1")]
    pub live_id: u32,
    #[prost(uint32, tag = "2")]
    pub projector_entity_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishPoolInfo {
    #[prost(uint32, tag = "1")]
    pub pool_id: u32,
    #[prost(uint32, repeated, tag = "2")]
    pub fish_area_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub today_fish_num: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomCommonNodeInfo {
    #[prost(int32, tag = "1")]
    pub parent_index: i32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(string, tag = "3")]
    pub slot_identifier: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomGadgetTreeInfo {
    #[prost(message, repeated, tag = "1")]
    pub node_list: ::prost::alloc::vec::Vec<CustomCommonNodeInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoguelikeGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub cell_config_id: u32,
    #[prost(uint32, tag = "2")]
    pub cell_type: u32,
    #[prost(uint32, tag = "3")]
    pub cell_state: u32,
    #[prost(uint32, tag = "4")]
    pub cell_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NightCrowGadgetInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub argument_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeshretObeliskGadgetInfo {
    #[prost(uint32, repeated, tag = "1")]
    pub argument_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoinCollectOperatorInfo {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcSpecialGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub group_id: u32,
    #[prost(uint32, tag = "2")]
    pub guid: u32,
    #[prost(uint32, tag = "3")]
    pub ugc_gadget_config_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcTowerLevelUpGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub tower_level: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JourneyGearGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub level_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGadgetInfo {
    #[prost(uint32, tag = "1")]
    pub gadget_id: u32,
    #[prost(uint32, tag = "2")]
    pub group_id: u32,
    #[prost(uint32, tag = "3")]
    pub config_id: u32,
    #[prost(uint32, tag = "4")]
    pub owner_entity_id: u32,
    #[prost(enumeration = "GadgetBornType", tag = "5")]
    pub born_type: i32,
    #[prost(uint32, tag = "6")]
    pub gadget_state: u32,
    #[prost(uint32, tag = "7")]
    pub gadget_type: u32,
    #[prost(bool, tag = "8")]
    pub is_show_cutscene: bool,
    #[prost(uint32, tag = "9")]
    pub authority_peer_id: u32,
    #[prost(bool, tag = "10")]
    pub is_enable_interact: bool,
    #[prost(uint32, tag = "11")]
    pub interact_id: u32,
    #[prost(uint32, tag = "12")]
    pub mark_flag: u32,
    #[prost(uint32, tag = "13")]
    pub prop_owner_entity_id: u32,
    #[prost(message, optional, tag = "14")]
    pub platform: ::core::option::Option<PlatformInfo>,
    #[prost(uint32, repeated, tag = "15")]
    pub interact_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "16")]
    pub draft_id: u32,
    #[prost(uint32, tag = "17")]
    pub gadget_talk_state: u32,
    #[prost(message, optional, tag = "18")]
    pub play_info: ::core::option::Option<GadgetPlayInfo>,
    #[prost(message, optional, tag = "19")]
    pub ugc_tower_level_up_gadget_info: ::core::option::Option<
        UgcTowerLevelUpGadgetInfo,
    >,
    #[prost(message, optional, tag = "20")]
    pub journey_gear_operator_info: ::core::option::Option<JourneyGearGadgetInfo>,
    #[prost(message, optional, tag = "21")]
    pub ugc_v2_special_gadget_info: ::core::option::Option<UgcSpecialGadgetInfo>,
    #[prost(
        oneof = "scene_gadget_info::Content",
        tags = "22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43"
    )]
    pub content: ::core::option::Option<scene_gadget_info::Content>,
}
/// Nested message and enum types in `SceneGadgetInfo`.
pub mod scene_gadget_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "22")]
        TrifleItem(super::Item),
        #[prost(message, tag = "23")]
        GatherGadget(super::GatherGadgetInfo),
        #[prost(message, tag = "24")]
        Worktop(super::WorktopInfo),
        #[prost(message, tag = "25")]
        ClientGadget(super::ClientGadgetInfo),
        #[prost(message, tag = "26")]
        Weather(super::WeatherInfo),
        #[prost(message, tag = "27")]
        AbilityGadget(super::AbilityGadgetInfo),
        #[prost(message, tag = "28")]
        StatueGadget(super::StatueGadgetInfo),
        #[prost(message, tag = "29")]
        BossChest(super::BossChestInfo),
        #[prost(message, tag = "30")]
        BlossomChest(super::BlossomChestInfo),
        #[prost(message, tag = "31")]
        MpPlayReward(super::MpPlayRewardInfo),
        #[prost(message, tag = "32")]
        GeneralReward(super::GadgetGeneralRewardInfo),
        #[prost(message, tag = "33")]
        OfferingInfo(super::OfferingInfo),
        #[prost(message, tag = "34")]
        FoundationInfo(super::FoundationInfo),
        #[prost(message, tag = "35")]
        VehicleInfo(super::VehicleInfo),
        #[prost(message, tag = "36")]
        ShellInfo(super::EchoShellInfo),
        #[prost(message, tag = "37")]
        ScreenInfo(super::ScreenInfo),
        #[prost(message, tag = "38")]
        FishPoolInfo(super::FishPoolInfo),
        #[prost(message, tag = "39")]
        CustomGadgetTreeInfo(super::CustomGadgetTreeInfo),
        #[prost(message, tag = "40")]
        RoguelikeGadgetInfo(super::RoguelikeGadgetInfo),
        #[prost(message, tag = "41")]
        NightCrowGadgetInfo(super::NightCrowGadgetInfo),
        #[prost(message, tag = "42")]
        DeshretObeliskGadgetInfo(super::DeshretObeliskGadgetInfo),
        #[prost(message, tag = "43")]
        CoinCollectOperatorInfo(super::CoinCollectOperatorInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimatorParameterValueInfo {
    #[prost(uint32, tag = "1")]
    pub para_type: u32,
    #[prost(oneof = "animator_parameter_value_info::ParaVal", tags = "2, 3, 4")]
    pub para_val: ::core::option::Option<animator_parameter_value_info::ParaVal>,
}
/// Nested message and enum types in `AnimatorParameterValueInfo`.
pub mod animator_parameter_value_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ParaVal {
        #[prost(int32, tag = "2")]
        IntVal(i32),
        #[prost(float, tag = "3")]
        FloatVal(f32),
        #[prost(bool, tag = "4")]
        BoolVal(bool),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServantInfo {
    #[prost(uint32, tag = "1")]
    pub master_entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub born_slot_index: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityAiInfo {
    #[prost(bool, tag = "1")]
    pub is_ai_open: bool,
    #[prost(message, optional, tag = "2")]
    pub born_pos: ::core::option::Option<Vector>,
    #[prost(map = "uint32, uint32", tag = "3")]
    pub skill_cd_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, optional, tag = "4")]
    pub servant_info: ::core::option::Option<ServantInfo>,
    #[prost(map = "uint32, uint32", tag = "5")]
    pub ai_threat_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "6")]
    pub skill_group_cd_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, tag = "7")]
    pub cur_tactic: u32,
    #[prost(bool, tag = "8")]
    pub is_entered_combat: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityRendererChangedInfo {
    #[prost(map = "string, uint32", tag = "1")]
    pub changed_renderers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u32,
    >,
    #[prost(uint32, tag = "2")]
    pub visibility_count: u32,
    #[prost(bool, tag = "3")]
    pub is_cached: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PropPair {
    #[prost(uint32, tag = "1")]
    pub r#type: u32,
    #[prost(message, optional, tag = "2")]
    pub prop_value: ::core::option::Option<PropValue>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FightPropPair {
    #[prost(uint32, tag = "1")]
    pub prop_type: u32,
    #[prost(float, tag = "2")]
    pub prop_value: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimatorParameterValueInfoPair {
    #[prost(int32, tag = "1")]
    pub name_id: i32,
    #[prost(message, optional, tag = "2")]
    pub animator_para: ::core::option::Option<AnimatorParameterValueInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityEnvironmentInfo {
    #[prost(uint32, tag = "1")]
    pub json_climate_type: u32,
    #[prost(uint32, tag = "2")]
    pub climate_area_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityClientExtraInfo {
    #[prost(message, optional, tag = "1")]
    pub skill_anchor_position: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityAuthorityInfo {
    #[prost(message, optional, tag = "1")]
    pub ability_info: ::core::option::Option<AbilitySyncStateInfo>,
    #[prost(message, optional, tag = "2")]
    pub renderer_changed_info: ::core::option::Option<EntityRendererChangedInfo>,
    #[prost(message, optional, tag = "3")]
    pub ai_info: ::core::option::Option<SceneEntityAiInfo>,
    #[prost(message, optional, tag = "4")]
    pub born_pos: ::core::option::Option<Vector>,
    #[prost(message, repeated, tag = "5")]
    pub pose_para_list: ::prost::alloc::vec::Vec<AnimatorParameterValueInfoPair>,
    #[prost(message, optional, tag = "6")]
    pub client_extra_info: ::core::option::Option<EntityClientExtraInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityInfo {
    #[prost(enumeration = "ProtEntityType", tag = "1")]
    pub entity_type: i32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub motion_info: ::core::option::Option<MotionInfo>,
    #[prost(message, repeated, tag = "5")]
    pub prop_list: ::prost::alloc::vec::Vec<PropPair>,
    #[prost(message, repeated, tag = "6")]
    pub fight_prop_list: ::prost::alloc::vec::Vec<FightPropPair>,
    #[prost(uint32, tag = "7")]
    pub life_state: u32,
    #[prost(message, repeated, tag = "8")]
    pub animator_para_list: ::prost::alloc::vec::Vec<AnimatorParameterValueInfoPair>,
    #[prost(uint32, tag = "9")]
    pub last_move_scene_time_ms: u32,
    #[prost(uint32, tag = "10")]
    pub last_move_reliable_seq: u32,
    #[prost(message, optional, tag = "11")]
    pub entity_client_data: ::core::option::Option<EntityClientData>,
    #[prost(message, repeated, tag = "12")]
    pub entity_environment_info_list: ::prost::alloc::vec::Vec<EntityEnvironmentInfo>,
    #[prost(message, optional, tag = "13")]
    pub entity_authority_info: ::core::option::Option<EntityAuthorityInfo>,
    #[prost(string, repeated, tag = "14")]
    pub tag_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "15")]
    pub server_buff_list: ::prost::alloc::vec::Vec<ServerBuff>,
    #[prost(oneof = "scene_entity_info::Entity", tags = "16, 17, 18, 19")]
    pub entity: ::core::option::Option<scene_entity_info::Entity>,
}
/// Nested message and enum types in `SceneEntityInfo`.
pub mod scene_entity_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entity {
        #[prost(message, tag = "16")]
        Avatar(super::SceneAvatarInfo),
        #[prost(message, tag = "17")]
        Monster(super::SceneMonsterInfo),
        #[prost(message, tag = "18")]
        Npc(super::SceneNpcInfo),
        #[prost(message, tag = "19")]
        Gadget(super::SceneGadgetInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateGadgetInfo {
    #[prost(enumeration = "GadgetBornType", tag = "1")]
    pub born_type: i32,
    #[prost(message, optional, tag = "2")]
    pub chest: ::core::option::Option<Chest>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Chest {
    #[prost(uint32, tag = "1")]
    pub chest_drop_id: u32,
    #[prost(bool, tag = "2")]
    pub is_show_cutscene: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateEntityInfo {
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(uint32, tag = "4")]
    pub scene_id: u32,
    #[prost(uint32, tag = "5")]
    pub room_id: u32,
    #[prost(uint32, tag = "6")]
    pub client_unique_id: u32,
    #[prost(oneof = "create_entity_info::Entity", tags = "7, 8, 9, 10")]
    pub entity: ::core::option::Option<create_entity_info::Entity>,
    #[prost(oneof = "create_entity_info::EntityCreateInfo", tags = "11")]
    pub entity_create_info: ::core::option::Option<create_entity_info::EntityCreateInfo>,
}
/// Nested message and enum types in `CreateEntityInfo`.
pub mod create_entity_info {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Entity {
        #[prost(uint32, tag = "7")]
        MonsterId(u32),
        #[prost(uint32, tag = "8")]
        NpcId(u32),
        #[prost(uint32, tag = "9")]
        GadgetId(u32),
        #[prost(uint32, tag = "10")]
        ItemId(u32),
    }
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum EntityCreateInfo {
        #[prost(message, tag = "11")]
        Gadget(super::CreateGadgetInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrialAvatarGrantRecord {
    #[prost(uint32, tag = "1")]
    pub grant_reason: u32,
    #[prost(uint32, tag = "2")]
    pub from_parent_quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub trial_avatar_id: u32,
    #[prost(message, repeated, tag = "2")]
    pub trial_equip_list: ::prost::alloc::vec::Vec<Item>,
    #[prost(message, optional, tag = "3")]
    pub grant_record: ::core::option::Option<TrialAvatarGrantRecord>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarSkillInfo {
    #[prost(uint32, tag = "1")]
    pub pass_cd_time: u32,
    #[prost(uint32, repeated, tag = "2")]
    pub full_cd_time_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub max_charge_count: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetterData {
    #[prost(uint32, tag = "1")]
    pub fetter_id: u32,
    #[prost(uint32, tag = "2")]
    pub fetter_state: u32,
    #[prost(uint32, repeated, tag = "3")]
    pub cond_index_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarFetterInfo {
    #[prost(uint32, tag = "1")]
    pub exp_number: u32,
    #[prost(uint32, tag = "2")]
    pub exp_level: u32,
    #[prost(uint32, repeated, tag = "3")]
    pub open_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub finish_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub rewarded_fetter_level_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "6")]
    pub fetter_list: ::prost::alloc::vec::Vec<FetterData>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarExpeditionInfo {
    #[prost(enumeration = "AvatarExpeditionState", tag = "1")]
    pub state: i32,
    #[prost(uint32, tag = "2")]
    pub exp_id: u32,
    #[prost(uint32, tag = "3")]
    pub hour_time: u32,
    #[prost(uint32, tag = "4")]
    pub start_time: u32,
    #[prost(float, tag = "5")]
    pub shorten_ratio: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarEquipAffixInfo {
    #[prost(uint32, tag = "1")]
    pub equip_affix_id: u32,
    #[prost(uint32, tag = "2")]
    pub left_cd_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MirrorAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub copy_from_avatar_type: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvatarInfo {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint64, tag = "2")]
    pub guid: u64,
    #[prost(map = "uint32, message", tag = "3")]
    pub prop_map: ::std::collections::HashMap<u32, PropValue>,
    #[prost(uint32, tag = "4")]
    pub life_state: u32,
    #[prost(uint64, repeated, tag = "5")]
    pub equip_guid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, tag = "6")]
    pub talent_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, float", tag = "7")]
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(message, optional, tag = "8")]
    pub trial_avatar_info: ::core::option::Option<TrialAvatarInfo>,
    #[prost(map = "uint32, message", tag = "9")]
    pub skill_map: ::std::collections::HashMap<u32, AvatarSkillInfo>,
    #[prost(uint32, tag = "10")]
    pub skill_depot_id: u32,
    #[prost(message, optional, tag = "11")]
    pub fetter_info: ::core::option::Option<AvatarFetterInfo>,
    #[prost(uint32, tag = "12")]
    pub core_proud_skill_level: u32,
    #[prost(uint32, repeated, tag = "13")]
    pub inherent_proud_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "14")]
    pub skill_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(enumeration = "AvatarExpeditionState", tag = "15")]
    pub expedition_state: i32,
    #[prost(map = "uint32, uint32", tag = "16")]
    pub proud_skill_extra_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(bool, tag = "17")]
    pub is_focus: bool,
    #[prost(uint32, tag = "18")]
    pub avatar_type: u32,
    #[prost(uint32, repeated, tag = "19")]
    pub team_resonance_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "20")]
    pub wearing_flycloak_id: u32,
    #[prost(message, repeated, tag = "21")]
    pub equip_affix_list: ::prost::alloc::vec::Vec<AvatarEquipAffixInfo>,
    #[prost(uint32, tag = "22")]
    pub born_time: u32,
    #[prost(uint32, repeated, tag = "23")]
    pub pending_promote_reward_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "24")]
    pub costume_id: u32,
    #[prost(message, optional, tag = "25")]
    pub excel_info: ::core::option::Option<AvatarExcelInfo>,
    #[prost(uint32, tag = "26")]
    pub anim_hash: u32,
    #[prost(message, optional, tag = "27")]
    pub mirror_avatar_info: ::core::option::Option<MirrorAvatarInfo>,
    #[prost(uint32, tag = "31")]
    pub trace_effect_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowEquip {
    #[prost(uint32, tag = "1")]
    pub item_id: u32,
    #[prost(oneof = "show_equip::Detail", tags = "2, 3")]
    pub detail: ::core::option::Option<show_equip::Detail>,
}
/// Nested message and enum types in `ShowEquip`.
pub mod show_equip {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(message, tag = "2")]
        Reliquary(super::Reliquary),
        #[prost(message, tag = "3")]
        Weapon(super::Weapon),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowAvatarInfo {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(map = "uint32, message", tag = "2")]
    pub prop_map: ::std::collections::HashMap<u32, PropValue>,
    #[prost(uint32, repeated, tag = "3")]
    pub talent_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, float", tag = "4")]
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    #[prost(uint32, tag = "5")]
    pub skill_depot_id: u32,
    #[prost(uint32, tag = "6")]
    pub core_proud_skill_level: u32,
    #[prost(uint32, repeated, tag = "7")]
    pub inherent_proud_skill_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "8")]
    pub skill_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "9")]
    pub proud_skill_extra_level_map: ::std::collections::HashMap<u32, u32>,
    #[prost(message, repeated, tag = "10")]
    pub equip_list: ::prost::alloc::vec::Vec<ShowEquip>,
    #[prost(message, optional, tag = "11")]
    pub fetter_info: ::core::option::Option<AvatarFetterInfo>,
    #[prost(uint32, tag = "12")]
    pub costume_id: u32,
    #[prost(message, optional, tag = "13")]
    pub excel_info: ::core::option::Option<AvatarExcelInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quest {
    #[prost(uint32, tag = "1")]
    pub quest_id: u32,
    #[prost(uint32, tag = "2")]
    pub state: u32,
    #[prost(uint32, tag = "3")]
    pub start_time: u32,
    #[prost(bool, tag = "4")]
    pub is_random: bool,
    #[prost(uint32, tag = "5")]
    pub parent_quest_id: u32,
    #[prost(uint32, tag = "6")]
    pub quest_config_id: u32,
    #[prost(uint32, tag = "7")]
    pub start_game_time: u32,
    #[prost(uint32, tag = "8")]
    pub accept_time: u32,
    #[prost(uint32, repeated, tag = "9")]
    pub lacked_npc_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "10")]
    pub finish_progress_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "11")]
    pub fail_progress_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "12")]
    pub lacked_npc_map: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, repeated, tag = "13")]
    pub lacked_place_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "14")]
    pub lacked_place_map: ::std::collections::HashMap<u32, u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NpcPositionInfo {
    #[prost(uint32, tag = "1")]
    pub npc_id: u32,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailTextContent {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sender: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailItem {
    #[prost(message, optional, tag = "1")]
    pub equip_param: ::core::option::Option<EquipParam>,
    #[prost(message, optional, tag = "2")]
    pub delete_info: ::core::option::Option<MaterialDeleteInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailData {
    #[prost(uint32, tag = "1")]
    pub mail_id: u32,
    #[prost(message, optional, tag = "2")]
    pub mail_text_content: ::core::option::Option<MailTextContent>,
    #[prost(message, repeated, tag = "3")]
    pub item_list: ::prost::alloc::vec::Vec<MailItem>,
    #[prost(uint32, tag = "4")]
    pub send_time: u32,
    #[prost(uint32, tag = "5")]
    pub expire_time: u32,
    #[prost(uint32, tag = "6")]
    pub importance: u32,
    #[prost(bool, tag = "7")]
    pub is_read: bool,
    #[prost(bool, tag = "8")]
    pub is_attachment_got: bool,
    #[prost(uint32, tag = "9")]
    pub config_id: u32,
    #[prost(string, repeated, tag = "10")]
    pub argument_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "MailCollectState", tag = "11")]
    pub collect_state: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlinePlayerInfo {
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub player_level: u32,
    #[prost(uint32, tag = "4")]
    pub avatar_id: u32,
    #[prost(enumeration = "MpSettingType", tag = "5")]
    pub mp_setting_type: i32,
    #[prost(uint32, tag = "6")]
    pub cur_player_num_in_world: u32,
    #[prost(uint32, tag = "7")]
    pub world_level: u32,
    #[prost(string, tag = "8")]
    pub online_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "9")]
    pub name_card_id: u32,
    #[prost(uint32, repeated, tag = "10")]
    pub blacklist_uid_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, tag = "11")]
    pub signature: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub profile_picture: ::core::option::Option<ProfilePicture>,
    #[prost(string, tag = "13")]
    pub psn_id: ::prost::alloc::string::String,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Birthday {
    #[prost(uint32, tag = "1")]
    pub month: u32,
    #[prost(uint32, tag = "2")]
    pub day: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapMarkPoint {
    #[prost(uint32, tag = "1")]
    pub scene_id: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(enumeration = "MapMarkPointType", tag = "4")]
    pub point_type: i32,
    #[prost(uint32, tag = "5")]
    pub monster_id: u32,
    #[prost(enumeration = "MapMarkFromType", tag = "6")]
    pub from_type: i32,
    #[prost(uint32, tag = "7")]
    pub quest_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MassiveWaterInfo {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MassiveGrassInfo {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(message, optional, tag = "2")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub size: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MassiveBoxInfo {
    #[prost(int32, tag = "1")]
    pub id: i32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(message, optional, tag = "3")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "4")]
    pub extents: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "5")]
    pub up: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "6")]
    pub forward: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "7")]
    pub right: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientMassiveEntity {
    #[prost(uint32, tag = "1")]
    pub entity_type: u32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(int64, tag = "3")]
    pub obj_id: i64,
    #[prost(oneof = "client_massive_entity::EntityInfo", tags = "4, 5, 6")]
    pub entity_info: ::core::option::Option<client_massive_entity::EntityInfo>,
}
/// Nested message and enum types in `ClientMassiveEntity`.
pub mod client_massive_entity {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum EntityInfo {
        #[prost(message, tag = "4")]
        WaterInfo(super::MassiveWaterInfo),
        #[prost(message, tag = "5")]
        GrassInfo(super::MassiveGrassInfo),
        #[prost(message, tag = "6")]
        BoxInfo(super::MassiveBoxInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShapeSphere {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(float, tag = "2")]
    pub radius: f32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShapeBox {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "2")]
    pub axis0: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "3")]
    pub axis1: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "4")]
    pub axis2: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "5")]
    pub extents: ::core::option::Option<Vector>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerMassiveEntity {
    #[prost(uint32, tag = "1")]
    pub entity_type: u32,
    #[prost(uint32, tag = "2")]
    pub config_id: u32,
    #[prost(uint32, tag = "3")]
    pub runtime_id: u32,
    #[prost(uint32, tag = "4")]
    pub authority_peer_id: u32,
    #[prost(int64, tag = "5")]
    pub obj_id: i64,
    #[prost(oneof = "server_massive_entity::EntityInfo", tags = "6, 7, 8")]
    pub entity_info: ::core::option::Option<server_massive_entity::EntityInfo>,
}
/// Nested message and enum types in `ServerMassiveEntity`.
pub mod server_massive_entity {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum EntityInfo {
        #[prost(message, tag = "6")]
        WaterInfo(super::MassiveWaterInfo),
        #[prost(message, tag = "7")]
        GrassInfo(super::MassiveGrassInfo),
        #[prost(message, tag = "8")]
        BoxInfo(super::MassiveBoxInfo),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MassiveEntityState {
    #[prost(uint32, tag = "1")]
    pub entity_type: u32,
    #[prost(int64, tag = "2")]
    pub obj_id: i64,
    #[prost(uint32, tag = "3")]
    pub element_state: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityClientData {
    #[prost(uint32, tag = "1")]
    pub wind_change_scene_time: u32,
    #[prost(float, tag = "2")]
    pub windmill_sync_angle: f32,
    #[prost(int32, tag = "3")]
    pub wind_change_target_level: i32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockInfo {
    #[prost(uint32, tag = "1")]
    pub block_id: u32,
    #[prost(uint32, tag = "2")]
    pub data_version: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub bin_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub is_dirty: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopMcoinProduct {
    #[prost(string, tag = "1")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub price_tier: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub mcoin_base: u32,
    #[prost(uint32, tag = "4")]
    pub mcoin_non_first: u32,
    #[prost(uint32, tag = "5")]
    pub mcoin_first: u32,
    #[prost(uint32, tag = "6")]
    pub bought_num: u32,
    #[prost(bool, tag = "7")]
    pub is_audit: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopCardProduct {
    #[prost(string, tag = "1")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub price_tier: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub mcoin_base: u32,
    #[prost(uint32, tag = "4")]
    pub hcoin_per_day: u32,
    #[prost(uint32, tag = "5")]
    pub days: u32,
    #[prost(uint32, tag = "6")]
    pub remain_reward_days: u32,
    #[prost(uint32, tag = "7")]
    pub card_product_type: u32,
    #[prost(oneof = "shop_card_product::ExtraCardData", tags = "8")]
    pub extra_card_data: ::core::option::Option<shop_card_product::ExtraCardData>,
}
/// Nested message and enum types in `ShopCardProduct`.
pub mod shop_card_product {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExtraCardData {
        #[prost(message, tag = "8")]
        ResinCard(super::ResinCard),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResinCard {
    #[prost(message, repeated, tag = "1")]
    pub per_day_item_list: ::prost::alloc::vec::Vec<ItemParam>,
    #[prost(message, repeated, tag = "2")]
    pub base_item_list: ::prost::alloc::vec::Vec<ItemParam>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayProduct {
    #[prost(string, tag = "1")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub price_tier: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub schedule_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopConcertProduct {
    #[prost(string, tag = "1")]
    pub product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub price_tier: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub obtain_count: u32,
    #[prost(uint32, tag = "4")]
    pub obtain_limit: u32,
    #[prost(uint32, tag = "5")]
    pub begin_time: u32,
    #[prost(uint32, tag = "6")]
    pub end_time: u32,
    #[prost(uint32, tag = "7")]
    pub buy_times: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayTeamEntityInfo {
    #[prost(uint32, tag = "1")]
    pub entity_id: u32,
    #[prost(uint32, tag = "2")]
    pub player_uid: u32,
    #[prost(uint32, tag = "3")]
    pub authority_peer_id: u32,
    #[prost(uint32, tag = "4")]
    pub gadget_config_id: u32,
    #[prost(message, optional, tag = "5")]
    pub ability_info: ::core::option::Option<AbilitySyncStateInfo>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeatureBlockInfo {
    #[prost(uint32, tag = "1")]
    pub feature_type: u32,
    #[prost(uint32, tag = "2")]
    pub end_time: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapMarkTipsInfo {
    #[prost(enumeration = "MapMarkTipsType", tag = "1")]
    pub tips_type: i32,
    #[prost(uint32, repeated, tag = "2")]
    pub point_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExhibitionDisplayInfo {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub param: u32,
    #[prost(uint32, tag = "3")]
    pub detail_param: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProfilePicture {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedPointData {
    #[prost(uint32, tag = "1")]
    pub red_point_type: u32,
    #[prost(bool, tag = "2")]
    pub is_show: bool,
    #[prost(uint32, tag = "3")]
    pub content_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeMarkPointNpcData {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(uint32, tag = "2")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeMarkPointSuiteData {
    #[prost(uint32, tag = "1")]
    pub suite_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeMarkPointFurnitureData {
    #[prost(uint32, tag = "1")]
    pub guid: u32,
    #[prost(uint32, tag = "2")]
    pub furniture_id: u32,
    #[prost(uint32, tag = "3")]
    pub furniture_type: u32,
    #[prost(message, optional, tag = "4")]
    pub pos: ::core::option::Option<Vector>,
    #[prost(oneof = "home_mark_point_furniture_data::Extra", tags = "5, 6")]
    pub extra: ::core::option::Option<home_mark_point_furniture_data::Extra>,
}
/// Nested message and enum types in `HomeMarkPointFurnitureData`.
pub mod home_mark_point_furniture_data {
    #[derive(sakura_proto_derive::CmdID)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Extra {
        #[prost(message, tag = "5")]
        NpcData(super::HomeMarkPointNpcData),
        #[prost(message, tag = "6")]
        SuiteData(super::HomeMarkPointSuiteData),
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MapAreaInfo {
    #[prost(uint32, tag = "1")]
    pub map_area_id: u32,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentAuditInfo {
    #[prost(bool, tag = "1")]
    pub is_open: bool,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub submit_count: u32,
    #[prost(enumeration = "AuditState", tag = "4")]
    pub audit_state: i32,
    #[prost(uint32, tag = "5")]
    pub submit_limit: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityDungeonAvatar {
    #[prost(uint32, tag = "1")]
    pub avatar_id: u32,
    #[prost(bool, tag = "2")]
    pub is_trial: bool,
    #[prost(uint32, tag = "3")]
    pub costume_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcDungeonStarredRoomData {
    #[prost(uint64, tag = "1")]
    pub dungeon_guid: u64,
    #[prost(uint32, tag = "2")]
    pub room_id: u32,
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AbilityInvokeArgument {
    AbilityNone = 0,
    AbilityMetaModifierChange = 1,
    AbilityMetaCommandModifierChangeRequest = 2,
    AbilityMetaSpecialFloatArgument = 3,
    AbilityMetaOverrideParam = 4,
    AbilityMetaClearOverrideParam = 5,
    AbilityMetaReinitOverridemap = 6,
    AbilityMetaGlobalFloatValue = 7,
    AbilityMetaClearGlobalFloatValue = 8,
    AbilityMetaAbilityElementStrength = 9,
    AbilityMetaAddOrGetAbilityAndTrigger = 10,
    AbilityMetaSetKilledState = 11,
    AbilityMetaSetAbilityTrigger = 12,
    AbilityMetaAddNewAbility = 13,
    AbilityMetaRemoveAbility = 14,
    AbilityMetaSetModifierApplyEntity = 15,
    AbilityMetaModifierDurabilityChange = 16,
    AbilityMetaElementReactionVisual = 17,
    AbilityMetaSetPoseParameter = 18,
    AbilityMetaUpdateBaseReactionDamage = 19,
    AbilityMetaTriggerElementReaction = 20,
    AbilityMetaLoseHp = 21,
    AbilityMetaDurabilityIsZero = 22,
    AbilityActionTriggerAbility = 50,
    AbilityActionSetCrashDamage = 51,
    AbilityActionEffect = 52,
    AbilityActionSummon = 53,
    AbilityActionBlink = 54,
    AbilityActionCreateGadget = 55,
    AbilityActionApplyLevelModifier = 56,
    AbilityActionGenerateElemBall = 57,
    AbilityActionSetRandomOverrideMapValue = 58,
    AbilityActionServerMonsterLog = 59,
    AbilityActionCreateTile = 60,
    AbilityActionDestroyTile = 61,
    AbilityActionFireAfterImage = 62,
    AbilityActionDeductStamina = 63,
    AbilityActionHitEffect = 64,
    AbilityActionSetBulletTrackTarget = 65,
    AbilityActionFireworkEffect = 66,
    AbilityMixinAvatarSteerByCamera = 100,
    AbilityMixinMonsterDefend = 101,
    AbilityMixinWindZone = 102,
    AbilityMixinCostStamina = 103,
    AbilityMixinEliteShield = 104,
    AbilityMixinElementShield = 105,
    AbilityMixinGlobalShield = 106,
    AbilityMixinShieldBar = 107,
    AbilityMixinWindSeedSpawner = 108,
    AbilityMixinDoActionByElementReaction = 109,
    AbilityMixinFieldEntityCountChange = 110,
    AbilityMixinScenePropSync = 111,
    AbilityMixinWidgetMpSupport = 112,
    AbilityMixinDoActionBySelfModifierElementDurabilityRatio = 113,
    AbilityMixinFireworksLauncher = 114,
    AbilityMixinAttackResultCreateCount = 115,
    AbilityMixinUgcTimeControl = 116,
    AbilityMixinAvatarCombat = 117,
    AbilityMixinDeathZoneRegionalPlayMixin = 118,
    AbilityMixinUiInteract = 119,
    AbilityMixinShootFromCamera = 120,
    AbilityMixinEraseBrickActivity = 121,
    AbilityMixinBreakout = 122,
    AbilityMixinDamageLoan = 123,
    AbilityMixinBroadcastGv = 124,
    AbilityMixinReceiveGv = 125,
    AbilityMixinEnergyCrystalTarget = 127,
}
impl AbilityInvokeArgument {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AbilityNone => "ABILITY_NONE",
            Self::AbilityMetaModifierChange => "ABILITY_META_MODIFIER_CHANGE",
            Self::AbilityMetaCommandModifierChangeRequest => {
                "ABILITY_META_COMMAND_MODIFIER_CHANGE_REQUEST"
            }
            Self::AbilityMetaSpecialFloatArgument => {
                "ABILITY_META_SPECIAL_FLOAT_ARGUMENT"
            }
            Self::AbilityMetaOverrideParam => "ABILITY_META_OVERRIDE_PARAM",
            Self::AbilityMetaClearOverrideParam => "ABILITY_META_CLEAR_OVERRIDE_PARAM",
            Self::AbilityMetaReinitOverridemap => "ABILITY_META_REINIT_OVERRIDEMAP",
            Self::AbilityMetaGlobalFloatValue => "ABILITY_META_GLOBAL_FLOAT_VALUE",
            Self::AbilityMetaClearGlobalFloatValue => {
                "ABILITY_META_CLEAR_GLOBAL_FLOAT_VALUE"
            }
            Self::AbilityMetaAbilityElementStrength => {
                "ABILITY_META_ABILITY_ELEMENT_STRENGTH"
            }
            Self::AbilityMetaAddOrGetAbilityAndTrigger => {
                "ABILITY_META_ADD_OR_GET_ABILITY_AND_TRIGGER"
            }
            Self::AbilityMetaSetKilledState => "ABILITY_META_SET_KILLED_STATE",
            Self::AbilityMetaSetAbilityTrigger => "ABILITY_META_SET_ABILITY_TRIGGER",
            Self::AbilityMetaAddNewAbility => "ABILITY_META_ADD_NEW_ABILITY",
            Self::AbilityMetaRemoveAbility => "ABILITY_META_REMOVE_ABILITY",
            Self::AbilityMetaSetModifierApplyEntity => {
                "ABILITY_META_SET_MODIFIER_APPLY_ENTITY"
            }
            Self::AbilityMetaModifierDurabilityChange => {
                "ABILITY_META_MODIFIER_DURABILITY_CHANGE"
            }
            Self::AbilityMetaElementReactionVisual => {
                "ABILITY_META_ELEMENT_REACTION_VISUAL"
            }
            Self::AbilityMetaSetPoseParameter => "ABILITY_META_SET_POSE_PARAMETER",
            Self::AbilityMetaUpdateBaseReactionDamage => {
                "ABILITY_META_UPDATE_BASE_REACTION_DAMAGE"
            }
            Self::AbilityMetaTriggerElementReaction => {
                "ABILITY_META_TRIGGER_ELEMENT_REACTION"
            }
            Self::AbilityMetaLoseHp => "ABILITY_META_LOSE_HP",
            Self::AbilityMetaDurabilityIsZero => "ABILITY_META_DURABILITY_IS_ZERO",
            Self::AbilityActionTriggerAbility => "ABILITY_ACTION_TRIGGER_ABILITY",
            Self::AbilityActionSetCrashDamage => "ABILITY_ACTION_SET_CRASH_DAMAGE",
            Self::AbilityActionEffect => "ABILITY_ACTION_EFFECT",
            Self::AbilityActionSummon => "ABILITY_ACTION_SUMMON",
            Self::AbilityActionBlink => "ABILITY_ACTION_BLINK",
            Self::AbilityActionCreateGadget => "ABILITY_ACTION_CREATE_GADGET",
            Self::AbilityActionApplyLevelModifier => {
                "ABILITY_ACTION_APPLY_LEVEL_MODIFIER"
            }
            Self::AbilityActionGenerateElemBall => "ABILITY_ACTION_GENERATE_ELEM_BALL",
            Self::AbilityActionSetRandomOverrideMapValue => {
                "ABILITY_ACTION_SET_RANDOM_OVERRIDE_MAP_VALUE"
            }
            Self::AbilityActionServerMonsterLog => "ABILITY_ACTION_SERVER_MONSTER_LOG",
            Self::AbilityActionCreateTile => "ABILITY_ACTION_CREATE_TILE",
            Self::AbilityActionDestroyTile => "ABILITY_ACTION_DESTROY_TILE",
            Self::AbilityActionFireAfterImage => "ABILITY_ACTION_FIRE_AFTER_IMAGE",
            Self::AbilityActionDeductStamina => "ABILITY_ACTION_DEDUCT_STAMINA",
            Self::AbilityActionHitEffect => "ABILITY_ACTION_HIT_EFFECT",
            Self::AbilityActionSetBulletTrackTarget => {
                "ABILITY_ACTION_SET_BULLET_TRACK_TARGET"
            }
            Self::AbilityActionFireworkEffect => "ABILITY_ACTION_FIREWORK_EFFECT",
            Self::AbilityMixinAvatarSteerByCamera => {
                "ABILITY_MIXIN_AVATAR_STEER_BY_CAMERA"
            }
            Self::AbilityMixinMonsterDefend => "ABILITY_MIXIN_MONSTER_DEFEND",
            Self::AbilityMixinWindZone => "ABILITY_MIXIN_WIND_ZONE",
            Self::AbilityMixinCostStamina => "ABILITY_MIXIN_COST_STAMINA",
            Self::AbilityMixinEliteShield => "ABILITY_MIXIN_ELITE_SHIELD",
            Self::AbilityMixinElementShield => "ABILITY_MIXIN_ELEMENT_SHIELD",
            Self::AbilityMixinGlobalShield => "ABILITY_MIXIN_GLOBAL_SHIELD",
            Self::AbilityMixinShieldBar => "ABILITY_MIXIN_SHIELD_BAR",
            Self::AbilityMixinWindSeedSpawner => "ABILITY_MIXIN_WIND_SEED_SPAWNER",
            Self::AbilityMixinDoActionByElementReaction => {
                "ABILITY_MIXIN_DO_ACTION_BY_ELEMENT_REACTION"
            }
            Self::AbilityMixinFieldEntityCountChange => {
                "ABILITY_MIXIN_FIELD_ENTITY_COUNT_CHANGE"
            }
            Self::AbilityMixinScenePropSync => "ABILITY_MIXIN_SCENE_PROP_SYNC",
            Self::AbilityMixinWidgetMpSupport => "ABILITY_MIXIN_WIDGET_MP_SUPPORT",
            Self::AbilityMixinDoActionBySelfModifierElementDurabilityRatio => {
                "ABILITY_MIXIN_DO_ACTION_BY_SELF_MODIFIER_ELEMENT_DURABILITY_RATIO"
            }
            Self::AbilityMixinFireworksLauncher => "ABILITY_MIXIN_FIREWORKS_LAUNCHER",
            Self::AbilityMixinAttackResultCreateCount => {
                "ABILITY_MIXIN_ATTACK_RESULT_CREATE_COUNT"
            }
            Self::AbilityMixinUgcTimeControl => "ABILITY_MIXIN_UGC_TIME_CONTROL",
            Self::AbilityMixinAvatarCombat => "ABILITY_MIXIN_AVATAR_COMBAT",
            Self::AbilityMixinDeathZoneRegionalPlayMixin => {
                "ABILITY_MIXIN_DEATH_ZONE_REGIONAL_PLAY_MIXIN"
            }
            Self::AbilityMixinUiInteract => "ABILITY_MIXIN_UI_INTERACT",
            Self::AbilityMixinShootFromCamera => "ABILITY_MIXIN_SHOOT_FROM_CAMERA",
            Self::AbilityMixinEraseBrickActivity => "ABILITY_MIXIN_ERASE_BRICK_ACTIVITY",
            Self::AbilityMixinBreakout => "ABILITY_MIXIN_BREAKOUT",
            Self::AbilityMixinDamageLoan => "ABILITY_MIXIN_DAMAGE_LOAN",
            Self::AbilityMixinBroadcastGv => "ABILITY_MIXIN_BROADCAST_GV",
            Self::AbilityMixinReceiveGv => "ABILITY_MIXIN_RECEIVE_GV",
            Self::AbilityMixinEnergyCrystalTarget => {
                "ABILITY_MIXIN_ENERGY_CRYSTAL_TARGET"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ABILITY_NONE" => Some(Self::AbilityNone),
            "ABILITY_META_MODIFIER_CHANGE" => Some(Self::AbilityMetaModifierChange),
            "ABILITY_META_COMMAND_MODIFIER_CHANGE_REQUEST" => {
                Some(Self::AbilityMetaCommandModifierChangeRequest)
            }
            "ABILITY_META_SPECIAL_FLOAT_ARGUMENT" => {
                Some(Self::AbilityMetaSpecialFloatArgument)
            }
            "ABILITY_META_OVERRIDE_PARAM" => Some(Self::AbilityMetaOverrideParam),
            "ABILITY_META_CLEAR_OVERRIDE_PARAM" => {
                Some(Self::AbilityMetaClearOverrideParam)
            }
            "ABILITY_META_REINIT_OVERRIDEMAP" => Some(Self::AbilityMetaReinitOverridemap),
            "ABILITY_META_GLOBAL_FLOAT_VALUE" => Some(Self::AbilityMetaGlobalFloatValue),
            "ABILITY_META_CLEAR_GLOBAL_FLOAT_VALUE" => {
                Some(Self::AbilityMetaClearGlobalFloatValue)
            }
            "ABILITY_META_ABILITY_ELEMENT_STRENGTH" => {
                Some(Self::AbilityMetaAbilityElementStrength)
            }
            "ABILITY_META_ADD_OR_GET_ABILITY_AND_TRIGGER" => {
                Some(Self::AbilityMetaAddOrGetAbilityAndTrigger)
            }
            "ABILITY_META_SET_KILLED_STATE" => Some(Self::AbilityMetaSetKilledState),
            "ABILITY_META_SET_ABILITY_TRIGGER" => {
                Some(Self::AbilityMetaSetAbilityTrigger)
            }
            "ABILITY_META_ADD_NEW_ABILITY" => Some(Self::AbilityMetaAddNewAbility),
            "ABILITY_META_REMOVE_ABILITY" => Some(Self::AbilityMetaRemoveAbility),
            "ABILITY_META_SET_MODIFIER_APPLY_ENTITY" => {
                Some(Self::AbilityMetaSetModifierApplyEntity)
            }
            "ABILITY_META_MODIFIER_DURABILITY_CHANGE" => {
                Some(Self::AbilityMetaModifierDurabilityChange)
            }
            "ABILITY_META_ELEMENT_REACTION_VISUAL" => {
                Some(Self::AbilityMetaElementReactionVisual)
            }
            "ABILITY_META_SET_POSE_PARAMETER" => Some(Self::AbilityMetaSetPoseParameter),
            "ABILITY_META_UPDATE_BASE_REACTION_DAMAGE" => {
                Some(Self::AbilityMetaUpdateBaseReactionDamage)
            }
            "ABILITY_META_TRIGGER_ELEMENT_REACTION" => {
                Some(Self::AbilityMetaTriggerElementReaction)
            }
            "ABILITY_META_LOSE_HP" => Some(Self::AbilityMetaLoseHp),
            "ABILITY_META_DURABILITY_IS_ZERO" => Some(Self::AbilityMetaDurabilityIsZero),
            "ABILITY_ACTION_TRIGGER_ABILITY" => Some(Self::AbilityActionTriggerAbility),
            "ABILITY_ACTION_SET_CRASH_DAMAGE" => Some(Self::AbilityActionSetCrashDamage),
            "ABILITY_ACTION_EFFECT" => Some(Self::AbilityActionEffect),
            "ABILITY_ACTION_SUMMON" => Some(Self::AbilityActionSummon),
            "ABILITY_ACTION_BLINK" => Some(Self::AbilityActionBlink),
            "ABILITY_ACTION_CREATE_GADGET" => Some(Self::AbilityActionCreateGadget),
            "ABILITY_ACTION_APPLY_LEVEL_MODIFIER" => {
                Some(Self::AbilityActionApplyLevelModifier)
            }
            "ABILITY_ACTION_GENERATE_ELEM_BALL" => {
                Some(Self::AbilityActionGenerateElemBall)
            }
            "ABILITY_ACTION_SET_RANDOM_OVERRIDE_MAP_VALUE" => {
                Some(Self::AbilityActionSetRandomOverrideMapValue)
            }
            "ABILITY_ACTION_SERVER_MONSTER_LOG" => {
                Some(Self::AbilityActionServerMonsterLog)
            }
            "ABILITY_ACTION_CREATE_TILE" => Some(Self::AbilityActionCreateTile),
            "ABILITY_ACTION_DESTROY_TILE" => Some(Self::AbilityActionDestroyTile),
            "ABILITY_ACTION_FIRE_AFTER_IMAGE" => Some(Self::AbilityActionFireAfterImage),
            "ABILITY_ACTION_DEDUCT_STAMINA" => Some(Self::AbilityActionDeductStamina),
            "ABILITY_ACTION_HIT_EFFECT" => Some(Self::AbilityActionHitEffect),
            "ABILITY_ACTION_SET_BULLET_TRACK_TARGET" => {
                Some(Self::AbilityActionSetBulletTrackTarget)
            }
            "ABILITY_ACTION_FIREWORK_EFFECT" => Some(Self::AbilityActionFireworkEffect),
            "ABILITY_MIXIN_AVATAR_STEER_BY_CAMERA" => {
                Some(Self::AbilityMixinAvatarSteerByCamera)
            }
            "ABILITY_MIXIN_MONSTER_DEFEND" => Some(Self::AbilityMixinMonsterDefend),
            "ABILITY_MIXIN_WIND_ZONE" => Some(Self::AbilityMixinWindZone),
            "ABILITY_MIXIN_COST_STAMINA" => Some(Self::AbilityMixinCostStamina),
            "ABILITY_MIXIN_ELITE_SHIELD" => Some(Self::AbilityMixinEliteShield),
            "ABILITY_MIXIN_ELEMENT_SHIELD" => Some(Self::AbilityMixinElementShield),
            "ABILITY_MIXIN_GLOBAL_SHIELD" => Some(Self::AbilityMixinGlobalShield),
            "ABILITY_MIXIN_SHIELD_BAR" => Some(Self::AbilityMixinShieldBar),
            "ABILITY_MIXIN_WIND_SEED_SPAWNER" => Some(Self::AbilityMixinWindSeedSpawner),
            "ABILITY_MIXIN_DO_ACTION_BY_ELEMENT_REACTION" => {
                Some(Self::AbilityMixinDoActionByElementReaction)
            }
            "ABILITY_MIXIN_FIELD_ENTITY_COUNT_CHANGE" => {
                Some(Self::AbilityMixinFieldEntityCountChange)
            }
            "ABILITY_MIXIN_SCENE_PROP_SYNC" => Some(Self::AbilityMixinScenePropSync),
            "ABILITY_MIXIN_WIDGET_MP_SUPPORT" => Some(Self::AbilityMixinWidgetMpSupport),
            "ABILITY_MIXIN_DO_ACTION_BY_SELF_MODIFIER_ELEMENT_DURABILITY_RATIO" => {
                Some(Self::AbilityMixinDoActionBySelfModifierElementDurabilityRatio)
            }
            "ABILITY_MIXIN_FIREWORKS_LAUNCHER" => {
                Some(Self::AbilityMixinFireworksLauncher)
            }
            "ABILITY_MIXIN_ATTACK_RESULT_CREATE_COUNT" => {
                Some(Self::AbilityMixinAttackResultCreateCount)
            }
            "ABILITY_MIXIN_UGC_TIME_CONTROL" => Some(Self::AbilityMixinUgcTimeControl),
            "ABILITY_MIXIN_AVATAR_COMBAT" => Some(Self::AbilityMixinAvatarCombat),
            "ABILITY_MIXIN_DEATH_ZONE_REGIONAL_PLAY_MIXIN" => {
                Some(Self::AbilityMixinDeathZoneRegionalPlayMixin)
            }
            "ABILITY_MIXIN_UI_INTERACT" => Some(Self::AbilityMixinUiInteract),
            "ABILITY_MIXIN_SHOOT_FROM_CAMERA" => Some(Self::AbilityMixinShootFromCamera),
            "ABILITY_MIXIN_ERASE_BRICK_ACTIVITY" => {
                Some(Self::AbilityMixinEraseBrickActivity)
            }
            "ABILITY_MIXIN_BREAKOUT" => Some(Self::AbilityMixinBreakout),
            "ABILITY_MIXIN_DAMAGE_LOAN" => Some(Self::AbilityMixinDamageLoan),
            "ABILITY_MIXIN_BROADCAST_GV" => Some(Self::AbilityMixinBroadcastGv),
            "ABILITY_MIXIN_RECEIVE_GV" => Some(Self::AbilityMixinReceiveGv),
            "ABILITY_MIXIN_ENERGY_CRYSTAL_TARGET" => {
                Some(Self::AbilityMixinEnergyCrystalTarget)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModifierAction {
    Added = 0,
    Removed = 1,
}
impl ModifierAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Added => "MODIFIER_ACTION_ADDED",
            Self::Removed => "MODIFIER_ACTION_REMOVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODIFIER_ACTION_ADDED" => Some(Self::Added),
            "MODIFIER_ACTION_REMOVED" => Some(Self::Removed),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncType {
    None = 0,
    CreateConnect = 1,
    StartGame = 2,
    Ping = 3,
    FinishGame = 4,
    SnapShot = 5,
    Action = 6,
}
impl SyncType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SYNC_TYPE_NONE",
            Self::CreateConnect => "SYNC_TYPE_CREATE_CONNECT",
            Self::StartGame => "SYNC_TYPE_START_GAME",
            Self::Ping => "SYNC_TYPE_PING",
            Self::FinishGame => "SYNC_TYPE_FINISH_GAME",
            Self::SnapShot => "SYNC_TYPE_SNAP_SHOT",
            Self::Action => "SYNC_TYPE_ACTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYNC_TYPE_NONE" => Some(Self::None),
            "SYNC_TYPE_CREATE_CONNECT" => Some(Self::CreateConnect),
            "SYNC_TYPE_START_GAME" => Some(Self::StartGame),
            "SYNC_TYPE_PING" => Some(Self::Ping),
            "SYNC_TYPE_FINISH_GAME" => Some(Self::FinishGame),
            "SYNC_TYPE_SNAP_SHOT" => Some(Self::SnapShot),
            "SYNC_TYPE_ACTION" => Some(Self::Action),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UpdateType {
    Invalid = 0,
    Add = 1,
    Set = 2,
}
impl UpdateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "UPDATE_TYPE_INVALID",
            Self::Add => "UPDATE_TYPE_ADD",
            Self::Set => "UPDATE_TYPE_SET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPDATE_TYPE_INVALID" => Some(Self::Invalid),
            "UPDATE_TYPE_ADD" => Some(Self::Add),
            "UPDATE_TYPE_SET" => Some(Self::Set),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperateType {
    None = 0,
    Effect = 1,
}
impl OperateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "OPERATE_TYPE_NONE",
            Self::Effect => "OPERATE_TYPE_EFFECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATE_TYPE_NONE" => Some(Self::None),
            "OPERATE_TYPE_EFFECT" => Some(Self::Effect),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AchievementStatus {
    StatusInvalid = 0,
    StatusUnfinished = 1,
    StatusFinished = 2,
    StatusRewardTaken = 3,
}
impl AchievementStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StatusInvalid => "AchievementStatus_STATUS_INVALID",
            Self::StatusUnfinished => "AchievementStatus_STATUS_UNFINISHED",
            Self::StatusFinished => "AchievementStatus_STATUS_FINISHED",
            Self::StatusRewardTaken => "AchievementStatus_STATUS_REWARD_TAKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AchievementStatus_STATUS_INVALID" => Some(Self::StatusInvalid),
            "AchievementStatus_STATUS_UNFINISHED" => Some(Self::StatusUnfinished),
            "AchievementStatus_STATUS_FINISHED" => Some(Self::StatusFinished),
            "AchievementStatus_STATUS_REWARD_TAKEN" => Some(Self::StatusRewardTaken),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RogueCellState {
    None = 0,
    Battle = 1,
    Success = 2,
    Finish = 3,
    TakenChest = 4,
}
impl RogueCellState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ROGUE_CELL_STATE_NONE",
            Self::Battle => "ROGUE_CELL_STATE_BATTLE",
            Self::Success => "ROGUE_CELL_STATE_SUCCESS",
            Self::Finish => "ROGUE_CELL_STATE_FINISH",
            Self::TakenChest => "ROGUE_CELL_STATE_TAKEN_CHEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROGUE_CELL_STATE_NONE" => Some(Self::None),
            "ROGUE_CELL_STATE_BATTLE" => Some(Self::Battle),
            "ROGUE_CELL_STATE_SUCCESS" => Some(Self::Success),
            "ROGUE_CELL_STATE_FINISH" => Some(Self::Finish),
            "ROGUE_CELL_STATE_TAKEN_CHEST" => Some(Self::TakenChest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RogueEliteCellDifficultyType {
    Normal = 0,
    Hard = 1,
}
impl RogueEliteCellDifficultyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "ROGUE_ELITE_CELL_DIFFICULTY_TYPE_NORMAL",
            Self::Hard => "ROGUE_ELITE_CELL_DIFFICULTY_TYPE_HARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROGUE_ELITE_CELL_DIFFICULTY_TYPE_NORMAL" => Some(Self::Normal),
            "ROGUE_ELITE_CELL_DIFFICULTY_TYPE_HARD" => Some(Self::Hard),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RogueDiaryAvatarDisableStatus {
    None = 0,
    Death = 1,
    Tired = 2,
    Duplicated = 3,
}
impl RogueDiaryAvatarDisableStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ROGUE_DIARY_AVATAR_DISABLE_STATUS_NONE",
            Self::Death => "ROGUE_DIARY_AVATAR_DISABLE_STATUS_DEATH",
            Self::Tired => "ROGUE_DIARY_AVATAR_DISABLE_STATUS_TIRED",
            Self::Duplicated => "ROGUE_DIARY_AVATAR_DISABLE_STATUS_DUPLICATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROGUE_DIARY_AVATAR_DISABLE_STATUS_NONE" => Some(Self::None),
            "ROGUE_DIARY_AVATAR_DISABLE_STATUS_DEATH" => Some(Self::Death),
            "ROGUE_DIARY_AVATAR_DISABLE_STATUS_TIRED" => Some(Self::Tired),
            "ROGUE_DIARY_AVATAR_DISABLE_STATUS_DUPLICATED" => Some(Self::Duplicated),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActivityPushTipsState {
    None = 0,
    Start = 1,
    Read = 2,
}
impl ActivityPushTipsState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ACTIVITY_PUSH_TIPS_STATE_NONE",
            Self::Start => "ACTIVITY_PUSH_TIPS_STATE_START",
            Self::Read => "ACTIVITY_PUSH_TIPS_STATE_READ",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTIVITY_PUSH_TIPS_STATE_NONE" => Some(Self::None),
            "ACTIVITY_PUSH_TIPS_STATE_START" => Some(Self::Start),
            "ACTIVITY_PUSH_TIPS_STATE_READ" => Some(Self::Read),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SandwormLevelStateType {
    NotOpen = 0,
    PreQuest = 1,
    Start = 2,
    SequelQuest = 3,
}
impl SandwormLevelStateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotOpen => "SANDWORM_LEVEL_STATE_TYPE_NOT_OPEN",
            Self::PreQuest => "SANDWORM_LEVEL_STATE_TYPE_PRE_QUEST",
            Self::Start => "SANDWORM_LEVEL_STATE_TYPE_START",
            Self::SequelQuest => "SANDWORM_LEVEL_STATE_TYPE_SEQUEL_QUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SANDWORM_LEVEL_STATE_TYPE_NOT_OPEN" => Some(Self::NotOpen),
            "SANDWORM_LEVEL_STATE_TYPE_PRE_QUEST" => Some(Self::PreQuest),
            "SANDWORM_LEVEL_STATE_TYPE_START" => Some(Self::Start),
            "SANDWORM_LEVEL_STATE_TYPE_SEQUEL_QUEST" => Some(Self::SequelQuest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EffigyChallengeV4PrepareState {
    Idle = 0,
    ChangingAvatar = 1,
    Ready = 2,
}
impl EffigyChallengeV4PrepareState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Idle => "EFFIGY_CHALLENGE_V4_PREPARE_STATE_IDLE",
            Self::ChangingAvatar => "EFFIGY_CHALLENGE_V4_PREPARE_STATE_CHANGING_AVATAR",
            Self::Ready => "EFFIGY_CHALLENGE_V4_PREPARE_STATE_READY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EFFIGY_CHALLENGE_V4_PREPARE_STATE_IDLE" => Some(Self::Idle),
            "EFFIGY_CHALLENGE_V4_PREPARE_STATE_CHANGING_AVATAR" => {
                Some(Self::ChangingAvatar)
            }
            "EFFIGY_CHALLENGE_V4_PREPARE_STATE_READY" => Some(Self::Ready),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EffigyChallengeV4RestartDungeonEndReason {
    None = 0,
    Timeout = 1,
    Reject = 2,
}
impl EffigyChallengeV4RestartDungeonEndReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "EFFIGY_CHALLENGE_V4_RESTART_DUNGEON_END_REASON_NONE",
            Self::Timeout => "EFFIGY_CHALLENGE_V4_RESTART_DUNGEON_END_REASON_TIMEOUT",
            Self::Reject => "EFFIGY_CHALLENGE_V4_RESTART_DUNGEON_END_REASON_REJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EFFIGY_CHALLENGE_V4_RESTART_DUNGEON_END_REASON_NONE" => Some(Self::None),
            "EFFIGY_CHALLENGE_V4_RESTART_DUNGEON_END_REASON_TIMEOUT" => {
                Some(Self::Timeout)
            }
            "EFFIGY_CHALLENGE_V4_RESTART_DUNGEON_END_REASON_REJECT" => Some(Self::Reject),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BrickBreakerSettleReason {
    SettleReasonTimeOut = 0,
    SettleReasonPlayEnd = 1,
    SettleReasonPlayerQuit = 2,
    SettleReasonLifeCount = 3,
}
impl BrickBreakerSettleReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettleReasonTimeOut => {
                "BrickBreakerSettleReason_SETTLE_REASON_TIME_OUT"
            }
            Self::SettleReasonPlayEnd => {
                "BrickBreakerSettleReason_SETTLE_REASON_PLAY_END"
            }
            Self::SettleReasonPlayerQuit => {
                "BrickBreakerSettleReason_SETTLE_REASON_PLAYER_QUIT"
            }
            Self::SettleReasonLifeCount => {
                "BrickBreakerSettleReason_SETTLE_REASON_LIFE_COUNT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BrickBreakerSettleReason_SETTLE_REASON_TIME_OUT" => {
                Some(Self::SettleReasonTimeOut)
            }
            "BrickBreakerSettleReason_SETTLE_REASON_PLAY_END" => {
                Some(Self::SettleReasonPlayEnd)
            }
            "BrickBreakerSettleReason_SETTLE_REASON_PLAYER_QUIT" => {
                Some(Self::SettleReasonPlayerQuit)
            }
            "BrickBreakerSettleReason_SETTLE_REASON_LIFE_COUNT" => {
                Some(Self::SettleReasonLifeCount)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattlePassUnlockStatus {
    Invalid = 0,
    Free = 1,
    Paid = 2,
}
impl BattlePassUnlockStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "BATTLE_PASS_UNLOCK_STATUS_INVALID",
            Self::Free => "BATTLE_PASS_UNLOCK_STATUS_FREE",
            Self::Paid => "BATTLE_PASS_UNLOCK_STATUS_PAID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_PASS_UNLOCK_STATUS_INVALID" => Some(Self::Invalid),
            "BATTLE_PASS_UNLOCK_STATUS_FREE" => Some(Self::Free),
            "BATTLE_PASS_UNLOCK_STATUS_PAID" => Some(Self::Paid),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MissionStatus {
    Invalid = 0,
    Unfinished = 1,
    Finished = 2,
    PointTaken = 3,
}
impl MissionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "MISSION_STATUS_INVALID",
            Self::Unfinished => "MISSION_STATUS_UNFINISHED",
            Self::Finished => "MISSION_STATUS_FINISHED",
            Self::PointTaken => "MISSION_STATUS_POINT_TAKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MISSION_STATUS_INVALID" => Some(Self::Invalid),
            "MISSION_STATUS_UNFINISHED" => Some(Self::Unfinished),
            "MISSION_STATUS_FINISHED" => Some(Self::Finished),
            "MISSION_STATUS_POINT_TAKEN" => Some(Self::PointTaken),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlossomScheduleState {
    None = 0,
    Init = 1,
    InProgress = 2,
    Reward = 3,
}
impl BlossomScheduleState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "BLOSSOM_SCHEDULE_STATE_NONE",
            Self::Init => "BLOSSOM_SCHEDULE_STATE_INIT",
            Self::InProgress => "BLOSSOM_SCHEDULE_STATE_IN_PROGRESS",
            Self::Reward => "BLOSSOM_SCHEDULE_STATE_REWARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOSSOM_SCHEDULE_STATE_NONE" => Some(Self::None),
            "BLOSSOM_SCHEDULE_STATE_INIT" => Some(Self::Init),
            "BLOSSOM_SCHEDULE_STATE_IN_PROGRESS" => Some(Self::InProgress),
            "BLOSSOM_SCHEDULE_STATE_REWARD" => Some(Self::Reward),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MainCoopStatus {
    StatusInvalid = 0,
    StatusRunning = 1,
    StatusFinished = 2,
}
impl MainCoopStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StatusInvalid => "MainCoopStatus_STATUS_INVALID",
            Self::StatusRunning => "MainCoopStatus_STATUS_RUNNING",
            Self::StatusFinished => "MainCoopStatus_STATUS_FINISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MainCoopStatus_STATUS_INVALID" => Some(Self::StatusInvalid),
            "MainCoopStatus_STATUS_RUNNING" => Some(Self::StatusRunning),
            "MainCoopStatus_STATUS_FINISHED" => Some(Self::StatusFinished),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoopPointState {
    StateUnstarted = 0,
    StateStarted = 1,
    StateFinished = 2,
}
impl CoopPointState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StateUnstarted => "CoopPointState_STATE_UNSTARTED",
            Self::StateStarted => "CoopPointState_STATE_STARTED",
            Self::StateFinished => "CoopPointState_STATE_FINISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CoopPointState_STATE_UNSTARTED" => Some(Self::StateUnstarted),
            "CoopPointState_STATE_STARTED" => Some(Self::StateStarted),
            "CoopPointState_STATE_FINISHED" => Some(Self::StateFinished),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoopRewardState {
    StateUnlock = 0,
    StateLock = 1,
    StateTaken = 2,
}
impl CoopRewardState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StateUnlock => "CoopRewardState_STATE_UNLOCK",
            Self::StateLock => "CoopRewardState_STATE_LOCK",
            Self::StateTaken => "CoopRewardState_STATE_TAKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CoopRewardState_STATE_UNLOCK" => Some(Self::StateUnlock),
            "CoopRewardState_STATE_LOCK" => Some(Self::StateLock),
            "CoopRewardState_STATE_TAKEN" => Some(Self::StateTaken),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoopChapterState {
    StateClose = 0,
    StateCondNotMeet = 1,
    StateCondMeet = 2,
    StateAccept = 3,
}
impl CoopChapterState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StateClose => "CoopChapterState_STATE_CLOSE",
            Self::StateCondNotMeet => "CoopChapterState_STATE_COND_NOT_MEET",
            Self::StateCondMeet => "CoopChapterState_STATE_COND_MEET",
            Self::StateAccept => "CoopChapterState_STATE_ACCEPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CoopChapterState_STATE_CLOSE" => Some(Self::StateClose),
            "CoopChapterState_STATE_COND_NOT_MEET" => Some(Self::StateCondNotMeet),
            "CoopChapterState_STATE_COND_MEET" => Some(Self::StateCondMeet),
            "CoopChapterState_STATE_ACCEPT" => Some(Self::StateAccept),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnterCustomDungeonType {
    None = 0,
    Edit = 1,
    Play = 2,
    Official = 3,
}
impl EnterCustomDungeonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ENTER_CUSTOM_DUNGEON_TYPE_NONE",
            Self::Edit => "ENTER_CUSTOM_DUNGEON_TYPE_EDIT",
            Self::Play => "ENTER_CUSTOM_DUNGEON_TYPE_PLAY",
            Self::Official => "ENTER_CUSTOM_DUNGEON_TYPE_OFFICIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTER_CUSTOM_DUNGEON_TYPE_NONE" => Some(Self::None),
            "ENTER_CUSTOM_DUNGEON_TYPE_EDIT" => Some(Self::Edit),
            "ENTER_CUSTOM_DUNGEON_TYPE_PLAY" => Some(Self::Play),
            "ENTER_CUSTOM_DUNGEON_TYPE_OFFICIAL" => Some(Self::Official),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomDungeonState {
    Edit = 0,
    SelfPass = 1,
    Published = 2,
}
impl CustomDungeonState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Edit => "CUSTOM_DUNGEON_STATE_EDIT",
            Self::SelfPass => "CUSTOM_DUNGEON_STATE_SELF_PASS",
            Self::Published => "CUSTOM_DUNGEON_STATE_PUBLISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CUSTOM_DUNGEON_STATE_EDIT" => Some(Self::Edit),
            "CUSTOM_DUNGEON_STATE_SELF_PASS" => Some(Self::SelfPass),
            "CUSTOM_DUNGEON_STATE_PUBLISHED" => Some(Self::Published),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomDungeonBanType {
    None = 0,
    Layout = 1,
}
impl CustomDungeonBanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CUSTOM_DUNGEON_BAN_TYPE_NONE",
            Self::Layout => "CUSTOM_DUNGEON_BAN_TYPE_LAYOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CUSTOM_DUNGEON_BAN_TYPE_NONE" => Some(Self::None),
            "CUSTOM_DUNGEON_BAN_TYPE_LAYOUT" => Some(Self::Layout),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TryCustomDungeonType {
    None = 0,
    Room = 1,
    All = 2,
    OfficialPlay = 3,
}
impl TryCustomDungeonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "TRY_CUSTOM_DUNGEON_TYPE_NONE",
            Self::Room => "TRY_CUSTOM_DUNGEON_TYPE_ROOM",
            Self::All => "TRY_CUSTOM_DUNGEON_TYPE_ALL",
            Self::OfficialPlay => "TRY_CUSTOM_DUNGEON_TYPE_OFFICIAL_PLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRY_CUSTOM_DUNGEON_TYPE_NONE" => Some(Self::None),
            "TRY_CUSTOM_DUNGEON_TYPE_ROOM" => Some(Self::Room),
            "TRY_CUSTOM_DUNGEON_TYPE_ALL" => Some(Self::All),
            "TRY_CUSTOM_DUNGEON_TYPE_OFFICIAL_PLAY" => Some(Self::OfficialPlay),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DraftInviteFailReason {
    Unknown = 0,
    ActivityNotOpen = 1,
    ActivityPlayNotOpen = 2,
    SceneNotMeet = 3,
    WorldNotMeet = 4,
    PlayLimitNotMeet = 5,
}
impl DraftInviteFailReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "DRAFT_INVITE_FAIL_REASON_UNKNOWN",
            Self::ActivityNotOpen => "DRAFT_INVITE_FAIL_REASON_ACTIVITY_NOT_OPEN",
            Self::ActivityPlayNotOpen => {
                "DRAFT_INVITE_FAIL_REASON_ACTIVITY_PLAY_NOT_OPEN"
            }
            Self::SceneNotMeet => "DRAFT_INVITE_FAIL_REASON_SCENE_NOT_MEET",
            Self::WorldNotMeet => "DRAFT_INVITE_FAIL_REASON_WORLD_NOT_MEET",
            Self::PlayLimitNotMeet => "DRAFT_INVITE_FAIL_REASON_PLAY_LIMIT_NOT_MEET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DRAFT_INVITE_FAIL_REASON_UNKNOWN" => Some(Self::Unknown),
            "DRAFT_INVITE_FAIL_REASON_ACTIVITY_NOT_OPEN" => Some(Self::ActivityNotOpen),
            "DRAFT_INVITE_FAIL_REASON_ACTIVITY_PLAY_NOT_OPEN" => {
                Some(Self::ActivityPlayNotOpen)
            }
            "DRAFT_INVITE_FAIL_REASON_SCENE_NOT_MEET" => Some(Self::SceneNotMeet),
            "DRAFT_INVITE_FAIL_REASON_WORLD_NOT_MEET" => Some(Self::WorldNotMeet),
            "DRAFT_INVITE_FAIL_REASON_PLAY_LIMIT_NOT_MEET" => {
                Some(Self::PlayLimitNotMeet)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WindFieldDungeonFailReason {
    None = 0,
    Cancel = 1,
    Timeout = 2,
    AllAvatarDie = 3,
    LuaInterrupt = 4,
}
impl WindFieldDungeonFailReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "WIND_FIELD_DUNGEON_FAIL_REASON_NONE",
            Self::Cancel => "WIND_FIELD_DUNGEON_FAIL_REASON_CANCEL",
            Self::Timeout => "WIND_FIELD_DUNGEON_FAIL_REASON_TIMEOUT",
            Self::AllAvatarDie => "WIND_FIELD_DUNGEON_FAIL_REASON_ALL_AVATAR_DIE",
            Self::LuaInterrupt => "WIND_FIELD_DUNGEON_FAIL_REASON_LUA_INTERRUPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIND_FIELD_DUNGEON_FAIL_REASON_NONE" => Some(Self::None),
            "WIND_FIELD_DUNGEON_FAIL_REASON_CANCEL" => Some(Self::Cancel),
            "WIND_FIELD_DUNGEON_FAIL_REASON_TIMEOUT" => Some(Self::Timeout),
            "WIND_FIELD_DUNGEON_FAIL_REASON_ALL_AVATAR_DIE" => Some(Self::AllAvatarDie),
            "WIND_FIELD_DUNGEON_FAIL_REASON_LUA_INTERRUPT" => Some(Self::LuaInterrupt),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PacmanDungeonStopReason {
    None = 0,
    Success = 1,
    Timeup = 2,
    ClientInterrupt = 3,
    Cancel = 4,
    ActivityClosed = 5,
    Fail = 6,
}
impl PacmanDungeonStopReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PACMAN_DUNGEON_STOP_REASON_NONE",
            Self::Success => "PACMAN_DUNGEON_STOP_REASON_SUCCESS",
            Self::Timeup => "PACMAN_DUNGEON_STOP_REASON_TIMEUP",
            Self::ClientInterrupt => "PACMAN_DUNGEON_STOP_REASON_CLIENT_INTERRUPT",
            Self::Cancel => "PACMAN_DUNGEON_STOP_REASON_CANCEL",
            Self::ActivityClosed => "PACMAN_DUNGEON_STOP_REASON_ACTIVITY_CLOSED",
            Self::Fail => "PACMAN_DUNGEON_STOP_REASON_FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PACMAN_DUNGEON_STOP_REASON_NONE" => Some(Self::None),
            "PACMAN_DUNGEON_STOP_REASON_SUCCESS" => Some(Self::Success),
            "PACMAN_DUNGEON_STOP_REASON_TIMEUP" => Some(Self::Timeup),
            "PACMAN_DUNGEON_STOP_REASON_CLIENT_INTERRUPT" => Some(Self::ClientInterrupt),
            "PACMAN_DUNGEON_STOP_REASON_CANCEL" => Some(Self::Cancel),
            "PACMAN_DUNGEON_STOP_REASON_ACTIVITY_CLOSED" => Some(Self::ActivityClosed),
            "PACMAN_DUNGEON_STOP_REASON_FAIL" => Some(Self::Fail),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChallengeFinishType {
    None = 0,
    Fail = 1,
    Succ = 2,
    Pause = 3,
}
impl ChallengeFinishType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CHALLENGE_FINISH_TYPE_NONE",
            Self::Fail => "CHALLENGE_FINISH_TYPE_FAIL",
            Self::Succ => "CHALLENGE_FINISH_TYPE_SUCC",
            Self::Pause => "CHALLENGE_FINISH_TYPE_PAUSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHALLENGE_FINISH_TYPE_NONE" => Some(Self::None),
            "CHALLENGE_FINISH_TYPE_FAIL" => Some(Self::Fail),
            "CHALLENGE_FINISH_TYPE_SUCC" => Some(Self::Succ),
            "CHALLENGE_FINISH_TYPE_PAUSE" => Some(Self::Pause),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomDungeonFinishType {
    PlayNormal = 0,
    PlayTry = 1,
    EditTry = 2,
    SelfPlayNormal = 3,
}
impl CustomDungeonFinishType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PlayNormal => "CUSTOM_DUNGEON_FINISH_TYPE_PLAY_NORMAL",
            Self::PlayTry => "CUSTOM_DUNGEON_FINISH_TYPE_PLAY_TRY",
            Self::EditTry => "CUSTOM_DUNGEON_FINISH_TYPE_EDIT_TRY",
            Self::SelfPlayNormal => "CUSTOM_DUNGEON_FINISH_TYPE_SELF_PLAY_NORMAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CUSTOM_DUNGEON_FINISH_TYPE_PLAY_NORMAL" => Some(Self::PlayNormal),
            "CUSTOM_DUNGEON_FINISH_TYPE_PLAY_TRY" => Some(Self::PlayTry),
            "CUSTOM_DUNGEON_FINISH_TYPE_EDIT_TRY" => Some(Self::EditTry),
            "CUSTOM_DUNGEON_FINISH_TYPE_SELF_PLAY_NORMAL" => Some(Self::SelfPlayNormal),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DungeonCandidateTeamPlayerLeaveReason {
    TplrNormal = 0,
    TplrDie = 1,
    TplrBeKick = 2,
    TplrDisconnect = 3,
}
impl DungeonCandidateTeamPlayerLeaveReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TplrNormal => "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_NORMAL",
            Self::TplrDie => "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_DIE",
            Self::TplrBeKick => "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_BE_KICK",
            Self::TplrDisconnect => {
                "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_DISCONNECT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_NORMAL" => {
                Some(Self::TplrNormal)
            }
            "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_DIE" => Some(Self::TplrDie),
            "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_BE_KICK" => {
                Some(Self::TplrBeKick)
            }
            "DUNGEON_CANDIDATE_TEAM_PLAYER_LEAVE_REASON_TPLR_DISCONNECT" => {
                Some(Self::TplrDisconnect)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DungeonCandidateTeamDismissReason {
    TpdrNormal = 0,
    TpdrDie = 1,
    TpdrDisconnect = 2,
}
impl DungeonCandidateTeamDismissReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TpdrNormal => "DUNGEON_CANDIDATE_TEAM_DISMISS_REASON_TPDR_NORMAL",
            Self::TpdrDie => "DUNGEON_CANDIDATE_TEAM_DISMISS_REASON_TPDR_DIE",
            Self::TpdrDisconnect => {
                "DUNGEON_CANDIDATE_TEAM_DISMISS_REASON_TPDR_DISCONNECT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUNGEON_CANDIDATE_TEAM_DISMISS_REASON_TPDR_NORMAL" => Some(Self::TpdrNormal),
            "DUNGEON_CANDIDATE_TEAM_DISMISS_REASON_TPDR_DIE" => Some(Self::TpdrDie),
            "DUNGEON_CANDIDATE_TEAM_DISMISS_REASON_TPDR_DISCONNECT" => {
                Some(Self::TpdrDisconnect)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ForwardType {
    Local = 0,
    ToAll = 1,
    ToAllExceptCur = 2,
    ToHost = 3,
    ToAllGuest = 4,
    ToPeer = 5,
    ToPeers = 6,
    OnlyServer = 7,
    ToAllExistExceptCur = 8,
}
impl ForwardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Local => "FORWARD_TYPE_LOCAL",
            Self::ToAll => "FORWARD_TYPE_TO_ALL",
            Self::ToAllExceptCur => "FORWARD_TYPE_TO_ALL_EXCEPT_CUR",
            Self::ToHost => "FORWARD_TYPE_TO_HOST",
            Self::ToAllGuest => "FORWARD_TYPE_TO_ALL_GUEST",
            Self::ToPeer => "FORWARD_TYPE_TO_PEER",
            Self::ToPeers => "FORWARD_TYPE_TO_PEERS",
            Self::OnlyServer => "FORWARD_TYPE_ONLY_SERVER",
            Self::ToAllExistExceptCur => "FORWARD_TYPE_TO_ALL_EXIST_EXCEPT_CUR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FORWARD_TYPE_LOCAL" => Some(Self::Local),
            "FORWARD_TYPE_TO_ALL" => Some(Self::ToAll),
            "FORWARD_TYPE_TO_ALL_EXCEPT_CUR" => Some(Self::ToAllExceptCur),
            "FORWARD_TYPE_TO_HOST" => Some(Self::ToHost),
            "FORWARD_TYPE_TO_ALL_GUEST" => Some(Self::ToAllGuest),
            "FORWARD_TYPE_TO_PEER" => Some(Self::ToPeer),
            "FORWARD_TYPE_TO_PEERS" => Some(Self::ToPeers),
            "FORWARD_TYPE_ONLY_SERVER" => Some(Self::OnlyServer),
            "FORWARD_TYPE_TO_ALL_EXIST_EXCEPT_CUR" => Some(Self::ToAllExistExceptCur),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HitColliderType {
    Invalid = 0,
    HitBox = 1,
    WetHitBox = 2,
    HeadBox = 3,
}
impl HitColliderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "HIT_COLLIDER_TYPE_INVALID",
            Self::HitBox => "HIT_COLLIDER_TYPE_HIT_BOX",
            Self::WetHitBox => "HIT_COLLIDER_TYPE_WET_HIT_BOX",
            Self::HeadBox => "HIT_COLLIDER_TYPE_HEAD_BOX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HIT_COLLIDER_TYPE_INVALID" => Some(Self::Invalid),
            "HIT_COLLIDER_TYPE_HIT_BOX" => Some(Self::HitBox),
            "HIT_COLLIDER_TYPE_WET_HIT_BOX" => Some(Self::WetHitBox),
            "HIT_COLLIDER_TYPE_HEAD_BOX" => Some(Self::HeadBox),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CombatTypeArgument {
    None = 0,
    EvtBeingHit = 1,
    AnimatorStateChanged = 2,
    FaceToDir = 3,
    SetAttackTarget = 4,
    RushMove = 5,
    AnimatorParameterChanged = 6,
    EntityMove = 7,
    SyncEntityPosition = 8,
    SteerMotionInfo = 9,
    ForceSetPosInfo = 10,
    CompensatePosDiff = 11,
    MonsterDoBlink = 12,
    FixedRushMove = 13,
    SyncTransform = 14,
    LightCoreMove = 15,
    BeingHealedNtf = 16,
    SkillAnchorPositionNtf = 17,
    GrapplingHookMove = 18,
    SpecialMotionInfo = 19,
    FixedAvatarFlashMove = 20,
    MultiOverrideAnim = 21,
    DebugSyncMotion = 22,
}
impl CombatTypeArgument {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "COMBAT_TYPE_ARGUMENT_NONE",
            Self::EvtBeingHit => "COMBAT_TYPE_ARGUMENT_EVT_BEING_HIT",
            Self::AnimatorStateChanged => "COMBAT_TYPE_ARGUMENT_ANIMATOR_STATE_CHANGED",
            Self::FaceToDir => "COMBAT_TYPE_ARGUMENT_FACE_TO_DIR",
            Self::SetAttackTarget => "COMBAT_TYPE_ARGUMENT_SET_ATTACK_TARGET",
            Self::RushMove => "COMBAT_TYPE_ARGUMENT_RUSH_MOVE",
            Self::AnimatorParameterChanged => {
                "COMBAT_TYPE_ARGUMENT_ANIMATOR_PARAMETER_CHANGED"
            }
            Self::EntityMove => "COMBAT_TYPE_ARGUMENT_ENTITY_MOVE",
            Self::SyncEntityPosition => "COMBAT_TYPE_ARGUMENT_SYNC_ENTITY_POSITION",
            Self::SteerMotionInfo => "COMBAT_TYPE_ARGUMENT_STEER_MOTION_INFO",
            Self::ForceSetPosInfo => "COMBAT_TYPE_ARGUMENT_FORCE_SET_POS_INFO",
            Self::CompensatePosDiff => "COMBAT_TYPE_ARGUMENT_COMPENSATE_POS_DIFF",
            Self::MonsterDoBlink => "COMBAT_TYPE_ARGUMENT_MONSTER_DO_BLINK",
            Self::FixedRushMove => "COMBAT_TYPE_ARGUMENT_FIXED_RUSH_MOVE",
            Self::SyncTransform => "COMBAT_TYPE_ARGUMENT_SYNC_TRANSFORM",
            Self::LightCoreMove => "COMBAT_TYPE_ARGUMENT_LIGHT_CORE_MOVE",
            Self::BeingHealedNtf => "COMBAT_TYPE_ARGUMENT_BEING_HEALED_NTF",
            Self::SkillAnchorPositionNtf => {
                "COMBAT_TYPE_ARGUMENT_SKILL_ANCHOR_POSITION_NTF"
            }
            Self::GrapplingHookMove => "COMBAT_TYPE_ARGUMENT_GRAPPLING_HOOK_MOVE",
            Self::SpecialMotionInfo => "COMBAT_TYPE_ARGUMENT_SPECIAL_MOTION_INFO",
            Self::FixedAvatarFlashMove => "COMBAT_TYPE_ARGUMENT_FIXED_AVATAR_FLASH_MOVE",
            Self::MultiOverrideAnim => "COMBAT_TYPE_ARGUMENT_MULTI_OVERRIDE_ANIM",
            Self::DebugSyncMotion => "COMBAT_TYPE_ARGUMENT_DEBUG_SYNC_MOTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMBAT_TYPE_ARGUMENT_NONE" => Some(Self::None),
            "COMBAT_TYPE_ARGUMENT_EVT_BEING_HIT" => Some(Self::EvtBeingHit),
            "COMBAT_TYPE_ARGUMENT_ANIMATOR_STATE_CHANGED" => {
                Some(Self::AnimatorStateChanged)
            }
            "COMBAT_TYPE_ARGUMENT_FACE_TO_DIR" => Some(Self::FaceToDir),
            "COMBAT_TYPE_ARGUMENT_SET_ATTACK_TARGET" => Some(Self::SetAttackTarget),
            "COMBAT_TYPE_ARGUMENT_RUSH_MOVE" => Some(Self::RushMove),
            "COMBAT_TYPE_ARGUMENT_ANIMATOR_PARAMETER_CHANGED" => {
                Some(Self::AnimatorParameterChanged)
            }
            "COMBAT_TYPE_ARGUMENT_ENTITY_MOVE" => Some(Self::EntityMove),
            "COMBAT_TYPE_ARGUMENT_SYNC_ENTITY_POSITION" => Some(Self::SyncEntityPosition),
            "COMBAT_TYPE_ARGUMENT_STEER_MOTION_INFO" => Some(Self::SteerMotionInfo),
            "COMBAT_TYPE_ARGUMENT_FORCE_SET_POS_INFO" => Some(Self::ForceSetPosInfo),
            "COMBAT_TYPE_ARGUMENT_COMPENSATE_POS_DIFF" => Some(Self::CompensatePosDiff),
            "COMBAT_TYPE_ARGUMENT_MONSTER_DO_BLINK" => Some(Self::MonsterDoBlink),
            "COMBAT_TYPE_ARGUMENT_FIXED_RUSH_MOVE" => Some(Self::FixedRushMove),
            "COMBAT_TYPE_ARGUMENT_SYNC_TRANSFORM" => Some(Self::SyncTransform),
            "COMBAT_TYPE_ARGUMENT_LIGHT_CORE_MOVE" => Some(Self::LightCoreMove),
            "COMBAT_TYPE_ARGUMENT_BEING_HEALED_NTF" => Some(Self::BeingHealedNtf),
            "COMBAT_TYPE_ARGUMENT_SKILL_ANCHOR_POSITION_NTF" => {
                Some(Self::SkillAnchorPositionNtf)
            }
            "COMBAT_TYPE_ARGUMENT_GRAPPLING_HOOK_MOVE" => Some(Self::GrapplingHookMove),
            "COMBAT_TYPE_ARGUMENT_SPECIAL_MOTION_INFO" => Some(Self::SpecialMotionInfo),
            "COMBAT_TYPE_ARGUMENT_FIXED_AVATAR_FLASH_MOVE" => {
                Some(Self::FixedAvatarFlashMove)
            }
            "COMBAT_TYPE_ARGUMENT_MULTI_OVERRIDE_ANIM" => Some(Self::MultiOverrideAnim),
            "COMBAT_TYPE_ARGUMENT_DEBUG_SYNC_MOTION" => Some(Self::DebugSyncMotion),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerBuffChangeType {
    AddServerBuff = 0,
    DelServerBuff = 1,
}
impl ServerBuffChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AddServerBuff => "SERVER_BUFF_CHANGE_TYPE_ADD_SERVER_BUFF",
            Self::DelServerBuff => "SERVER_BUFF_CHANGE_TYPE_DEL_SERVER_BUFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVER_BUFF_CHANGE_TYPE_ADD_SERVER_BUFF" => Some(Self::AddServerBuff),
            "SERVER_BUFF_CHANGE_TYPE_DEL_SERVER_BUFF" => Some(Self::DelServerBuff),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LuaOptionType {
    None = 0,
    PlayerInput = 1,
}
impl LuaOptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "LUA_OPTION_TYPE_NONE",
            Self::PlayerInput => "LUA_OPTION_TYPE_PLAYER_INPUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LUA_OPTION_TYPE_NONE" => Some(Self::None),
            "LUA_OPTION_TYPE_PLAYER_INPUT" => Some(Self::PlayerInput),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FishEscapeReason {
    None = 0,
    Shocked = 1,
    Unhook = 2,
}
impl FishEscapeReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FISH_ESCAPE_REASON_NONE",
            Self::Shocked => "FISH_ESCAPE_REASON_SHOCKED",
            Self::Unhook => "FISH_ESCAPE_REASON_UNHOOK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FISH_ESCAPE_REASON_NONE" => Some(Self::None),
            "FISH_ESCAPE_REASON_SHOCKED" => Some(Self::Shocked),
            "FISH_ESCAPE_REASON_UNHOOK" => Some(Self::Unhook),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FishBattleResult {
    None = 0,
    Succ = 1,
    Fail = 2,
    Timeout = 3,
    Cancel = 4,
    Exit = 5,
}
impl FishBattleResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FISH_BATTLE_RESULT_NONE",
            Self::Succ => "FISH_BATTLE_RESULT_SUCC",
            Self::Fail => "FISH_BATTLE_RESULT_FAIL",
            Self::Timeout => "FISH_BATTLE_RESULT_TIMEOUT",
            Self::Cancel => "FISH_BATTLE_RESULT_CANCEL",
            Self::Exit => "FISH_BATTLE_RESULT_EXIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FISH_BATTLE_RESULT_NONE" => Some(Self::None),
            "FISH_BATTLE_RESULT_SUCC" => Some(Self::Succ),
            "FISH_BATTLE_RESULT_FAIL" => Some(Self::Fail),
            "FISH_BATTLE_RESULT_TIMEOUT" => Some(Self::Timeout),
            "FISH_BATTLE_RESULT_CANCEL" => Some(Self::Cancel),
            "FISH_BATTLE_RESULT_EXIT" => Some(Self::Exit),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FishNoRewardReason {
    None = 0,
    ActivityLimit = 1,
    BagLimit = 2,
    PoolLimit = 3,
}
impl FishNoRewardReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FISH_NO_REWARD_REASON_NONE",
            Self::ActivityLimit => "FISH_NO_REWARD_REASON_ACTIVITY_LIMIT",
            Self::BagLimit => "FISH_NO_REWARD_REASON_BAG_LIMIT",
            Self::PoolLimit => "FISH_NO_REWARD_REASON_POOL_LIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FISH_NO_REWARD_REASON_NONE" => Some(Self::None),
            "FISH_NO_REWARD_REASON_ACTIVITY_LIMIT" => Some(Self::ActivityLimit),
            "FISH_NO_REWARD_REASON_BAG_LIMIT" => Some(Self::BagLimit),
            "FISH_NO_REWARD_REASON_POOL_LIMIT" => Some(Self::PoolLimit),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InteractType {
    None = 0,
    PickItem = 1,
    Gather = 2,
    OpenChest = 3,
    OpenStatue = 4,
    Consume = 5,
    MpPlayReward = 6,
    View = 7,
    GeneralReward = 8,
    MiracleRing = 9,
    Foundation = 10,
    EchoShell = 11,
    HomeGather = 12,
    EnvAnimal = 13,
    QuestGadget = 14,
    UiInteract = 15,
    DeshretObelisk = 16,
}
impl InteractType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "INTERACT_TYPE_NONE",
            Self::PickItem => "INTERACT_TYPE_PICK_ITEM",
            Self::Gather => "INTERACT_TYPE_GATHER",
            Self::OpenChest => "INTERACT_TYPE_OPEN_CHEST",
            Self::OpenStatue => "INTERACT_TYPE_OPEN_STATUE",
            Self::Consume => "INTERACT_TYPE_CONSUME",
            Self::MpPlayReward => "INTERACT_TYPE_MP_PLAY_REWARD",
            Self::View => "INTERACT_TYPE_VIEW",
            Self::GeneralReward => "INTERACT_TYPE_GENERAL_REWARD",
            Self::MiracleRing => "INTERACT_TYPE_MIRACLE_RING",
            Self::Foundation => "INTERACT_TYPE_FOUNDATION",
            Self::EchoShell => "INTERACT_TYPE_ECHO_SHELL",
            Self::HomeGather => "INTERACT_TYPE_HOME_GATHER",
            Self::EnvAnimal => "INTERACT_TYPE_ENV_ANIMAL",
            Self::QuestGadget => "INTERACT_TYPE_QUEST_GADGET",
            Self::UiInteract => "INTERACT_TYPE_UI_INTERACT",
            Self::DeshretObelisk => "INTERACT_TYPE_DESHRET_OBELISK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERACT_TYPE_NONE" => Some(Self::None),
            "INTERACT_TYPE_PICK_ITEM" => Some(Self::PickItem),
            "INTERACT_TYPE_GATHER" => Some(Self::Gather),
            "INTERACT_TYPE_OPEN_CHEST" => Some(Self::OpenChest),
            "INTERACT_TYPE_OPEN_STATUE" => Some(Self::OpenStatue),
            "INTERACT_TYPE_CONSUME" => Some(Self::Consume),
            "INTERACT_TYPE_MP_PLAY_REWARD" => Some(Self::MpPlayReward),
            "INTERACT_TYPE_VIEW" => Some(Self::View),
            "INTERACT_TYPE_GENERAL_REWARD" => Some(Self::GeneralReward),
            "INTERACT_TYPE_MIRACLE_RING" => Some(Self::MiracleRing),
            "INTERACT_TYPE_FOUNDATION" => Some(Self::Foundation),
            "INTERACT_TYPE_ECHO_SHELL" => Some(Self::EchoShell),
            "INTERACT_TYPE_HOME_GATHER" => Some(Self::HomeGather),
            "INTERACT_TYPE_ENV_ANIMAL" => Some(Self::EnvAnimal),
            "INTERACT_TYPE_QUEST_GADGET" => Some(Self::QuestGadget),
            "INTERACT_TYPE_UI_INTERACT" => Some(Self::UiInteract),
            "INTERACT_TYPE_DESHRET_OBELISK" => Some(Self::DeshretObelisk),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterOpType {
    Finish = 0,
    Start = 1,
}
impl InterOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Finish => "INTER_OP_TYPE_FINISH",
            Self::Start => "INTER_OP_TYPE_START",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTER_OP_TYPE_FINISH" => Some(Self::Finish),
            "INTER_OP_TYPE_START" => Some(Self::Start),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResinCostType {
    None = 0,
    Normal = 1,
    Condense = 2,
    ReunionPrivilege = 3,
    OpActivity = 4,
    Material = 5,
}
impl ResinCostType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "RESIN_COST_TYPE_NONE",
            Self::Normal => "RESIN_COST_TYPE_NORMAL",
            Self::Condense => "RESIN_COST_TYPE_CONDENSE",
            Self::ReunionPrivilege => "RESIN_COST_TYPE_REUNION_PRIVILEGE",
            Self::OpActivity => "RESIN_COST_TYPE_OP_ACTIVITY",
            Self::Material => "RESIN_COST_TYPE_MATERIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESIN_COST_TYPE_NONE" => Some(Self::None),
            "RESIN_COST_TYPE_NORMAL" => Some(Self::Normal),
            "RESIN_COST_TYPE_CONDENSE" => Some(Self::Condense),
            "RESIN_COST_TYPE_REUNION_PRIVILEGE" => Some(Self::ReunionPrivilege),
            "RESIN_COST_TYPE_OP_ACTIVITY" => Some(Self::OpActivity),
            "RESIN_COST_TYPE_MATERIAL" => Some(Self::Material),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FoundationOpType {
    None = 0,
    Build = 1,
    Demolition = 2,
    Rebuild = 3,
    Rotate = 4,
    Lock = 5,
    Unlock = 6,
}
impl FoundationOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FOUNDATION_OP_TYPE_NONE",
            Self::Build => "FOUNDATION_OP_TYPE_BUILD",
            Self::Demolition => "FOUNDATION_OP_TYPE_DEMOLITION",
            Self::Rebuild => "FOUNDATION_OP_TYPE_REBUILD",
            Self::Rotate => "FOUNDATION_OP_TYPE_ROTATE",
            Self::Lock => "FOUNDATION_OP_TYPE_LOCK",
            Self::Unlock => "FOUNDATION_OP_TYPE_UNLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FOUNDATION_OP_TYPE_NONE" => Some(Self::None),
            "FOUNDATION_OP_TYPE_BUILD" => Some(Self::Build),
            "FOUNDATION_OP_TYPE_DEMOLITION" => Some(Self::Demolition),
            "FOUNDATION_OP_TYPE_REBUILD" => Some(Self::Rebuild),
            "FOUNDATION_OP_TYPE_ROTATE" => Some(Self::Rotate),
            "FOUNDATION_OP_TYPE_LOCK" => Some(Self::Lock),
            "FOUNDATION_OP_TYPE_UNLOCK" => Some(Self::Unlock),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VehicleInteractType {
    None = 0,
    In = 1,
    Out = 2,
}
impl VehicleInteractType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "VEHICLE_INTERACT_TYPE_NONE",
            Self::In => "VEHICLE_INTERACT_TYPE_IN",
            Self::Out => "VEHICLE_INTERACT_TYPE_OUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VEHICLE_INTERACT_TYPE_NONE" => Some(Self::None),
            "VEHICLE_INTERACT_TYPE_IN" => Some(Self::In),
            "VEHICLE_INTERACT_TYPE_OUT" => Some(Self::Out),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpType {
    None = 0,
    Activate = 1,
    Deactivate = 2,
}
impl OpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "OP_TYPE_NONE",
            Self::Activate => "OP_TYPE_ACTIVATE",
            Self::Deactivate => "OP_TYPE_DEACTIVATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OP_TYPE_NONE" => Some(Self::None),
            "OP_TYPE_ACTIVATE" => Some(Self::Activate),
            "OP_TYPE_DEACTIVATE" => Some(Self::Deactivate),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GalleryStageType {
    None = 0,
    Prestart = 1,
    Start = 2,
}
impl GalleryStageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GALLERY_STAGE_TYPE_NONE",
            Self::Prestart => "GALLERY_STAGE_TYPE_PRESTART",
            Self::Start => "GALLERY_STAGE_TYPE_START",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GALLERY_STAGE_TYPE_NONE" => Some(Self::None),
            "GALLERY_STAGE_TYPE_PRESTART" => Some(Self::Prestart),
            "GALLERY_STAGE_TYPE_START" => Some(Self::Start),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GalleryStopReason {
    None = 0,
    Timeup = 1,
    ClientInterrupt = 2,
    LuaInterruptSuccess = 3,
    LuaInterruptFail = 4,
    OwnerLeaveScene = 5,
    PlayInitFailed = 6,
    OtherPlayerEnter = 7,
    AvatarDie = 8,
    Finished = 9,
    FungusAllDie = 10,
    LifeCountZero = 11,
    ActivityClosed = 12,
    LeaveRegionFail = 13,
    HeartBloodUsedOut = 14,
    GuardianStoneDie = 15,
}
impl GalleryStopReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GALLERY_STOP_REASON_NONE",
            Self::Timeup => "GALLERY_STOP_REASON_TIMEUP",
            Self::ClientInterrupt => "GALLERY_STOP_REASON_CLIENT_INTERRUPT",
            Self::LuaInterruptSuccess => "GALLERY_STOP_REASON_LUA_INTERRUPT_SUCCESS",
            Self::LuaInterruptFail => "GALLERY_STOP_REASON_LUA_INTERRUPT_FAIL",
            Self::OwnerLeaveScene => "GALLERY_STOP_REASON_OWNER_LEAVE_SCENE",
            Self::PlayInitFailed => "GALLERY_STOP_REASON_PLAY_INIT_FAILED",
            Self::OtherPlayerEnter => "GALLERY_STOP_REASON_OTHER_PLAYER_ENTER",
            Self::AvatarDie => "GALLERY_STOP_REASON_AVATAR_DIE",
            Self::Finished => "GALLERY_STOP_REASON_FINISHED",
            Self::FungusAllDie => "GALLERY_STOP_REASON_FUNGUS_ALL_DIE",
            Self::LifeCountZero => "GALLERY_STOP_REASON_LIFE_COUNT_ZERO",
            Self::ActivityClosed => "GALLERY_STOP_REASON_ACTIVITY_CLOSED",
            Self::LeaveRegionFail => "GALLERY_STOP_REASON_LEAVE_REGION_FAIL",
            Self::HeartBloodUsedOut => "GALLERY_STOP_REASON_HEART_BLOOD_USED_OUT",
            Self::GuardianStoneDie => "GALLERY_STOP_REASON_GUARDIAN_STONE_DIE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GALLERY_STOP_REASON_NONE" => Some(Self::None),
            "GALLERY_STOP_REASON_TIMEUP" => Some(Self::Timeup),
            "GALLERY_STOP_REASON_CLIENT_INTERRUPT" => Some(Self::ClientInterrupt),
            "GALLERY_STOP_REASON_LUA_INTERRUPT_SUCCESS" => {
                Some(Self::LuaInterruptSuccess)
            }
            "GALLERY_STOP_REASON_LUA_INTERRUPT_FAIL" => Some(Self::LuaInterruptFail),
            "GALLERY_STOP_REASON_OWNER_LEAVE_SCENE" => Some(Self::OwnerLeaveScene),
            "GALLERY_STOP_REASON_PLAY_INIT_FAILED" => Some(Self::PlayInitFailed),
            "GALLERY_STOP_REASON_OTHER_PLAYER_ENTER" => Some(Self::OtherPlayerEnter),
            "GALLERY_STOP_REASON_AVATAR_DIE" => Some(Self::AvatarDie),
            "GALLERY_STOP_REASON_FINISHED" => Some(Self::Finished),
            "GALLERY_STOP_REASON_FUNGUS_ALL_DIE" => Some(Self::FungusAllDie),
            "GALLERY_STOP_REASON_LIFE_COUNT_ZERO" => Some(Self::LifeCountZero),
            "GALLERY_STOP_REASON_ACTIVITY_CLOSED" => Some(Self::ActivityClosed),
            "GALLERY_STOP_REASON_LEAVE_REGION_FAIL" => Some(Self::LeaveRegionFail),
            "GALLERY_STOP_REASON_HEART_BLOOD_USED_OUT" => Some(Self::HeartBloodUsedOut),
            "GALLERY_STOP_REASON_GUARDIAN_STONE_DIE" => Some(Self::GuardianStoneDie),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GalleryStartSource {
    ByNone = 0,
    ByMatch = 1,
    ByDraft = 2,
}
impl GalleryStartSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ByNone => "GALLERY_START_SOURCE_BY_NONE",
            Self::ByMatch => "GALLERY_START_SOURCE_BY_MATCH",
            Self::ByDraft => "GALLERY_START_SOURCE_BY_DRAFT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GALLERY_START_SOURCE_BY_NONE" => Some(Self::ByNone),
            "GALLERY_START_SOURCE_BY_MATCH" => Some(Self::ByMatch),
            "GALLERY_START_SOURCE_BY_DRAFT" => Some(Self::ByDraft),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SalvagePreventStopReason {
    None = 0,
    Success = 1,
    Arrival = 2,
    Interrupt = 3,
    Leave = 4,
    Full = 5,
    Away = 6,
}
impl SalvagePreventStopReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SALVAGE_PREVENT_STOP_REASON_NONE",
            Self::Success => "SALVAGE_PREVENT_STOP_REASON_SUCCESS",
            Self::Arrival => "SALVAGE_PREVENT_STOP_REASON_ARRIVAL",
            Self::Interrupt => "SALVAGE_PREVENT_STOP_REASON_INTERRUPT",
            Self::Leave => "SALVAGE_PREVENT_STOP_REASON_LEAVE",
            Self::Full => "SALVAGE_PREVENT_STOP_REASON_FULL",
            Self::Away => "SALVAGE_PREVENT_STOP_REASON_AWAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SALVAGE_PREVENT_STOP_REASON_NONE" => Some(Self::None),
            "SALVAGE_PREVENT_STOP_REASON_SUCCESS" => Some(Self::Success),
            "SALVAGE_PREVENT_STOP_REASON_ARRIVAL" => Some(Self::Arrival),
            "SALVAGE_PREVENT_STOP_REASON_INTERRUPT" => Some(Self::Interrupt),
            "SALVAGE_PREVENT_STOP_REASON_LEAVE" => Some(Self::Leave),
            "SALVAGE_PREVENT_STOP_REASON_FULL" => Some(Self::Full),
            "SALVAGE_PREVENT_STOP_REASON_AWAY" => Some(Self::Away),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SalvageEscortStopReason {
    None = 0,
    Success = 1,
    Dump = 2,
    Time = 3,
    Interrupt = 4,
    Leave = 5,
    Full = 6,
}
impl SalvageEscortStopReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SALVAGE_ESCORT_STOP_REASON_NONE",
            Self::Success => "SALVAGE_ESCORT_STOP_REASON_SUCCESS",
            Self::Dump => "SALVAGE_ESCORT_STOP_REASON_DUMP",
            Self::Time => "SALVAGE_ESCORT_STOP_REASON_TIME",
            Self::Interrupt => "SALVAGE_ESCORT_STOP_REASON_INTERRUPT",
            Self::Leave => "SALVAGE_ESCORT_STOP_REASON_LEAVE",
            Self::Full => "SALVAGE_ESCORT_STOP_REASON_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SALVAGE_ESCORT_STOP_REASON_NONE" => Some(Self::None),
            "SALVAGE_ESCORT_STOP_REASON_SUCCESS" => Some(Self::Success),
            "SALVAGE_ESCORT_STOP_REASON_DUMP" => Some(Self::Dump),
            "SALVAGE_ESCORT_STOP_REASON_TIME" => Some(Self::Time),
            "SALVAGE_ESCORT_STOP_REASON_INTERRUPT" => Some(Self::Interrupt),
            "SALVAGE_ESCORT_STOP_REASON_LEAVE" => Some(Self::Leave),
            "SALVAGE_ESCORT_STOP_REASON_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IslandPartySailStage {
    None = 0,
    Sail = 1,
    Battle = 2,
}
impl IslandPartySailStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ISLAND_PARTY_SAIL_STAGE_NONE",
            Self::Sail => "ISLAND_PARTY_SAIL_STAGE_SAIL",
            Self::Battle => "ISLAND_PARTY_SAIL_STAGE_BATTLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ISLAND_PARTY_SAIL_STAGE_NONE" => Some(Self::None),
            "ISLAND_PARTY_SAIL_STAGE_SAIL" => Some(Self::Sail),
            "ISLAND_PARTY_SAIL_STAGE_BATTLE" => Some(Self::Battle),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SceneGallerySandwormCannonSpecialEffectType {
    NoneEffect = 0,
    WeakEffect = 1,
    StrongEffect = 2,
}
impl SceneGallerySandwormCannonSpecialEffectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoneEffect => {
                "SCENE_GALLERY_SANDWORM_CANNON_SPECIAL_EFFECT_TYPE_NONE_EFFECT"
            }
            Self::WeakEffect => {
                "SCENE_GALLERY_SANDWORM_CANNON_SPECIAL_EFFECT_TYPE_WEAK_EFFECT"
            }
            Self::StrongEffect => {
                "SCENE_GALLERY_SANDWORM_CANNON_SPECIAL_EFFECT_TYPE_STRONG_EFFECT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCENE_GALLERY_SANDWORM_CANNON_SPECIAL_EFFECT_TYPE_NONE_EFFECT" => {
                Some(Self::NoneEffect)
            }
            "SCENE_GALLERY_SANDWORM_CANNON_SPECIAL_EFFECT_TYPE_WEAK_EFFECT" => {
                Some(Self::WeakEffect)
            }
            "SCENE_GALLERY_SANDWORM_CANNON_SPECIAL_EFFECT_TYPE_STRONG_EFFECT" => {
                Some(Self::StrongEffect)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomGalleryScoreBoardType {
    Normal = 0,
    Countdown = 1,
    Timer = 2,
}
impl CustomGalleryScoreBoardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "CUSTOM_GALLERY_SCORE_BOARD_TYPE_NORMAL",
            Self::Countdown => "CUSTOM_GALLERY_SCORE_BOARD_TYPE_COUNTDOWN",
            Self::Timer => "CUSTOM_GALLERY_SCORE_BOARD_TYPE_TIMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CUSTOM_GALLERY_SCORE_BOARD_TYPE_NORMAL" => Some(Self::Normal),
            "CUSTOM_GALLERY_SCORE_BOARD_TYPE_COUNTDOWN" => Some(Self::Countdown),
            "CUSTOM_GALLERY_SCORE_BOARD_TYPE_TIMER" => Some(Self::Timer),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgSkillHpChangeType {
    None = 0,
    Damage = 1,
    Heal = 2,
}
impl GcgSkillHpChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_SKILL_HP_CHANGE_TYPE_NONE",
            Self::Damage => "GCG_SKILL_HP_CHANGE_TYPE_DAMAGE",
            Self::Heal => "GCG_SKILL_HP_CHANGE_TYPE_HEAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_SKILL_HP_CHANGE_TYPE_NONE" => Some(Self::None),
            "GCG_SKILL_HP_CHANGE_TYPE_DAMAGE" => Some(Self::Damage),
            "GCG_SKILL_HP_CHANGE_TYPE_HEAL" => Some(Self::Heal),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgSettleOption {
    OptNone = 0,
    OptExit = 1,
    OptContinue = 2,
    OptRestart = 3,
}
impl GcgSettleOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OptNone => "GCG_SETTLE_OPTION_OPT_NONE",
            Self::OptExit => "GCG_SETTLE_OPTION_OPT_EXIT",
            Self::OptContinue => "GCG_SETTLE_OPTION_OPT_CONTINUE",
            Self::OptRestart => "GCG_SETTLE_OPTION_OPT_RESTART",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_SETTLE_OPTION_OPT_NONE" => Some(Self::OptNone),
            "GCG_SETTLE_OPTION_OPT_EXIT" => Some(Self::OptExit),
            "GCG_SETTLE_OPTION_OPT_CONTINUE" => Some(Self::OptContinue),
            "GCG_SETTLE_OPTION_OPT_RESTART" => Some(Self::OptRestart),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgGameCreateReason {
    None = 0,
    GameMax = 1,
    ClientVersionNotLatest = 2,
    ResourceNotComplete = 3,
    Timeout = 4,
    OpponentClientVersionNotLatest = 5,
}
impl GcgGameCreateReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_GAME_CREATE_REASON_NONE",
            Self::GameMax => "GCG_GAME_CREATE_REASON_GAME_MAX",
            Self::ClientVersionNotLatest => {
                "GCG_GAME_CREATE_REASON_CLIENT_VERSION_NOT_LATEST"
            }
            Self::ResourceNotComplete => "GCG_GAME_CREATE_REASON_RESOURCE_NOT_COMPLETE",
            Self::Timeout => "GCG_GAME_CREATE_REASON_TIMEOUT",
            Self::OpponentClientVersionNotLatest => {
                "GCG_GAME_CREATE_REASON_OPPONENT_CLIENT_VERSION_NOT_LATEST"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_GAME_CREATE_REASON_NONE" => Some(Self::None),
            "GCG_GAME_CREATE_REASON_GAME_MAX" => Some(Self::GameMax),
            "GCG_GAME_CREATE_REASON_CLIENT_VERSION_NOT_LATEST" => {
                Some(Self::ClientVersionNotLatest)
            }
            "GCG_GAME_CREATE_REASON_RESOURCE_NOT_COMPLETE" => {
                Some(Self::ResourceNotComplete)
            }
            "GCG_GAME_CREATE_REASON_TIMEOUT" => Some(Self::Timeout),
            "GCG_GAME_CREATE_REASON_OPPONENT_CLIENT_VERSION_NOT_LATEST" => {
                Some(Self::OpponentClientVersionNotLatest)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgHintType {
    None = 0,
    GameNotFound = 1,
}
impl GcgHintType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_HINT_TYPE_NONE",
            Self::GameNotFound => "GCG_HINT_TYPE_GAME_NOT_FOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_HINT_TYPE_NONE" => Some(Self::None),
            "GCG_HINT_TYPE_GAME_NOT_FOUND" => Some(Self::GameNotFound),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgActionType {
    None = 0,
    SpecialPhase = 1,
    NextPhase = 2,
    Draw = 3,
    Redraw = 4,
    SelectOnstage = 5,
    Roll = 6,
    Reroll = 7,
    Attack = 8,
    PlayCard = 9,
    Pass = 10,
    Reboot = 11,
    GameOver = 12,
    Trigger = 13,
    PhaseExit = 14,
    Custom = 15,
    NotifyCost = 16,
    AfterOperation = 17,
    UseSkill = 18,
    NotifySkillPreview = 19,
    PreviewAttack = 20,
    PreviewAfterAttack = 21,
    SendMessage = 22,
    WaitingCharacter = 23,
    TriggerSkill = 24,
    BeforeNextOperation = 25,
    RemoveCharacterCard = 26,
}
impl GcgActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_ACTION_TYPE_NONE",
            Self::SpecialPhase => "GCG_ACTION_TYPE_SPECIAL_PHASE",
            Self::NextPhase => "GCG_ACTION_TYPE_NEXT_PHASE",
            Self::Draw => "GCG_ACTION_TYPE_DRAW",
            Self::Redraw => "GCG_ACTION_TYPE_REDRAW",
            Self::SelectOnstage => "GCG_ACTION_TYPE_SELECT_ONSTAGE",
            Self::Roll => "GCG_ACTION_TYPE_ROLL",
            Self::Reroll => "GCG_ACTION_TYPE_REROLL",
            Self::Attack => "GCG_ACTION_TYPE_ATTACK",
            Self::PlayCard => "GCG_ACTION_TYPE_PLAY_CARD",
            Self::Pass => "GCG_ACTION_TYPE_PASS",
            Self::Reboot => "GCG_ACTION_TYPE_REBOOT",
            Self::GameOver => "GCG_ACTION_TYPE_GAME_OVER",
            Self::Trigger => "GCG_ACTION_TYPE_TRIGGER",
            Self::PhaseExit => "GCG_ACTION_TYPE_PHASE_EXIT",
            Self::Custom => "GCG_ACTION_TYPE_CUSTOM",
            Self::NotifyCost => "GCG_ACTION_TYPE_NOTIFY_COST",
            Self::AfterOperation => "GCG_ACTION_TYPE_AFTER_OPERATION",
            Self::UseSkill => "GCG_ACTION_TYPE_USE_SKILL",
            Self::NotifySkillPreview => "GCG_ACTION_TYPE_NOTIFY_SKILL_PREVIEW",
            Self::PreviewAttack => "GCG_ACTION_TYPE_PREVIEW_ATTACK",
            Self::PreviewAfterAttack => "GCG_ACTION_TYPE_PREVIEW_AFTER_ATTACK",
            Self::SendMessage => "GCG_ACTION_TYPE_SEND_MESSAGE",
            Self::WaitingCharacter => "GCG_ACTION_TYPE_WAITING_CHARACTER",
            Self::TriggerSkill => "GCG_ACTION_TYPE_TRIGGER_SKILL",
            Self::BeforeNextOperation => "GCG_ACTION_TYPE_BEFORE_NEXT_OPERATION",
            Self::RemoveCharacterCard => "GCG_ACTION_TYPE_REMOVE_CHARACTER_CARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_ACTION_TYPE_NONE" => Some(Self::None),
            "GCG_ACTION_TYPE_SPECIAL_PHASE" => Some(Self::SpecialPhase),
            "GCG_ACTION_TYPE_NEXT_PHASE" => Some(Self::NextPhase),
            "GCG_ACTION_TYPE_DRAW" => Some(Self::Draw),
            "GCG_ACTION_TYPE_REDRAW" => Some(Self::Redraw),
            "GCG_ACTION_TYPE_SELECT_ONSTAGE" => Some(Self::SelectOnstage),
            "GCG_ACTION_TYPE_ROLL" => Some(Self::Roll),
            "GCG_ACTION_TYPE_REROLL" => Some(Self::Reroll),
            "GCG_ACTION_TYPE_ATTACK" => Some(Self::Attack),
            "GCG_ACTION_TYPE_PLAY_CARD" => Some(Self::PlayCard),
            "GCG_ACTION_TYPE_PASS" => Some(Self::Pass),
            "GCG_ACTION_TYPE_REBOOT" => Some(Self::Reboot),
            "GCG_ACTION_TYPE_GAME_OVER" => Some(Self::GameOver),
            "GCG_ACTION_TYPE_TRIGGER" => Some(Self::Trigger),
            "GCG_ACTION_TYPE_PHASE_EXIT" => Some(Self::PhaseExit),
            "GCG_ACTION_TYPE_CUSTOM" => Some(Self::Custom),
            "GCG_ACTION_TYPE_NOTIFY_COST" => Some(Self::NotifyCost),
            "GCG_ACTION_TYPE_AFTER_OPERATION" => Some(Self::AfterOperation),
            "GCG_ACTION_TYPE_USE_SKILL" => Some(Self::UseSkill),
            "GCG_ACTION_TYPE_NOTIFY_SKILL_PREVIEW" => Some(Self::NotifySkillPreview),
            "GCG_ACTION_TYPE_PREVIEW_ATTACK" => Some(Self::PreviewAttack),
            "GCG_ACTION_TYPE_PREVIEW_AFTER_ATTACK" => Some(Self::PreviewAfterAttack),
            "GCG_ACTION_TYPE_SEND_MESSAGE" => Some(Self::SendMessage),
            "GCG_ACTION_TYPE_WAITING_CHARACTER" => Some(Self::WaitingCharacter),
            "GCG_ACTION_TYPE_TRIGGER_SKILL" => Some(Self::TriggerSkill),
            "GCG_ACTION_TYPE_BEFORE_NEXT_OPERATION" => Some(Self::BeforeNextOperation),
            "GCG_ACTION_TYPE_REMOVE_CHARACTER_CARD" => Some(Self::RemoveCharacterCard),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgDiceSideType {
    Invalid = 0,
    Cryo = 1,
    Hydro = 2,
    Pyro = 3,
    Electro = 4,
    Geo = 5,
    Dendro = 6,
    Anemo = 7,
    Paimon = 8,
}
impl GcgDiceSideType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "GCG_DICE_SIDE_TYPE_INVALID",
            Self::Cryo => "GCG_DICE_SIDE_TYPE_CRYO",
            Self::Hydro => "GCG_DICE_SIDE_TYPE_HYDRO",
            Self::Pyro => "GCG_DICE_SIDE_TYPE_PYRO",
            Self::Electro => "GCG_DICE_SIDE_TYPE_ELECTRO",
            Self::Geo => "GCG_DICE_SIDE_TYPE_GEO",
            Self::Dendro => "GCG_DICE_SIDE_TYPE_DENDRO",
            Self::Anemo => "GCG_DICE_SIDE_TYPE_ANEMO",
            Self::Paimon => "GCG_DICE_SIDE_TYPE_PAIMON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_DICE_SIDE_TYPE_INVALID" => Some(Self::Invalid),
            "GCG_DICE_SIDE_TYPE_CRYO" => Some(Self::Cryo),
            "GCG_DICE_SIDE_TYPE_HYDRO" => Some(Self::Hydro),
            "GCG_DICE_SIDE_TYPE_PYRO" => Some(Self::Pyro),
            "GCG_DICE_SIDE_TYPE_ELECTRO" => Some(Self::Electro),
            "GCG_DICE_SIDE_TYPE_GEO" => Some(Self::Geo),
            "GCG_DICE_SIDE_TYPE_DENDRO" => Some(Self::Dendro),
            "GCG_DICE_SIDE_TYPE_ANEMO" => Some(Self::Anemo),
            "GCG_DICE_SIDE_TYPE_PAIMON" => Some(Self::Paimon),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgZoneType {
    Invalid = 0,
    Deck = 1,
    Hand = 2,
    Character = 3,
    Modify = 4,
    Summon = 5,
    Assist = 7,
    Onstage = 8,
    Rule = 9,
}
impl GcgZoneType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "GCG_ZONE_TYPE_INVALID",
            Self::Deck => "GCG_ZONE_TYPE_DECK",
            Self::Hand => "GCG_ZONE_TYPE_HAND",
            Self::Character => "GCG_ZONE_TYPE_CHARACTER",
            Self::Modify => "GCG_ZONE_TYPE_MODIFY",
            Self::Summon => "GCG_ZONE_TYPE_SUMMON",
            Self::Assist => "GCG_ZONE_TYPE_ASSIST",
            Self::Onstage => "GCG_ZONE_TYPE_ONSTAGE",
            Self::Rule => "GCG_ZONE_TYPE_RULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_ZONE_TYPE_INVALID" => Some(Self::Invalid),
            "GCG_ZONE_TYPE_DECK" => Some(Self::Deck),
            "GCG_ZONE_TYPE_HAND" => Some(Self::Hand),
            "GCG_ZONE_TYPE_CHARACTER" => Some(Self::Character),
            "GCG_ZONE_TYPE_MODIFY" => Some(Self::Modify),
            "GCG_ZONE_TYPE_SUMMON" => Some(Self::Summon),
            "GCG_ZONE_TYPE_ASSIST" => Some(Self::Assist),
            "GCG_ZONE_TYPE_ONSTAGE" => Some(Self::Onstage),
            "GCG_ZONE_TYPE_RULE" => Some(Self::Rule),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgPhaseType {
    Invalid = 0,
    Start = 1,
    Draw = 2,
    OnStage = 3,
    Dice = 4,
    Main = 5,
    End = 6,
    Die = 7,
    Fin = 8,
    PreMain = 9,
    Reroll = 10,
    Redraw = 11,
}
impl GcgPhaseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "GCG_PHASE_TYPE_INVALID",
            Self::Start => "GCG_PHASE_TYPE_START",
            Self::Draw => "GCG_PHASE_TYPE_DRAW",
            Self::OnStage => "GCG_PHASE_TYPE_ON_STAGE",
            Self::Dice => "GCG_PHASE_TYPE_DICE",
            Self::Main => "GCG_PHASE_TYPE_MAIN",
            Self::End => "GCG_PHASE_TYPE_END",
            Self::Die => "GCG_PHASE_TYPE_DIE",
            Self::Fin => "GCG_PHASE_TYPE_FIN",
            Self::PreMain => "GCG_PHASE_TYPE_PRE_MAIN",
            Self::Reroll => "GCG_PHASE_TYPE_REROLL",
            Self::Redraw => "GCG_PHASE_TYPE_REDRAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_PHASE_TYPE_INVALID" => Some(Self::Invalid),
            "GCG_PHASE_TYPE_START" => Some(Self::Start),
            "GCG_PHASE_TYPE_DRAW" => Some(Self::Draw),
            "GCG_PHASE_TYPE_ON_STAGE" => Some(Self::OnStage),
            "GCG_PHASE_TYPE_DICE" => Some(Self::Dice),
            "GCG_PHASE_TYPE_MAIN" => Some(Self::Main),
            "GCG_PHASE_TYPE_END" => Some(Self::End),
            "GCG_PHASE_TYPE_DIE" => Some(Self::Die),
            "GCG_PHASE_TYPE_FIN" => Some(Self::Fin),
            "GCG_PHASE_TYPE_PRE_MAIN" => Some(Self::PreMain),
            "GCG_PHASE_TYPE_REROLL" => Some(Self::Reroll),
            "GCG_PHASE_TYPE_REDRAW" => Some(Self::Redraw),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgReason {
    Default = 0,
    Effect = 1,
    Cost = 2,
    Gm = 3,
    Attack = 4,
    Reboot = 5,
    PlayCard = 6,
    QuicklyOnstage = 7,
    RemoveAfterDie = 8,
    Init = 9,
    EffectDamage = 10,
    EffectHeal = 11,
    EffectRevive = 12,
    InitOnstage = 13,
    DieOnstage = 14,
    SelectOnstage = 15,
    CharacterDie = 16,
    ReviveWhenDeath = 17,
    TransferToOpponent = 18,
    TransferDice = 19,
}
impl GcgReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "GCG_REASON_DEFAULT",
            Self::Effect => "GCG_REASON_EFFECT",
            Self::Cost => "GCG_REASON_COST",
            Self::Gm => "GCG_REASON_GM",
            Self::Attack => "GCG_REASON_ATTACK",
            Self::Reboot => "GCG_REASON_REBOOT",
            Self::PlayCard => "GCG_REASON_PLAY_CARD",
            Self::QuicklyOnstage => "GCG_REASON_QUICKLY_ONSTAGE",
            Self::RemoveAfterDie => "GCG_REASON_REMOVE_AFTER_DIE",
            Self::Init => "GCG_REASON_INIT",
            Self::EffectDamage => "GCG_REASON_EFFECT_DAMAGE",
            Self::EffectHeal => "GCG_REASON_EFFECT_HEAL",
            Self::EffectRevive => "GCG_REASON_EFFECT_REVIVE",
            Self::InitOnstage => "GCG_REASON_INIT_ONSTAGE",
            Self::DieOnstage => "GCG_REASON_DIE_ONSTAGE",
            Self::SelectOnstage => "GCG_REASON_SELECT_ONSTAGE",
            Self::CharacterDie => "GCG_REASON_CHARACTER_DIE",
            Self::ReviveWhenDeath => "GCG_REASON_REVIVE_WHEN_DEATH",
            Self::TransferToOpponent => "GCG_REASON_TRANSFER_TO_OPPONENT",
            Self::TransferDice => "GCG_REASON_TRANSFER_DICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_REASON_DEFAULT" => Some(Self::Default),
            "GCG_REASON_EFFECT" => Some(Self::Effect),
            "GCG_REASON_COST" => Some(Self::Cost),
            "GCG_REASON_GM" => Some(Self::Gm),
            "GCG_REASON_ATTACK" => Some(Self::Attack),
            "GCG_REASON_REBOOT" => Some(Self::Reboot),
            "GCG_REASON_PLAY_CARD" => Some(Self::PlayCard),
            "GCG_REASON_QUICKLY_ONSTAGE" => Some(Self::QuicklyOnstage),
            "GCG_REASON_REMOVE_AFTER_DIE" => Some(Self::RemoveAfterDie),
            "GCG_REASON_INIT" => Some(Self::Init),
            "GCG_REASON_EFFECT_DAMAGE" => Some(Self::EffectDamage),
            "GCG_REASON_EFFECT_HEAL" => Some(Self::EffectHeal),
            "GCG_REASON_EFFECT_REVIVE" => Some(Self::EffectRevive),
            "GCG_REASON_INIT_ONSTAGE" => Some(Self::InitOnstage),
            "GCG_REASON_DIE_ONSTAGE" => Some(Self::DieOnstage),
            "GCG_REASON_SELECT_ONSTAGE" => Some(Self::SelectOnstage),
            "GCG_REASON_CHARACTER_DIE" => Some(Self::CharacterDie),
            "GCG_REASON_REVIVE_WHEN_DEATH" => Some(Self::ReviveWhenDeath),
            "GCG_REASON_TRANSFER_TO_OPPONENT" => Some(Self::TransferToOpponent),
            "GCG_REASON_TRANSFER_DICE" => Some(Self::TransferDice),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgClientPerformType {
    Invalid = 0,
    CardExchange = 1,
    FirstHand = 2,
    Reroll = 3,
    PreformCostRevise = 4,
    Redraw = 5,
    History = 6,
}
impl GcgClientPerformType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "GCG_CLIENT_PERFORM_TYPE_INVALID",
            Self::CardExchange => "GCG_CLIENT_PERFORM_TYPE_CARD_EXCHANGE",
            Self::FirstHand => "GCG_CLIENT_PERFORM_TYPE_FIRST_HAND",
            Self::Reroll => "GCG_CLIENT_PERFORM_TYPE_REROLL",
            Self::PreformCostRevise => "GCG_CLIENT_PERFORM_TYPE_PREFORM_COST_REVISE",
            Self::Redraw => "GCG_CLIENT_PERFORM_TYPE_REDRAW",
            Self::History => "GCG_CLIENT_PERFORM_TYPE_HISTORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_CLIENT_PERFORM_TYPE_INVALID" => Some(Self::Invalid),
            "GCG_CLIENT_PERFORM_TYPE_CARD_EXCHANGE" => Some(Self::CardExchange),
            "GCG_CLIENT_PERFORM_TYPE_FIRST_HAND" => Some(Self::FirstHand),
            "GCG_CLIENT_PERFORM_TYPE_REROLL" => Some(Self::Reroll),
            "GCG_CLIENT_PERFORM_TYPE_PREFORM_COST_REVISE" => {
                Some(Self::PreformCostRevise)
            }
            "GCG_CLIENT_PERFORM_TYPE_REDRAW" => Some(Self::Redraw),
            "GCG_CLIENT_PERFORM_TYPE_HISTORY" => Some(Self::History),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgEndReason {
    Default = 0,
    Die = 1,
    Surrender = 2,
    Disconnected = 3,
    RoundLimit = 4,
    Gm = 5,
    NoPlayer = 6,
    GiveUp = 7,
    InitTimeout = 8,
    Effect = 9,
    ExpireTimeout = 10,
}
impl GcgEndReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "GCG_END_REASON_DEFAULT",
            Self::Die => "GCG_END_REASON_DIE",
            Self::Surrender => "GCG_END_REASON_SURRENDER",
            Self::Disconnected => "GCG_END_REASON_DISCONNECTED",
            Self::RoundLimit => "GCG_END_REASON_ROUND_LIMIT",
            Self::Gm => "GCG_END_REASON_GM",
            Self::NoPlayer => "GCG_END_REASON_NO_PLAYER",
            Self::GiveUp => "GCG_END_REASON_GIVE_UP",
            Self::InitTimeout => "GCG_END_REASON_INIT_TIMEOUT",
            Self::Effect => "GCG_END_REASON_EFFECT",
            Self::ExpireTimeout => "GCG_END_REASON_EXPIRE_TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_END_REASON_DEFAULT" => Some(Self::Default),
            "GCG_END_REASON_DIE" => Some(Self::Die),
            "GCG_END_REASON_SURRENDER" => Some(Self::Surrender),
            "GCG_END_REASON_DISCONNECTED" => Some(Self::Disconnected),
            "GCG_END_REASON_ROUND_LIMIT" => Some(Self::RoundLimit),
            "GCG_END_REASON_GM" => Some(Self::Gm),
            "GCG_END_REASON_NO_PLAYER" => Some(Self::NoPlayer),
            "GCG_END_REASON_GIVE_UP" => Some(Self::GiveUp),
            "GCG_END_REASON_INIT_TIMEOUT" => Some(Self::InitTimeout),
            "GCG_END_REASON_EFFECT" => Some(Self::Effect),
            "GCG_END_REASON_EXPIRE_TIMEOUT" => Some(Self::ExpireTimeout),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgGameBusinessType {
    None = 0,
    Gm = 1,
    Match = 2,
    Pvp = 3,
    TavernChallenge = 4,
    ConstChallenge = 5,
    WorldChallenge = 6,
    BossChallenge = 7,
    WeekChallenge = 8,
    BreakChallenge = 9,
    Quest = 10,
    GuideGroup = 11,
    Other = 12,
    ActivityJourney = 13,
    PveActivity = 14,
    Arena = 15,
}
impl GcgGameBusinessType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_GAME_BUSINESS_TYPE_NONE",
            Self::Gm => "GCG_GAME_BUSINESS_TYPE_GM",
            Self::Match => "GCG_GAME_BUSINESS_TYPE_MATCH",
            Self::Pvp => "GCG_GAME_BUSINESS_TYPE_PVP",
            Self::TavernChallenge => "GCG_GAME_BUSINESS_TYPE_TAVERN_CHALLENGE",
            Self::ConstChallenge => "GCG_GAME_BUSINESS_TYPE_CONST_CHALLENGE",
            Self::WorldChallenge => "GCG_GAME_BUSINESS_TYPE_WORLD_CHALLENGE",
            Self::BossChallenge => "GCG_GAME_BUSINESS_TYPE_BOSS_CHALLENGE",
            Self::WeekChallenge => "GCG_GAME_BUSINESS_TYPE_WEEK_CHALLENGE",
            Self::BreakChallenge => "GCG_GAME_BUSINESS_TYPE_BREAK_CHALLENGE",
            Self::Quest => "GCG_GAME_BUSINESS_TYPE_QUEST",
            Self::GuideGroup => "GCG_GAME_BUSINESS_TYPE_GUIDE_GROUP",
            Self::Other => "GCG_GAME_BUSINESS_TYPE_OTHER",
            Self::ActivityJourney => "GCG_GAME_BUSINESS_TYPE_ACTIVITY_JOURNEY",
            Self::PveActivity => "GCG_GAME_BUSINESS_TYPE_PVE_ACTIVITY",
            Self::Arena => "GCG_GAME_BUSINESS_TYPE_ARENA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_GAME_BUSINESS_TYPE_NONE" => Some(Self::None),
            "GCG_GAME_BUSINESS_TYPE_GM" => Some(Self::Gm),
            "GCG_GAME_BUSINESS_TYPE_MATCH" => Some(Self::Match),
            "GCG_GAME_BUSINESS_TYPE_PVP" => Some(Self::Pvp),
            "GCG_GAME_BUSINESS_TYPE_TAVERN_CHALLENGE" => Some(Self::TavernChallenge),
            "GCG_GAME_BUSINESS_TYPE_CONST_CHALLENGE" => Some(Self::ConstChallenge),
            "GCG_GAME_BUSINESS_TYPE_WORLD_CHALLENGE" => Some(Self::WorldChallenge),
            "GCG_GAME_BUSINESS_TYPE_BOSS_CHALLENGE" => Some(Self::BossChallenge),
            "GCG_GAME_BUSINESS_TYPE_WEEK_CHALLENGE" => Some(Self::WeekChallenge),
            "GCG_GAME_BUSINESS_TYPE_BREAK_CHALLENGE" => Some(Self::BreakChallenge),
            "GCG_GAME_BUSINESS_TYPE_QUEST" => Some(Self::Quest),
            "GCG_GAME_BUSINESS_TYPE_GUIDE_GROUP" => Some(Self::GuideGroup),
            "GCG_GAME_BUSINESS_TYPE_OTHER" => Some(Self::Other),
            "GCG_GAME_BUSINESS_TYPE_ACTIVITY_JOURNEY" => Some(Self::ActivityJourney),
            "GCG_GAME_BUSINESS_TYPE_PVE_ACTIVITY" => Some(Self::PveActivity),
            "GCG_GAME_BUSINESS_TYPE_ARENA" => Some(Self::Arena),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgLevelType {
    None = 0,
    Const = 1,
    Week = 2,
    World = 3,
    Boss = 4,
    Character = 5,
    Break = 6,
    Quest = 7,
    GuideGroup = 8,
    Other = 9,
    Journey = 10,
    Pve = 11,
}
impl GcgLevelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_LEVEL_TYPE_NONE",
            Self::Const => "GCG_LEVEL_TYPE_CONST",
            Self::Week => "GCG_LEVEL_TYPE_WEEK",
            Self::World => "GCG_LEVEL_TYPE_WORLD",
            Self::Boss => "GCG_LEVEL_TYPE_BOSS",
            Self::Character => "GCG_LEVEL_TYPE_CHARACTER",
            Self::Break => "GCG_LEVEL_TYPE_BREAK",
            Self::Quest => "GCG_LEVEL_TYPE_QUEST",
            Self::GuideGroup => "GCG_LEVEL_TYPE_GUIDE_GROUP",
            Self::Other => "GCG_LEVEL_TYPE_OTHER",
            Self::Journey => "GCG_LEVEL_TYPE_JOURNEY",
            Self::Pve => "GCG_LEVEL_TYPE_PVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_LEVEL_TYPE_NONE" => Some(Self::None),
            "GCG_LEVEL_TYPE_CONST" => Some(Self::Const),
            "GCG_LEVEL_TYPE_WEEK" => Some(Self::Week),
            "GCG_LEVEL_TYPE_WORLD" => Some(Self::World),
            "GCG_LEVEL_TYPE_BOSS" => Some(Self::Boss),
            "GCG_LEVEL_TYPE_CHARACTER" => Some(Self::Character),
            "GCG_LEVEL_TYPE_BREAK" => Some(Self::Break),
            "GCG_LEVEL_TYPE_QUEST" => Some(Self::Quest),
            "GCG_LEVEL_TYPE_GUIDE_GROUP" => Some(Self::GuideGroup),
            "GCG_LEVEL_TYPE_OTHER" => Some(Self::Other),
            "GCG_LEVEL_TYPE_JOURNEY" => Some(Self::Journey),
            "GCG_LEVEL_TYPE_PVE" => Some(Self::Pve),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcgIntentionChangeType {
    None = 0,
    Rm = 1,
}
impl GcgIntentionChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GCG_INTENTION_CHANGE_TYPE_NONE",
            Self::Rm => "GCG_INTENTION_CHANGE_TYPE_RM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCG_INTENTION_CHANGE_TYPE_NONE" => Some(Self::None),
            "GCG_INTENTION_CHANGE_TYPE_RM" => Some(Self::Rm),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HomePlantFieldStatus {
    StatueNone = 0,
    StatueSeed = 1,
    StatueSprout = 2,
    StatueGather = 3,
}
impl HomePlantFieldStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StatueNone => "HOME_PLANT_FIELD_STATUS_STATUE_NONE",
            Self::StatueSeed => "HOME_PLANT_FIELD_STATUS_STATUE_SEED",
            Self::StatueSprout => "HOME_PLANT_FIELD_STATUS_STATUE_SPROUT",
            Self::StatueGather => "HOME_PLANT_FIELD_STATUS_STATUE_GATHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HOME_PLANT_FIELD_STATUS_STATUE_NONE" => Some(Self::StatueNone),
            "HOME_PLANT_FIELD_STATUS_STATUE_SEED" => Some(Self::StatueSeed),
            "HOME_PLANT_FIELD_STATUS_STATUE_SPROUT" => Some(Self::StatueSprout),
            "HOME_PLANT_FIELD_STATUS_STATUE_GATHER" => Some(Self::StatueGather),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerApplyEnterHomeReason {
    ReasonPlayerJudge = 0,
    ReasonPlayerEnterOptionRefuse = 1,
    ReasonPlayerEnterOptionDirect = 2,
    ReasonSystemJudge = 3,
    ReasonHostInMatch = 4,
    ReasonPsPlayerNotAcceptOthers = 5,
    ReasonOpenStateNotOpen = 6,
    ReasonHostInEditMode = 7,
    ReasonPriorCheck = 8,
}
impl PlayerApplyEnterHomeReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonPlayerJudge => "PlayerApplyEnterHomeReason_REASON_PLAYER_JUDGE",
            Self::ReasonPlayerEnterOptionRefuse => {
                "PlayerApplyEnterHomeReason_REASON_PLAYER_ENTER_OPTION_REFUSE"
            }
            Self::ReasonPlayerEnterOptionDirect => {
                "PlayerApplyEnterHomeReason_REASON_PLAYER_ENTER_OPTION_DIRECT"
            }
            Self::ReasonSystemJudge => "PlayerApplyEnterHomeReason_REASON_SYSTEM_JUDGE",
            Self::ReasonHostInMatch => "PlayerApplyEnterHomeReason_REASON_HOST_IN_MATCH",
            Self::ReasonPsPlayerNotAcceptOthers => {
                "PlayerApplyEnterHomeReason_REASON_PS_PLAYER_NOT_ACCEPT_OTHERS"
            }
            Self::ReasonOpenStateNotOpen => {
                "PlayerApplyEnterHomeReason_REASON_OPEN_STATE_NOT_OPEN"
            }
            Self::ReasonHostInEditMode => {
                "PlayerApplyEnterHomeReason_REASON_HOST_IN_EDIT_MODE"
            }
            Self::ReasonPriorCheck => "PlayerApplyEnterHomeReason_REASON_PRIOR_CHECK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerApplyEnterHomeReason_REASON_PLAYER_JUDGE" => {
                Some(Self::ReasonPlayerJudge)
            }
            "PlayerApplyEnterHomeReason_REASON_PLAYER_ENTER_OPTION_REFUSE" => {
                Some(Self::ReasonPlayerEnterOptionRefuse)
            }
            "PlayerApplyEnterHomeReason_REASON_PLAYER_ENTER_OPTION_DIRECT" => {
                Some(Self::ReasonPlayerEnterOptionDirect)
            }
            "PlayerApplyEnterHomeReason_REASON_SYSTEM_JUDGE" => {
                Some(Self::ReasonSystemJudge)
            }
            "PlayerApplyEnterHomeReason_REASON_HOST_IN_MATCH" => {
                Some(Self::ReasonHostInMatch)
            }
            "PlayerApplyEnterHomeReason_REASON_PS_PLAYER_NOT_ACCEPT_OTHERS" => {
                Some(Self::ReasonPsPlayerNotAcceptOthers)
            }
            "PlayerApplyEnterHomeReason_REASON_OPEN_STATE_NOT_OPEN" => {
                Some(Self::ReasonOpenStateNotOpen)
            }
            "PlayerApplyEnterHomeReason_REASON_HOST_IN_EDIT_MODE" => {
                Some(Self::ReasonHostInEditMode)
            }
            "PlayerApplyEnterHomeReason_REASON_PRIOR_CHECK" => {
                Some(Self::ReasonPriorCheck)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerQuitFromHomeReason {
    QuitReasonInvalid = 0,
    QuitReasonKickByHost = 1,
    QuitReasonBackToMyWorld = 2,
    QuitReasonHomeBlocked = 3,
    QuitReasonHomeInEditMode = 4,
    QuitReasonByMuip = 5,
    QuitReasonCurModuleClosed = 6,
}
impl PlayerQuitFromHomeReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::QuitReasonInvalid => "PlayerQuitFromHomeReason_QUIT_REASON_INVALID",
            Self::QuitReasonKickByHost => {
                "PlayerQuitFromHomeReason_QUIT_REASON_KICK_BY_HOST"
            }
            Self::QuitReasonBackToMyWorld => {
                "PlayerQuitFromHomeReason_QUIT_REASON_BACK_TO_MY_WORLD"
            }
            Self::QuitReasonHomeBlocked => {
                "PlayerQuitFromHomeReason_QUIT_REASON_HOME_BLOCKED"
            }
            Self::QuitReasonHomeInEditMode => {
                "PlayerQuitFromHomeReason_QUIT_REASON_HOME_IN_EDIT_MODE"
            }
            Self::QuitReasonByMuip => "PlayerQuitFromHomeReason_QUIT_REASON_BY_MUIP",
            Self::QuitReasonCurModuleClosed => {
                "PlayerQuitFromHomeReason_QUIT_REASON_CUR_MODULE_CLOSED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerQuitFromHomeReason_QUIT_REASON_INVALID" => {
                Some(Self::QuitReasonInvalid)
            }
            "PlayerQuitFromHomeReason_QUIT_REASON_KICK_BY_HOST" => {
                Some(Self::QuitReasonKickByHost)
            }
            "PlayerQuitFromHomeReason_QUIT_REASON_BACK_TO_MY_WORLD" => {
                Some(Self::QuitReasonBackToMyWorld)
            }
            "PlayerQuitFromHomeReason_QUIT_REASON_HOME_BLOCKED" => {
                Some(Self::QuitReasonHomeBlocked)
            }
            "PlayerQuitFromHomeReason_QUIT_REASON_HOME_IN_EDIT_MODE" => {
                Some(Self::QuitReasonHomeInEditMode)
            }
            "PlayerQuitFromHomeReason_QUIT_REASON_BY_MUIP" => {
                Some(Self::QuitReasonByMuip)
            }
            "PlayerQuitFromHomeReason_QUIT_REASON_CUR_MODULE_CLOSED" => {
                Some(Self::QuitReasonCurModuleClosed)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OtherPlayerEnterHomeNotifyReason {
    ReasonInvalid = 0,
    ReasonEnter = 1,
    ReasonLeave = 2,
}
impl OtherPlayerEnterHomeNotifyReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonInvalid => "OtherPlayerEnterHomeNotifyReason_REASON_INVALID",
            Self::ReasonEnter => "OtherPlayerEnterHomeNotifyReason_REASON_ENTER",
            Self::ReasonLeave => "OtherPlayerEnterHomeNotifyReason_REASON_LEAVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OtherPlayerEnterHomeNotifyReason_REASON_INVALID" => {
                Some(Self::ReasonInvalid)
            }
            "OtherPlayerEnterHomeNotifyReason_REASON_ENTER" => Some(Self::ReasonEnter),
            "OtherPlayerEnterHomeNotifyReason_REASON_LEAVE" => Some(Self::ReasonLeave),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerApplyCreateBlueprintResultNotifyReason {
    ReasonPlayerJudge = 0,
    ReasonPlayerEnterOptionRefuse = 1,
    ReasonPlayerEnterOptionDirect = 2,
    ReasonSystemJudge = 3,
    ReasonHostInMatch = 4,
    ReasonPsPlayerNotAcceptOthers = 5,
    ReasonOpenStateNotOpen = 6,
    ReasonHostInEditMode = 7,
    ReasonPriorCheck = 8,
    ReasonPlayerOffline = 9,
}
impl PlayerApplyCreateBlueprintResultNotifyReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonPlayerJudge => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_JUDGE"
            }
            Self::ReasonPlayerEnterOptionRefuse => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_ENTER_OPTION_REFUSE"
            }
            Self::ReasonPlayerEnterOptionDirect => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_ENTER_OPTION_DIRECT"
            }
            Self::ReasonSystemJudge => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_SYSTEM_JUDGE"
            }
            Self::ReasonHostInMatch => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_HOST_IN_MATCH"
            }
            Self::ReasonPsPlayerNotAcceptOthers => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PS_PLAYER_NOT_ACCEPT_OTHERS"
            }
            Self::ReasonOpenStateNotOpen => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_OPEN_STATE_NOT_OPEN"
            }
            Self::ReasonHostInEditMode => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_HOST_IN_EDIT_MODE"
            }
            Self::ReasonPriorCheck => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PRIOR_CHECK"
            }
            Self::ReasonPlayerOffline => {
                "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_OFFLINE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_JUDGE" => {
                Some(Self::ReasonPlayerJudge)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_ENTER_OPTION_REFUSE" => {
                Some(Self::ReasonPlayerEnterOptionRefuse)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_ENTER_OPTION_DIRECT" => {
                Some(Self::ReasonPlayerEnterOptionDirect)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_SYSTEM_JUDGE" => {
                Some(Self::ReasonSystemJudge)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_HOST_IN_MATCH" => {
                Some(Self::ReasonHostInMatch)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PS_PLAYER_NOT_ACCEPT_OTHERS" => {
                Some(Self::ReasonPsPlayerNotAcceptOthers)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_OPEN_STATE_NOT_OPEN" => {
                Some(Self::ReasonOpenStateNotOpen)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_HOST_IN_EDIT_MODE" => {
                Some(Self::ReasonHostInEditMode)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PRIOR_CHECK" => {
                Some(Self::ReasonPriorCheck)
            }
            "PlayerApplyCreateBlueprintResultNotifyReason_REASON_PLAYER_OFFLINE" => {
                Some(Self::ReasonPlayerOffline)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvestigationState {
    StateInvalid = 0,
    StateInProgress = 1,
    StateComplete = 2,
    StateRewardTaken = 3,
}
impl InvestigationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StateInvalid => "InvestigationState_STATE_INVALID",
            Self::StateInProgress => "InvestigationState_STATE_IN_PROGRESS",
            Self::StateComplete => "InvestigationState_STATE_COMPLETE",
            Self::StateRewardTaken => "InvestigationState_STATE_REWARD_TAKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "InvestigationState_STATE_INVALID" => Some(Self::StateInvalid),
            "InvestigationState_STATE_IN_PROGRESS" => Some(Self::StateInProgress),
            "InvestigationState_STATE_COMPLETE" => Some(Self::StateComplete),
            "InvestigationState_STATE_REWARD_TAKEN" => Some(Self::StateRewardTaken),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvestigationTargetState {
    StateInvalid = 0,
    StateInProgress = 1,
    StateComplete = 2,
    StateRewardTaken = 3,
}
impl InvestigationTargetState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StateInvalid => "InvestigationTargetState_STATE_INVALID",
            Self::StateInProgress => "InvestigationTargetState_STATE_IN_PROGRESS",
            Self::StateComplete => "InvestigationTargetState_STATE_COMPLETE",
            Self::StateRewardTaken => "InvestigationTargetState_STATE_REWARD_TAKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "InvestigationTargetState_STATE_INVALID" => Some(Self::StateInvalid),
            "InvestigationTargetState_STATE_IN_PROGRESS" => Some(Self::StateInProgress),
            "InvestigationTargetState_STATE_COMPLETE" => Some(Self::StateComplete),
            "InvestigationTargetState_STATE_REWARD_TAKEN" => Some(Self::StateRewardTaken),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockState {
    None = 0,
    Quest = 1,
}
impl LockState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "LOCK_STATE_NONE",
            Self::Quest => "LOCK_STATE_QUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCK_STATE_NONE" => Some(Self::None),
            "LOCK_STATE_QUEST" => Some(Self::Quest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ForgeQueueManipulateType {
    ReceiveOutput = 0,
    StopForge = 1,
}
impl ForgeQueueManipulateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReceiveOutput => "FORGE_QUEUE_MANIPULATE_TYPE_RECEIVE_OUTPUT",
            Self::StopForge => "FORGE_QUEUE_MANIPULATE_TYPE_STOP_FORGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FORGE_QUEUE_MANIPULATE_TYPE_RECEIVE_OUTPUT" => Some(Self::ReceiveOutput),
            "FORGE_QUEUE_MANIPULATE_TYPE_STOP_FORGE" => Some(Self::StopForge),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MaterialDeleteReturnType {
    Bag = 0,
    Seed = 1,
}
impl MaterialDeleteReturnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Bag => "MATERIAL_DELETE_RETURN_TYPE_BAG",
            Self::Seed => "MATERIAL_DELETE_RETURN_TYPE_SEED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATERIAL_DELETE_RETURN_TYPE_BAG" => Some(Self::Bag),
            "MATERIAL_DELETE_RETURN_TYPE_SEED" => Some(Self::Seed),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemExceedLimitMsgType {
    Default = 0,
    Text = 1,
    Dialog = 2,
    DialogNonblock = 3,
}
impl ItemExceedLimitMsgType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "ITEM_EXCEED_LIMIT_MSG_TYPE_DEFAULT",
            Self::Text => "ITEM_EXCEED_LIMIT_MSG_TYPE_TEXT",
            Self::Dialog => "ITEM_EXCEED_LIMIT_MSG_TYPE_DIALOG",
            Self::DialogNonblock => "ITEM_EXCEED_LIMIT_MSG_TYPE_DIALOG_NONBLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ITEM_EXCEED_LIMIT_MSG_TYPE_DEFAULT" => Some(Self::Default),
            "ITEM_EXCEED_LIMIT_MSG_TYPE_TEXT" => Some(Self::Text),
            "ITEM_EXCEED_LIMIT_MSG_TYPE_DIALOG" => Some(Self::Dialog),
            "ITEM_EXCEED_LIMIT_MSG_TYPE_DIALOG_NONBLOCK" => Some(Self::DialogNonblock),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerMatchAgreedResultNotifyReason {
    ReasonSucc = 0,
    ReasonTargetSceneCannotEnter = 1,
    ReasonSelfMpUnavailable = 2,
    ReasonOtherDataVersionNotLatest = 3,
    ReasonDataVersionNotLatest = 4,
}
impl PlayerMatchAgreedResultNotifyReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonSucc => "PlayerMatchAgreedResultNotifyReason_REASON_SUCC",
            Self::ReasonTargetSceneCannotEnter => {
                "PlayerMatchAgreedResultNotifyReason_REASON_TARGET_SCENE_CANNOT_ENTER"
            }
            Self::ReasonSelfMpUnavailable => {
                "PlayerMatchAgreedResultNotifyReason_REASON_SELF_MP_UNAVAILABLE"
            }
            Self::ReasonOtherDataVersionNotLatest => {
                "PlayerMatchAgreedResultNotifyReason_REASON_OTHER_DATA_VERSION_NOT_LATEST"
            }
            Self::ReasonDataVersionNotLatest => {
                "PlayerMatchAgreedResultNotifyReason_REASON_DATA_VERSION_NOT_LATEST"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerMatchAgreedResultNotifyReason_REASON_SUCC" => Some(Self::ReasonSucc),
            "PlayerMatchAgreedResultNotifyReason_REASON_TARGET_SCENE_CANNOT_ENTER" => {
                Some(Self::ReasonTargetSceneCannotEnter)
            }
            "PlayerMatchAgreedResultNotifyReason_REASON_SELF_MP_UNAVAILABLE" => {
                Some(Self::ReasonSelfMpUnavailable)
            }
            "PlayerMatchAgreedResultNotifyReason_REASON_OTHER_DATA_VERSION_NOT_LATEST" => {
                Some(Self::ReasonOtherDataVersionNotLatest)
            }
            "PlayerMatchAgreedResultNotifyReason_REASON_DATA_VERSION_NOT_LATEST" => {
                Some(Self::ReasonDataVersionNotLatest)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SvrMsgId {
    Unknown = 0,
    BlockRefreshCountdown = 1,
    AvatarReviveByStatue = 2,
    DailyTaskRewardMaxNum = 3,
    RoutineTypeNotOpen = 4,
    RoutineTypeRewardMaxNum = 5,
    MechanicusCoinLimit = 6,
}
impl SvrMsgId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SVR_MSG_ID_UNKNOWN",
            Self::BlockRefreshCountdown => "SVR_MSG_ID_BLOCK_REFRESH_COUNTDOWN",
            Self::AvatarReviveByStatue => "SVR_MSG_ID_AVATAR_REVIVE_BY_STATUE",
            Self::DailyTaskRewardMaxNum => "SVR_MSG_ID_DAILY_TASK_REWARD_MAX_NUM",
            Self::RoutineTypeNotOpen => "SVR_MSG_ID_ROUTINE_TYPE_NOT_OPEN",
            Self::RoutineTypeRewardMaxNum => "SVR_MSG_ID_ROUTINE_TYPE_REWARD_MAX_NUM",
            Self::MechanicusCoinLimit => "SVR_MSG_ID_MECHANICUS_COIN_LIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SVR_MSG_ID_UNKNOWN" => Some(Self::Unknown),
            "SVR_MSG_ID_BLOCK_REFRESH_COUNTDOWN" => Some(Self::BlockRefreshCountdown),
            "SVR_MSG_ID_AVATAR_REVIVE_BY_STATUE" => Some(Self::AvatarReviveByStatue),
            "SVR_MSG_ID_DAILY_TASK_REWARD_MAX_NUM" => Some(Self::DailyTaskRewardMaxNum),
            "SVR_MSG_ID_ROUTINE_TYPE_NOT_OPEN" => Some(Self::RoutineTypeNotOpen),
            "SVR_MSG_ID_ROUTINE_TYPE_REWARD_MAX_NUM" => {
                Some(Self::RoutineTypeRewardMaxNum)
            }
            "SVR_MSG_ID_MECHANICUS_COIN_LIMIT" => Some(Self::MechanicusCoinLimit),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerLogType {
    None = 0,
    Ability = 1,
    Level = 2,
    Entity = 3,
    Lua = 4,
}
impl ServerLogType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SERVER_LOG_TYPE_NONE",
            Self::Ability => "SERVER_LOG_TYPE_ABILITY",
            Self::Level => "SERVER_LOG_TYPE_LEVEL",
            Self::Entity => "SERVER_LOG_TYPE_ENTITY",
            Self::Lua => "SERVER_LOG_TYPE_LUA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVER_LOG_TYPE_NONE" => Some(Self::None),
            "SERVER_LOG_TYPE_ABILITY" => Some(Self::Ability),
            "SERVER_LOG_TYPE_LEVEL" => Some(Self::Level),
            "SERVER_LOG_TYPE_ENTITY" => Some(Self::Entity),
            "SERVER_LOG_TYPE_LUA" => Some(Self::Lua),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerLogLevel {
    None = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
}
impl ServerLogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SERVER_LOG_LEVEL_NONE",
            Self::Debug => "SERVER_LOG_LEVEL_DEBUG",
            Self::Info => "SERVER_LOG_LEVEL_INFO",
            Self::Warning => "SERVER_LOG_LEVEL_WARNING",
            Self::Error => "SERVER_LOG_LEVEL_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVER_LOG_LEVEL_NONE" => Some(Self::None),
            "SERVER_LOG_LEVEL_DEBUG" => Some(Self::Debug),
            "SERVER_LOG_LEVEL_INFO" => Some(Self::Info),
            "SERVER_LOG_LEVEL_WARNING" => Some(Self::Warning),
            "SERVER_LOG_LEVEL_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClientReconnectReason {
    None = 0,
    QuitMp = 1,
}
impl ClientReconnectReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CLIENT_RECONNECT_REASON_NONE",
            Self::QuitMp => "CLIENT_RECONNECT_REASON_QUIT_MP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLIENT_RECONNECT_REASON_NONE" => Some(Self::None),
            "CLIENT_RECONNECT_REASON_QUIT_MP" => Some(Self::QuitMp),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerApplyEnterMpResultNotifyReason {
    ReasonPlayerJudge = 0,
    ReasonSceneCannotEnter = 1,
    ReasonPlayerCannotEnterMp = 2,
    ReasonSystemJudge = 3,
    ReasonAllowEnterPlayerFull = 4,
    ReasonWorldLevelLowerThanHost = 5,
    ReasonHostInMatch = 6,
    ReasonPlayerInBlacklist = 7,
    ReasonPsPlayerNotAcceptOthers = 8,
    ReasonHostIsBlocked = 9,
    ReasonOtherDataVersionNotLatest = 10,
    ReasonDataVersionNotLatest = 11,
    ReasonPlayerNotInPlayerWorld = 12,
    ReasonMaxPlayer = 13,
}
impl PlayerApplyEnterMpResultNotifyReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonPlayerJudge => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_JUDGE"
            }
            Self::ReasonSceneCannotEnter => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_SCENE_CANNOT_ENTER"
            }
            Self::ReasonPlayerCannotEnterMp => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_CANNOT_ENTER_MP"
            }
            Self::ReasonSystemJudge => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_SYSTEM_JUDGE"
            }
            Self::ReasonAllowEnterPlayerFull => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_ALLOW_ENTER_PLAYER_FULL"
            }
            Self::ReasonWorldLevelLowerThanHost => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_WORLD_LEVEL_LOWER_THAN_HOST"
            }
            Self::ReasonHostInMatch => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_HOST_IN_MATCH"
            }
            Self::ReasonPlayerInBlacklist => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_IN_BLACKLIST"
            }
            Self::ReasonPsPlayerNotAcceptOthers => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_PS_PLAYER_NOT_ACCEPT_OTHERS"
            }
            Self::ReasonHostIsBlocked => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_HOST_IS_BLOCKED"
            }
            Self::ReasonOtherDataVersionNotLatest => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_OTHER_DATA_VERSION_NOT_LATEST"
            }
            Self::ReasonDataVersionNotLatest => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_DATA_VERSION_NOT_LATEST"
            }
            Self::ReasonPlayerNotInPlayerWorld => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_NOT_IN_PLAYER_WORLD"
            }
            Self::ReasonMaxPlayer => {
                "PlayerApplyEnterMpResultNotifyReason_REASON_MAX_PLAYER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_JUDGE" => {
                Some(Self::ReasonPlayerJudge)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_SCENE_CANNOT_ENTER" => {
                Some(Self::ReasonSceneCannotEnter)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_CANNOT_ENTER_MP" => {
                Some(Self::ReasonPlayerCannotEnterMp)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_SYSTEM_JUDGE" => {
                Some(Self::ReasonSystemJudge)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_ALLOW_ENTER_PLAYER_FULL" => {
                Some(Self::ReasonAllowEnterPlayerFull)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_WORLD_LEVEL_LOWER_THAN_HOST" => {
                Some(Self::ReasonWorldLevelLowerThanHost)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_HOST_IN_MATCH" => {
                Some(Self::ReasonHostInMatch)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_IN_BLACKLIST" => {
                Some(Self::ReasonPlayerInBlacklist)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_PS_PLAYER_NOT_ACCEPT_OTHERS" => {
                Some(Self::ReasonPsPlayerNotAcceptOthers)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_HOST_IS_BLOCKED" => {
                Some(Self::ReasonHostIsBlocked)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_OTHER_DATA_VERSION_NOT_LATEST" => {
                Some(Self::ReasonOtherDataVersionNotLatest)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_DATA_VERSION_NOT_LATEST" => {
                Some(Self::ReasonDataVersionNotLatest)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_PLAYER_NOT_IN_PLAYER_WORLD" => {
                Some(Self::ReasonPlayerNotInPlayerWorld)
            }
            "PlayerApplyEnterMpResultNotifyReason_REASON_MAX_PLAYER" => {
                Some(Self::ReasonMaxPlayer)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerQuitFromMpNotifyQuitReason {
    QuitReasonInvalid = 0,
    QuitReasonHostNoOtherPlayer = 1,
    QuitReasonKickByHost = 2,
    QuitReasonBackToMyWorld = 3,
    QuitReasonKickByHostLogout = 4,
    QuitReasonKickByHostBlock = 5,
    QuitReasonBeBlocked = 6,
    QuitReasonKickByHostEnterHome = 7,
    QuitReasonHostSceneInvalid = 8,
    QuitReasonKickByPlay = 9,
    QuitReasonKickByIslandPartyGalleryStartFailed = 10,
}
impl PlayerQuitFromMpNotifyQuitReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::QuitReasonInvalid => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_INVALID"
            }
            Self::QuitReasonHostNoOtherPlayer => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_HOST_NO_OTHER_PLAYER"
            }
            Self::QuitReasonKickByHost => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST"
            }
            Self::QuitReasonBackToMyWorld => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_BACK_TO_MY_WORLD"
            }
            Self::QuitReasonKickByHostLogout => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST_LOGOUT"
            }
            Self::QuitReasonKickByHostBlock => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST_BLOCK"
            }
            Self::QuitReasonBeBlocked => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_BE_BLOCKED"
            }
            Self::QuitReasonKickByHostEnterHome => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST_ENTER_HOME"
            }
            Self::QuitReasonHostSceneInvalid => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_HOST_SCENE_INVALID"
            }
            Self::QuitReasonKickByPlay => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_PLAY"
            }
            Self::QuitReasonKickByIslandPartyGalleryStartFailed => {
                "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_ISLAND_PARTY_GALLERY_START_FAILED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_INVALID" => {
                Some(Self::QuitReasonInvalid)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_HOST_NO_OTHER_PLAYER" => {
                Some(Self::QuitReasonHostNoOtherPlayer)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST" => {
                Some(Self::QuitReasonKickByHost)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_BACK_TO_MY_WORLD" => {
                Some(Self::QuitReasonBackToMyWorld)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST_LOGOUT" => {
                Some(Self::QuitReasonKickByHostLogout)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST_BLOCK" => {
                Some(Self::QuitReasonKickByHostBlock)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_BE_BLOCKED" => {
                Some(Self::QuitReasonBeBlocked)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_HOST_ENTER_HOME" => {
                Some(Self::QuitReasonKickByHostEnterHome)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_HOST_SCENE_INVALID" => {
                Some(Self::QuitReasonHostSceneInvalid)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_PLAY" => {
                Some(Self::QuitReasonKickByPlay)
            }
            "PlayerQuitFromMpNotifyQuitReason_QUIT_REASON_KICK_BY_ISLAND_PARTY_GALLERY_START_FAILED" => {
                Some(Self::QuitReasonKickByIslandPartyGalleryStartFailed)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerPreEnterMpNotifyState {
    StateInvalid = 0,
    StateStart = 1,
    StateTimeout = 2,
}
impl PlayerPreEnterMpNotifyState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StateInvalid => "PlayerPreEnterMpNotifyState_STATE_INVALID",
            Self::StateStart => "PlayerPreEnterMpNotifyState_STATE_START",
            Self::StateTimeout => "PlayerPreEnterMpNotifyState_STATE_TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerPreEnterMpNotifyState_STATE_INVALID" => Some(Self::StateInvalid),
            "PlayerPreEnterMpNotifyState_STATE_START" => Some(Self::StateStart),
            "PlayerPreEnterMpNotifyState_STATE_TIMEOUT" => Some(Self::StateTimeout),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MultistagePlayType {
    Non = 0,
    Mechanicus = 1,
    FleurFair = 2,
    HideAndSeek = 3,
    BounceConjuring = 4,
    Chess = 5,
    IrodoriChess = 6,
    CharAmusement = 7,
    BrickBreaker = 8,
    CoinCollect = 9,
    LanV3Boat = 10,
    FleurFairV2Pacman = 11,
}
impl MultistagePlayType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Non => "MULTISTAGE_PLAY_TYPE_NON",
            Self::Mechanicus => "MULTISTAGE_PLAY_TYPE_MECHANICUS",
            Self::FleurFair => "MULTISTAGE_PLAY_TYPE_FLEUR_FAIR",
            Self::HideAndSeek => "MULTISTAGE_PLAY_TYPE_HIDE_AND_SEEK",
            Self::BounceConjuring => "MULTISTAGE_PLAY_TYPE_BOUNCE_CONJURING",
            Self::Chess => "MULTISTAGE_PLAY_TYPE_CHESS",
            Self::IrodoriChess => "MULTISTAGE_PLAY_TYPE_IRODORI_CHESS",
            Self::CharAmusement => "MULTISTAGE_PLAY_TYPE_CHAR_AMUSEMENT",
            Self::BrickBreaker => "MULTISTAGE_PLAY_TYPE_BRICK_BREAKER",
            Self::CoinCollect => "MULTISTAGE_PLAY_TYPE_COIN_COLLECT",
            Self::LanV3Boat => "MULTISTAGE_PLAY_TYPE_LAN_V3_BOAT",
            Self::FleurFairV2Pacman => "MULTISTAGE_PLAY_TYPE_FLEUR_FAIR_V2_PACMAN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MULTISTAGE_PLAY_TYPE_NON" => Some(Self::Non),
            "MULTISTAGE_PLAY_TYPE_MECHANICUS" => Some(Self::Mechanicus),
            "MULTISTAGE_PLAY_TYPE_FLEUR_FAIR" => Some(Self::FleurFair),
            "MULTISTAGE_PLAY_TYPE_HIDE_AND_SEEK" => Some(Self::HideAndSeek),
            "MULTISTAGE_PLAY_TYPE_BOUNCE_CONJURING" => Some(Self::BounceConjuring),
            "MULTISTAGE_PLAY_TYPE_CHESS" => Some(Self::Chess),
            "MULTISTAGE_PLAY_TYPE_IRODORI_CHESS" => Some(Self::IrodoriChess),
            "MULTISTAGE_PLAY_TYPE_CHAR_AMUSEMENT" => Some(Self::CharAmusement),
            "MULTISTAGE_PLAY_TYPE_BRICK_BREAKER" => Some(Self::BrickBreaker),
            "MULTISTAGE_PLAY_TYPE_COIN_COLLECT" => Some(Self::CoinCollect),
            "MULTISTAGE_PLAY_TYPE_LAN_V3_BOAT" => Some(Self::LanV3Boat),
            "MULTISTAGE_PLAY_TYPE_FLEUR_FAIR_V2_PACMAN" => Some(Self::FleurFairV2Pacman),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InBattleMechanicusStageType {
    None = 0,
    Build = 1,
    CardFlip = 2,
    Kill = 3,
}
impl InBattleMechanicusStageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "IN_BATTLE_MECHANICUS_STAGE_TYPE_NONE",
            Self::Build => "IN_BATTLE_MECHANICUS_STAGE_TYPE_BUILD",
            Self::CardFlip => "IN_BATTLE_MECHANICUS_STAGE_TYPE_CARD_FLIP",
            Self::Kill => "IN_BATTLE_MECHANICUS_STAGE_TYPE_KILL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IN_BATTLE_MECHANICUS_STAGE_TYPE_NONE" => Some(Self::None),
            "IN_BATTLE_MECHANICUS_STAGE_TYPE_BUILD" => Some(Self::Build),
            "IN_BATTLE_MECHANICUS_STAGE_TYPE_CARD_FLIP" => Some(Self::CardFlip),
            "IN_BATTLE_MECHANICUS_STAGE_TYPE_KILL" => Some(Self::Kill),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InBattleMechanicusCardChallengeState {
    None = 0,
    OnGoing = 1,
    Fail = 2,
    Success = 3,
}
impl InBattleMechanicusCardChallengeState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_NONE",
            Self::OnGoing => "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_ON_GOING",
            Self::Fail => "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_FAIL",
            Self::Success => "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_SUCCESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_NONE" => Some(Self::None),
            "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_ON_GOING" => Some(Self::OnGoing),
            "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_FAIL" => Some(Self::Fail),
            "IN_BATTLE_MECHANICUS_CARD_CHALLENGE_STATE_SUCCESS" => Some(Self::Success),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HideAndSeekStageType {
    Prepare = 0,
    Pick = 1,
    Game = 2,
    Hide = 3,
    Seek = 4,
    Settle = 5,
}
impl HideAndSeekStageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Prepare => "HIDE_AND_SEEK_STAGE_TYPE_PREPARE",
            Self::Pick => "HIDE_AND_SEEK_STAGE_TYPE_PICK",
            Self::Game => "HIDE_AND_SEEK_STAGE_TYPE_GAME",
            Self::Hide => "HIDE_AND_SEEK_STAGE_TYPE_HIDE",
            Self::Seek => "HIDE_AND_SEEK_STAGE_TYPE_SEEK",
            Self::Settle => "HIDE_AND_SEEK_STAGE_TYPE_SETTLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HIDE_AND_SEEK_STAGE_TYPE_PREPARE" => Some(Self::Prepare),
            "HIDE_AND_SEEK_STAGE_TYPE_PICK" => Some(Self::Pick),
            "HIDE_AND_SEEK_STAGE_TYPE_GAME" => Some(Self::Game),
            "HIDE_AND_SEEK_STAGE_TYPE_HIDE" => Some(Self::Hide),
            "HIDE_AND_SEEK_STAGE_TYPE_SEEK" => Some(Self::Seek),
            "HIDE_AND_SEEK_STAGE_TYPE_SETTLE" => Some(Self::Settle),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BrickBreakerStageType {
    Prepare = 0,
    Pick = 1,
    Game = 2,
    Play = 3,
    Settle = 4,
}
impl BrickBreakerStageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Prepare => "BRICK_BREAKER_STAGE_TYPE_PREPARE",
            Self::Pick => "BRICK_BREAKER_STAGE_TYPE_PICK",
            Self::Game => "BRICK_BREAKER_STAGE_TYPE_GAME",
            Self::Play => "BRICK_BREAKER_STAGE_TYPE_PLAY",
            Self::Settle => "BRICK_BREAKER_STAGE_TYPE_SETTLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BRICK_BREAKER_STAGE_TYPE_PREPARE" => Some(Self::Prepare),
            "BRICK_BREAKER_STAGE_TYPE_PICK" => Some(Self::Pick),
            "BRICK_BREAKER_STAGE_TYPE_GAME" => Some(Self::Game),
            "BRICK_BREAKER_STAGE_TYPE_PLAY" => Some(Self::Play),
            "BRICK_BREAKER_STAGE_TYPE_SETTLE" => Some(Self::Settle),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HideAndSeekSettleNotifySettleReason {
    SettleReasonTimeOut = 0,
    SettleReasonPlayEnd = 1,
    SettleReasonPlayerQuit = 2,
}
impl HideAndSeekSettleNotifySettleReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettleReasonTimeOut => {
                "HideAndSeekSettleNotifySettleReason_SETTLE_REASON_TIME_OUT"
            }
            Self::SettleReasonPlayEnd => {
                "HideAndSeekSettleNotifySettleReason_SETTLE_REASON_PLAY_END"
            }
            Self::SettleReasonPlayerQuit => {
                "HideAndSeekSettleNotifySettleReason_SETTLE_REASON_PLAYER_QUIT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HideAndSeekSettleNotifySettleReason_SETTLE_REASON_TIME_OUT" => {
                Some(Self::SettleReasonTimeOut)
            }
            "HideAndSeekSettleNotifySettleReason_SETTLE_REASON_PLAY_END" => {
                Some(Self::SettleReasonPlayEnd)
            }
            "HideAndSeekSettleNotifySettleReason_SETTLE_REASON_PLAYER_QUIT" => {
                Some(Self::SettleReasonPlayerQuit)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryPathReqOptionType {
    OptionTypeNone = 0,
    OptionTypeNormal = 1,
    OptionTypeFirstCanGo = 2,
}
impl QueryPathReqOptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OptionTypeNone => "QueryPathReqOptionType_OPTION_TYPE_NONE",
            Self::OptionTypeNormal => "QueryPathReqOptionType_OPTION_TYPE_NORMAL",
            Self::OptionTypeFirstCanGo => {
                "QueryPathReqOptionType_OPTION_TYPE_FIRST_CAN_GO"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QueryPathReqOptionType_OPTION_TYPE_NONE" => Some(Self::OptionTypeNone),
            "QueryPathReqOptionType_OPTION_TYPE_NORMAL" => Some(Self::OptionTypeNormal),
            "QueryPathReqOptionType_OPTION_TYPE_FIRST_CAN_GO" => {
                Some(Self::OptionTypeFirstCanGo)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryPathRspPathStatusType {
    PathStatusTypeFail = 0,
    PathStatusTypeSucc = 1,
    PathStatusTypePartial = 2,
}
impl QueryPathRspPathStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PathStatusTypeFail => {
                "QueryPathRspPathStatusType_PATH_STATUS_TYPE_FAIL"
            }
            Self::PathStatusTypeSucc => {
                "QueryPathRspPathStatusType_PATH_STATUS_TYPE_SUCC"
            }
            Self::PathStatusTypePartial => {
                "QueryPathRspPathStatusType_PATH_STATUS_TYPE_PARTIAL"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QueryPathRspPathStatusType_PATH_STATUS_TYPE_FAIL" => {
                Some(Self::PathStatusTypeFail)
            }
            "QueryPathRspPathStatusType_PATH_STATUS_TYPE_SUCC" => {
                Some(Self::PathStatusTypeSucc)
            }
            "QueryPathRspPathStatusType_PATH_STATUS_TYPE_PARTIAL" => {
                Some(Self::PathStatusTypePartial)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ObstacleInfoShapeType {
    ShapeTypeObstacleShapeCapsule = 0,
    ShapeTypeObstacleShapeBox = 1,
}
impl ObstacleInfoShapeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ShapeTypeObstacleShapeCapsule => {
                "ObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_CAPSULE"
            }
            Self::ShapeTypeObstacleShapeBox => {
                "ObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_BOX"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_CAPSULE" => {
                Some(Self::ShapeTypeObstacleShapeCapsule)
            }
            "ObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_BOX" => {
                Some(Self::ShapeTypeObstacleShapeBox)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EdgeType {
    Inner = 0,
    TileBound = 1,
    TileBoundUnconnected = 2,
    TileBoundOverride = 3,
}
impl EdgeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Inner => "EDGE_TYPE_INNER",
            Self::TileBound => "EDGE_TYPE_TILE_BOUND",
            Self::TileBoundUnconnected => "EDGE_TYPE_TILE_BOUND_UNCONNECTED",
            Self::TileBoundOverride => "EDGE_TYPE_TILE_BOUND_OVERRIDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDGE_TYPE_INNER" => Some(Self::Inner),
            "EDGE_TYPE_TILE_BOUND" => Some(Self::TileBound),
            "EDGE_TYPE_TILE_BOUND_UNCONNECTED" => Some(Self::TileBoundUnconnected),
            "EDGE_TYPE_TILE_BOUND_OVERRIDE" => Some(Self::TileBoundOverride),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GmQueryPathRspPathStatusType {
    PathStatusTypeFail = 0,
    PathStatusTypeSucc = 1,
    PathStatusTypePartial = 2,
}
impl GmQueryPathRspPathStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PathStatusTypeFail => {
                "GMQueryPathRspPathStatusType_PATH_STATUS_TYPE_FAIL"
            }
            Self::PathStatusTypeSucc => {
                "GMQueryPathRspPathStatusType_PATH_STATUS_TYPE_SUCC"
            }
            Self::PathStatusTypePartial => {
                "GMQueryPathRspPathStatusType_PATH_STATUS_TYPE_PARTIAL"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GMQueryPathRspPathStatusType_PATH_STATUS_TYPE_FAIL" => {
                Some(Self::PathStatusTypeFail)
            }
            "GMQueryPathRspPathStatusType_PATH_STATUS_TYPE_SUCC" => {
                Some(Self::PathStatusTypeSucc)
            }
            "GMQueryPathRspPathStatusType_PATH_STATUS_TYPE_PARTIAL" => {
                Some(Self::PathStatusTypePartial)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompoundBoostTakeStatusType {
    None = 0,
    BoostOnly = 1,
    BoostAndTake = 2,
    BagFull = 3,
}
impl CompoundBoostTakeStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "COMPOUND_BOOST_TAKE_STATUS_TYPE_NONE",
            Self::BoostOnly => "COMPOUND_BOOST_TAKE_STATUS_TYPE_BOOST_ONLY",
            Self::BoostAndTake => "COMPOUND_BOOST_TAKE_STATUS_TYPE_BOOST_AND_TAKE",
            Self::BagFull => "COMPOUND_BOOST_TAKE_STATUS_TYPE_BAG_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPOUND_BOOST_TAKE_STATUS_TYPE_NONE" => Some(Self::None),
            "COMPOUND_BOOST_TAKE_STATUS_TYPE_BOOST_ONLY" => Some(Self::BoostOnly),
            "COMPOUND_BOOST_TAKE_STATUS_TYPE_BOOST_AND_TAKE" => Some(Self::BoostAndTake),
            "COMPOUND_BOOST_TAKE_STATUS_TYPE_BAG_FULL" => Some(Self::BagFull),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerLogoutReqReason {
    ReasonDisconnect = 0,
    ReasonClientReq = 1,
    ReasonTimeout = 2,
    ReasonAdminReq = 3,
    ReasonServerClose = 4,
    ReasonGmClear = 5,
    ReasonPlayerTransfer = 6,
    ReasonClientChecksumInvalid = 7,
    ReasonMuipMoveSaveWait = 8,
}
impl PlayerLogoutReqReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonDisconnect => "PlayerLogoutReqReason_REASON_DISCONNECT",
            Self::ReasonClientReq => "PlayerLogoutReqReason_REASON_CLIENT_REQ",
            Self::ReasonTimeout => "PlayerLogoutReqReason_REASON_TIMEOUT",
            Self::ReasonAdminReq => "PlayerLogoutReqReason_REASON_ADMIN_REQ",
            Self::ReasonServerClose => "PlayerLogoutReqReason_REASON_SERVER_CLOSE",
            Self::ReasonGmClear => "PlayerLogoutReqReason_REASON_GM_CLEAR",
            Self::ReasonPlayerTransfer => "PlayerLogoutReqReason_REASON_PLAYER_TRANSFER",
            Self::ReasonClientChecksumInvalid => {
                "PlayerLogoutReqReason_REASON_CLIENT_CHECKSUM_INVALID"
            }
            Self::ReasonMuipMoveSaveWait => {
                "PlayerLogoutReqReason_REASON_MUIP_MOVE_SAVE_WAIT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerLogoutReqReason_REASON_DISCONNECT" => Some(Self::ReasonDisconnect),
            "PlayerLogoutReqReason_REASON_CLIENT_REQ" => Some(Self::ReasonClientReq),
            "PlayerLogoutReqReason_REASON_TIMEOUT" => Some(Self::ReasonTimeout),
            "PlayerLogoutReqReason_REASON_ADMIN_REQ" => Some(Self::ReasonAdminReq),
            "PlayerLogoutReqReason_REASON_SERVER_CLOSE" => Some(Self::ReasonServerClose),
            "PlayerLogoutReqReason_REASON_GM_CLEAR" => Some(Self::ReasonGmClear),
            "PlayerLogoutReqReason_REASON_PLAYER_TRANSFER" => {
                Some(Self::ReasonPlayerTransfer)
            }
            "PlayerLogoutReqReason_REASON_CLIENT_CHECKSUM_INVALID" => {
                Some(Self::ReasonClientChecksumInvalid)
            }
            "PlayerLogoutReqReason_REASON_MUIP_MOVE_SAVE_WAIT" => {
                Some(Self::ReasonMuipMoveSaveWait)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataResVersionOpType {
    None = 0,
    Relogin = 1,
    MpRelogin = 2,
}
impl DataResVersionOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "DATA_RES_VERSION_OP_TYPE_NONE",
            Self::Relogin => "DATA_RES_VERSION_OP_TYPE_RELOGIN",
            Self::MpRelogin => "DATA_RES_VERSION_OP_TYPE_MP_RELOGIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_RES_VERSION_OP_TYPE_NONE" => Some(Self::None),
            "DATA_RES_VERSION_OP_TYPE_RELOGIN" => Some(Self::Relogin),
            "DATA_RES_VERSION_OP_TYPE_MP_RELOGIN" => Some(Self::MpRelogin),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FinishReason {
    Default = 0,
    Clear = 1,
    Distance = 2,
    Finish = 3,
}
impl FinishReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "FINISH_REASON_DEFAULT",
            Self::Clear => "FINISH_REASON_CLEAR",
            Self::Distance => "FINISH_REASON_DISTANCE",
            Self::Finish => "FINISH_REASON_FINISH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FINISH_REASON_DEFAULT" => Some(Self::Default),
            "FINISH_REASON_CLEAR" => Some(Self::Clear),
            "FINISH_REASON_DISTANCE" => Some(Self::Distance),
            "FINISH_REASON_FINISH" => Some(Self::Finish),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemGivingType {
    Quest = 0,
    Gadget = 1,
}
impl ItemGivingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Quest => "ITEM_GIVING_TYPE_QUEST",
            Self::Gadget => "ITEM_GIVING_TYPE_GADGET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ITEM_GIVING_TYPE_QUEST" => Some(Self::Quest),
            "ITEM_GIVING_TYPE_GADGET" => Some(Self::Gadget),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PropChangeReason {
    None = 0,
    StatueRecover = 1,
    EnergyBall = 2,
    Ability = 3,
    Levelup = 4,
    Item = 5,
    AvatarCard = 6,
    CityLevelup = 7,
    AvatarUpgrade = 8,
    AvatarPromote = 9,
    PlayerAddExp = 10,
    FinishQuest = 11,
    Gm = 12,
    ManualAdjustWorldLevel = 13,
}
impl PropChangeReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PROP_CHANGE_REASON_NONE",
            Self::StatueRecover => "PROP_CHANGE_REASON_STATUE_RECOVER",
            Self::EnergyBall => "PROP_CHANGE_REASON_ENERGY_BALL",
            Self::Ability => "PROP_CHANGE_REASON_ABILITY",
            Self::Levelup => "PROP_CHANGE_REASON_LEVELUP",
            Self::Item => "PROP_CHANGE_REASON_ITEM",
            Self::AvatarCard => "PROP_CHANGE_REASON_AVATAR_CARD",
            Self::CityLevelup => "PROP_CHANGE_REASON_CITY_LEVELUP",
            Self::AvatarUpgrade => "PROP_CHANGE_REASON_AVATAR_UPGRADE",
            Self::AvatarPromote => "PROP_CHANGE_REASON_AVATAR_PROMOTE",
            Self::PlayerAddExp => "PROP_CHANGE_REASON_PLAYER_ADD_EXP",
            Self::FinishQuest => "PROP_CHANGE_REASON_FINISH_QUEST",
            Self::Gm => "PROP_CHANGE_REASON_GM",
            Self::ManualAdjustWorldLevel => {
                "PROP_CHANGE_REASON_MANUAL_ADJUST_WORLD_LEVEL"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROP_CHANGE_REASON_NONE" => Some(Self::None),
            "PROP_CHANGE_REASON_STATUE_RECOVER" => Some(Self::StatueRecover),
            "PROP_CHANGE_REASON_ENERGY_BALL" => Some(Self::EnergyBall),
            "PROP_CHANGE_REASON_ABILITY" => Some(Self::Ability),
            "PROP_CHANGE_REASON_LEVELUP" => Some(Self::Levelup),
            "PROP_CHANGE_REASON_ITEM" => Some(Self::Item),
            "PROP_CHANGE_REASON_AVATAR_CARD" => Some(Self::AvatarCard),
            "PROP_CHANGE_REASON_CITY_LEVELUP" => Some(Self::CityLevelup),
            "PROP_CHANGE_REASON_AVATAR_UPGRADE" => Some(Self::AvatarUpgrade),
            "PROP_CHANGE_REASON_AVATAR_PROMOTE" => Some(Self::AvatarPromote),
            "PROP_CHANGE_REASON_PLAYER_ADD_EXP" => Some(Self::PlayerAddExp),
            "PROP_CHANGE_REASON_FINISH_QUEST" => Some(Self::FinishQuest),
            "PROP_CHANGE_REASON_GM" => Some(Self::Gm),
            "PROP_CHANGE_REASON_MANUAL_ADJUST_WORLD_LEVEL" => {
                Some(Self::ManualAdjustWorldLevel)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeEnergyReason {
    None = 0,
    SkillStart = 1,
}
impl ChangeEnergyReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CHANGE_ENERGY_REASON_NONE",
            Self::SkillStart => "CHANGE_ENERGY_REASON_SKILL_START",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_ENERGY_REASON_NONE" => Some(Self::None),
            "CHANGE_ENERGY_REASON_SKILL_START" => Some(Self::SkillStart),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChapterState {
    Invalid = 0,
    UnableToBegin = 1,
    Begin = 2,
    End = 3,
}
impl ChapterState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CHAPTER_STATE_INVALID",
            Self::UnableToBegin => "CHAPTER_STATE_UNABLE_TO_BEGIN",
            Self::Begin => "CHAPTER_STATE_BEGIN",
            Self::End => "CHAPTER_STATE_END",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAPTER_STATE_INVALID" => Some(Self::Invalid),
            "CHAPTER_STATE_UNABLE_TO_BEGIN" => Some(Self::UnableToBegin),
            "CHAPTER_STATE_BEGIN" => Some(Self::Begin),
            "CHAPTER_STATE_END" => Some(Self::End),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BargainResultType {
    CompleteSucc = 0,
    SingleFail = 1,
    CompleteFail = 2,
}
impl BargainResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CompleteSucc => "BARGAIN_RESULT_TYPE_COMPLETE_SUCC",
            Self::SingleFail => "BARGAIN_RESULT_TYPE_SINGLE_FAIL",
            Self::CompleteFail => "BARGAIN_RESULT_TYPE_COMPLETE_FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BARGAIN_RESULT_TYPE_COMPLETE_SUCC" => Some(Self::CompleteSucc),
            "BARGAIN_RESULT_TYPE_SINGLE_FAIL" => Some(Self::SingleFail),
            "BARGAIN_RESULT_TYPE_COMPLETE_FAIL" => Some(Self::CompleteFail),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LockReason {
    Level = 0,
    Quest = 1,
}
impl LockReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Level => "LOCK_REASON_LEVEL",
            Self::Quest => "LOCK_REASON_QUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCK_REASON_LEVEL" => Some(Self::Level),
            "LOCK_REASON_QUEST" => Some(Self::Quest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RegionEvent {
    None = 0,
    Enter = 1,
    Leave = 2,
}
impl RegionEvent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "REGION_EVENT_NONE",
            Self::Enter => "REGION_EVENT_ENTER",
            Self::Leave => "REGION_EVENT_LEAVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGION_EVENT_NONE" => Some(Self::None),
            "REGION_EVENT_ENTER" => Some(Self::Enter),
            "REGION_EVENT_LEAVE" => Some(Self::Leave),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReunionReportedType {
    ReportTypeNone = 0,
    ReportTypeStart = 1,
    ReportTypeDouble = 2,
}
impl ReunionReportedType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReportTypeNone => "REUNION_REPORTED_TYPE_REPORT_TYPE_NONE",
            Self::ReportTypeStart => "REUNION_REPORTED_TYPE_REPORT_TYPE_START",
            Self::ReportTypeDouble => "REUNION_REPORTED_TYPE_REPORT_TYPE_DOUBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REUNION_REPORTED_TYPE_REPORT_TYPE_NONE" => Some(Self::ReportTypeNone),
            "REUNION_REPORTED_TYPE_REPORT_TYPE_START" => Some(Self::ReportTypeStart),
            "REUNION_REPORTED_TYPE_REPORT_TYPE_DOUBLE" => Some(Self::ReportTypeDouble),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnterType {
    EnterNone = 0,
    EnterSelf = 1,
    EnterGoto = 2,
    EnterJump = 3,
    EnterOther = 4,
    EnterBack = 5,
    EnterDungeon = 6,
    EnterDungeonReplay = 7,
    EnterGotoByPortal = 8,
    EnterSelfHome = 9,
    EnterOtherHome = 10,
    EnterGotoRecreate = 11,
}
impl EnterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EnterNone => "ENTER_NONE",
            Self::EnterSelf => "ENTER_SELF",
            Self::EnterGoto => "ENTER_GOTO",
            Self::EnterJump => "ENTER_JUMP",
            Self::EnterOther => "ENTER_OTHER",
            Self::EnterBack => "ENTER_BACK",
            Self::EnterDungeon => "ENTER_DUNGEON",
            Self::EnterDungeonReplay => "ENTER_DUNGEON_REPLAY",
            Self::EnterGotoByPortal => "ENTER_GOTO_BY_PORTAL",
            Self::EnterSelfHome => "ENTER_SELF_HOME",
            Self::EnterOtherHome => "ENTER_OTHER_HOME",
            Self::EnterGotoRecreate => "ENTER_GOTO_RECREATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTER_NONE" => Some(Self::EnterNone),
            "ENTER_SELF" => Some(Self::EnterSelf),
            "ENTER_GOTO" => Some(Self::EnterGoto),
            "ENTER_JUMP" => Some(Self::EnterJump),
            "ENTER_OTHER" => Some(Self::EnterOther),
            "ENTER_BACK" => Some(Self::EnterBack),
            "ENTER_DUNGEON" => Some(Self::EnterDungeon),
            "ENTER_DUNGEON_REPLAY" => Some(Self::EnterDungeonReplay),
            "ENTER_GOTO_BY_PORTAL" => Some(Self::EnterGotoByPortal),
            "ENTER_SELF_HOME" => Some(Self::EnterSelfHome),
            "ENTER_OTHER_HOME" => Some(Self::EnterOtherHome),
            "ENTER_GOTO_RECREATE" => Some(Self::EnterGotoRecreate),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VisionType {
    None = 0,
    Meet = 1,
    Reborn = 2,
    Replace = 3,
    WaypointReborn = 4,
    Miss = 5,
    Die = 6,
    GatherEscape = 7,
    Refresh = 8,
    Transport = 9,
    ReplaceDie = 10,
    ReplaceNoNotify = 11,
    Born = 12,
    Pickup = 13,
    Remove = 14,
    ChangeCostume = 15,
    FishRefresh = 16,
    FishBigShock = 17,
    FishQteSucc = 18,
    CaptureDisappear = 19,
}
impl VisionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "VISION_TYPE_NONE",
            Self::Meet => "VISION_TYPE_MEET",
            Self::Reborn => "VISION_TYPE_REBORN",
            Self::Replace => "VISION_TYPE_REPLACE",
            Self::WaypointReborn => "VISION_TYPE_WAYPOINT_REBORN",
            Self::Miss => "VISION_TYPE_MISS",
            Self::Die => "VISION_TYPE_DIE",
            Self::GatherEscape => "VISION_TYPE_GATHER_ESCAPE",
            Self::Refresh => "VISION_TYPE_REFRESH",
            Self::Transport => "VISION_TYPE_TRANSPORT",
            Self::ReplaceDie => "VISION_TYPE_REPLACE_DIE",
            Self::ReplaceNoNotify => "VISION_TYPE_REPLACE_NO_NOTIFY",
            Self::Born => "VISION_TYPE_BORN",
            Self::Pickup => "VISION_TYPE_PICKUP",
            Self::Remove => "VISION_TYPE_REMOVE",
            Self::ChangeCostume => "VISION_TYPE_CHANGE_COSTUME",
            Self::FishRefresh => "VISION_TYPE_FISH_REFRESH",
            Self::FishBigShock => "VISION_TYPE_FISH_BIG_SHOCK",
            Self::FishQteSucc => "VISION_TYPE_FISH_QTE_SUCC",
            Self::CaptureDisappear => "VISION_TYPE_CAPTURE_DISAPPEAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VISION_TYPE_NONE" => Some(Self::None),
            "VISION_TYPE_MEET" => Some(Self::Meet),
            "VISION_TYPE_REBORN" => Some(Self::Reborn),
            "VISION_TYPE_REPLACE" => Some(Self::Replace),
            "VISION_TYPE_WAYPOINT_REBORN" => Some(Self::WaypointReborn),
            "VISION_TYPE_MISS" => Some(Self::Miss),
            "VISION_TYPE_DIE" => Some(Self::Die),
            "VISION_TYPE_GATHER_ESCAPE" => Some(Self::GatherEscape),
            "VISION_TYPE_REFRESH" => Some(Self::Refresh),
            "VISION_TYPE_TRANSPORT" => Some(Self::Transport),
            "VISION_TYPE_REPLACE_DIE" => Some(Self::ReplaceDie),
            "VISION_TYPE_REPLACE_NO_NOTIFY" => Some(Self::ReplaceNoNotify),
            "VISION_TYPE_BORN" => Some(Self::Born),
            "VISION_TYPE_PICKUP" => Some(Self::Pickup),
            "VISION_TYPE_REMOVE" => Some(Self::Remove),
            "VISION_TYPE_CHANGE_COSTUME" => Some(Self::ChangeCostume),
            "VISION_TYPE_FISH_REFRESH" => Some(Self::FishRefresh),
            "VISION_TYPE_FISH_BIG_SHOCK" => Some(Self::FishBigShock),
            "VISION_TYPE_FISH_QTE_SUCC" => Some(Self::FishQteSucc),
            "VISION_TYPE_CAPTURE_DISAPPEAR" => Some(Self::CaptureDisappear),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CreateReason {
    None = 0,
    Quest = 1,
    Energy = 2,
}
impl CreateReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CREATE_REASON_NONE",
            Self::Quest => "CREATE_REASON_QUEST",
            Self::Energy => "CREATE_REASON_ENERGY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREATE_REASON_NONE" => Some(Self::None),
            "CREATE_REASON_QUEST" => Some(Self::Quest),
            "CREATE_REASON_ENERGY" => Some(Self::Energy),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransmitReason {
    None = 0,
    Quest = 1,
}
impl TransmitReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "TRANSMIT_REASON_NONE",
            Self::Quest => "TRANSMIT_REASON_QUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSMIT_REASON_NONE" => Some(Self::None),
            "TRANSMIT_REASON_QUEST" => Some(Self::Quest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SealBattleType {
    KeepAlive = 0,
    KillMonster = 1,
    EnergyCharge = 2,
}
impl SealBattleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KeepAlive => "SEAL_BATTLE_TYPE_KEEP_ALIVE",
            Self::KillMonster => "SEAL_BATTLE_TYPE_KILL_MONSTER",
            Self::EnergyCharge => "SEAL_BATTLE_TYPE_ENERGY_CHARGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEAL_BATTLE_TYPE_KEEP_ALIVE" => Some(Self::KeepAlive),
            "SEAL_BATTLE_TYPE_KILL_MONSTER" => Some(Self::KillMonster),
            "SEAL_BATTLE_TYPE_ENERGY_CHARGE" => Some(Self::EnergyCharge),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DungeonEntryBlockReason {
    None = 0,
    Level = 1,
    Quest = 2,
    Muliple = 3,
}
impl DungeonEntryBlockReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "DUNGEON_ENTRY_BLOCK_REASON_NONE",
            Self::Level => "DUNGEON_ENTRY_BLOCK_REASON_LEVEL",
            Self::Quest => "DUNGEON_ENTRY_BLOCK_REASON_QUEST",
            Self::Muliple => "DUNGEON_ENTRY_BLOCK_REASON_MULIPLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUNGEON_ENTRY_BLOCK_REASON_NONE" => Some(Self::None),
            "DUNGEON_ENTRY_BLOCK_REASON_LEVEL" => Some(Self::Level),
            "DUNGEON_ENTRY_BLOCK_REASON_QUEST" => Some(Self::Quest),
            "DUNGEON_ENTRY_BLOCK_REASON_MULIPLE" => Some(Self::Muliple),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AreaPlayType {
    None = 0,
    Climate = 1,
    RegionalPlay = 2,
}
impl AreaPlayType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AREA_PLAY_TYPE_NONE",
            Self::Climate => "AREA_PLAY_TYPE_CLIMATE",
            Self::RegionalPlay => "AREA_PLAY_TYPE_REGIONAL_PLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AREA_PLAY_TYPE_NONE" => Some(Self::None),
            "AREA_PLAY_TYPE_CLIMATE" => Some(Self::Climate),
            "AREA_PLAY_TYPE_REGIONAL_PLAY" => Some(Self::RegionalPlay),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntityJumpNotifyType {
    TypeNull = 0,
    TypeActive = 1,
    TypePassive = 2,
}
impl EntityJumpNotifyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TypeNull => "EntityJumpNotifyType_TYPE_NULL",
            Self::TypeActive => "EntityJumpNotifyType_TYPE_ACTIVE",
            Self::TypePassive => "EntityJumpNotifyType_TYPE_PASSIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EntityJumpNotifyType_TYPE_NULL" => Some(Self::TypeNull),
            "EntityJumpNotifyType_TYPE_ACTIVE" => Some(Self::TypeActive),
            "EntityJumpNotifyType_TYPE_PASSIVE" => Some(Self::TypePassive),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeepRotType {
    X = 0,
    Xy = 1,
}
impl KeepRotType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::X => "KEEP_ROT_TYPE_X",
            Self::Xy => "KEEP_ROT_TYPE_XY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEEP_ROT_TYPE_X" => Some(Self::X),
            "KEEP_ROT_TYPE_XY" => Some(Self::Xy),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlaySoundType {
    None = 0,
    Start = 1,
    Stop = 2,
}
impl PlaySoundType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PLAY_SOUND_TYPE_NONE",
            Self::Start => "PLAY_SOUND_TYPE_START",
            Self::Stop => "PLAY_SOUND_TYPE_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAY_SOUND_TYPE_NONE" => Some(Self::None),
            "PLAY_SOUND_TYPE_START" => Some(Self::Start),
            "PLAY_SOUND_TYPE_STOP" => Some(Self::Stop),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operation {
    Add = 0,
    Mod = 1,
    Del = 2,
    Get = 3,
}
impl Operation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Add => "OPERATION_ADD",
            Self::Mod => "OPERATION_MOD",
            Self::Del => "OPERATION_DEL",
            Self::Get => "OPERATION_GET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATION_ADD" => Some(Self::Add),
            "OPERATION_MOD" => Some(Self::Mod),
            "OPERATION_DEL" => Some(Self::Del),
            "OPERATION_GET" => Some(Self::Get),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FollowType {
    InitFollowPos = 0,
    SetFollowPos = 1,
    SetAbsFollowPos = 2,
}
impl FollowType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InitFollowPos => "FOLLOW_TYPE_INIT_FOLLOW_POS",
            Self::SetFollowPos => "FOLLOW_TYPE_SET_FOLLOW_POS",
            Self::SetAbsFollowPos => "FOLLOW_TYPE_SET_ABS_FOLLOW_POS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FOLLOW_TYPE_INIT_FOLLOW_POS" => Some(Self::InitFollowPos),
            "FOLLOW_TYPE_SET_FOLLOW_POS" => Some(Self::SetFollowPos),
            "FOLLOW_TYPE_SET_ABS_FOLLOW_POS" => Some(Self::SetAbsFollowPos),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScenePlayBattleState {
    None = 0,
    Init = 1,
    Prepare = 2,
    Ready = 3,
    Prestart = 4,
    Start = 5,
    Stop = 6,
}
impl ScenePlayBattleState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SCENE_PLAY_BATTLE_STATE_NONE",
            Self::Init => "SCENE_PLAY_BATTLE_STATE_INIT",
            Self::Prepare => "SCENE_PLAY_BATTLE_STATE_PREPARE",
            Self::Ready => "SCENE_PLAY_BATTLE_STATE_READY",
            Self::Prestart => "SCENE_PLAY_BATTLE_STATE_PRESTART",
            Self::Start => "SCENE_PLAY_BATTLE_STATE_START",
            Self::Stop => "SCENE_PLAY_BATTLE_STATE_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCENE_PLAY_BATTLE_STATE_NONE" => Some(Self::None),
            "SCENE_PLAY_BATTLE_STATE_INIT" => Some(Self::Init),
            "SCENE_PLAY_BATTLE_STATE_PREPARE" => Some(Self::Prepare),
            "SCENE_PLAY_BATTLE_STATE_READY" => Some(Self::Ready),
            "SCENE_PLAY_BATTLE_STATE_PRESTART" => Some(Self::Prestart),
            "SCENE_PLAY_BATTLE_STATE_START" => Some(Self::Start),
            "SCENE_PLAY_BATTLE_STATE_STOP" => Some(Self::Stop),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShopGoodsDisableType {
    None = 0,
    TalentFull = 1,
    FurnitureFormulaUnlocked = 2,
    CostumeUnlocked = 3,
    BgmUnlocked = 4,
    GcgCardExceed = 5,
    GcgCardFaceUnlocked = 6,
    GcgCardBackUnlocked = 7,
    GcgFieldUnlocked = 8,
    FormulaHasLearned = 9,
    ItemReachedStackLimit = 10,
    ItemReachedGlobalOutputLimit = 11,
}
impl ShopGoodsDisableType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SHOP_GOODS_DISABLE_TYPE_NONE",
            Self::TalentFull => "SHOP_GOODS_DISABLE_TYPE_TALENT_FULL",
            Self::FurnitureFormulaUnlocked => {
                "SHOP_GOODS_DISABLE_TYPE_FURNITURE_FORMULA_UNLOCKED"
            }
            Self::CostumeUnlocked => "SHOP_GOODS_DISABLE_TYPE_COSTUME_UNLOCKED",
            Self::BgmUnlocked => "SHOP_GOODS_DISABLE_TYPE_BGM_UNLOCKED",
            Self::GcgCardExceed => "SHOP_GOODS_DISABLE_TYPE_GCG_CARD_EXCEED",
            Self::GcgCardFaceUnlocked => "SHOP_GOODS_DISABLE_TYPE_GCG_CARD_FACE_UNLOCKED",
            Self::GcgCardBackUnlocked => "SHOP_GOODS_DISABLE_TYPE_GCG_CARD_BACK_UNLOCKED",
            Self::GcgFieldUnlocked => "SHOP_GOODS_DISABLE_TYPE_GCG_FIELD_UNLOCKED",
            Self::FormulaHasLearned => "SHOP_GOODS_DISABLE_TYPE_FORMULA_HAS_LEARNED",
            Self::ItemReachedStackLimit => {
                "SHOP_GOODS_DISABLE_TYPE_ITEM_REACHED_STACK_LIMIT"
            }
            Self::ItemReachedGlobalOutputLimit => {
                "SHOP_GOODS_DISABLE_TYPE_ITEM_REACHED_GLOBAL_OUTPUT_LIMIT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHOP_GOODS_DISABLE_TYPE_NONE" => Some(Self::None),
            "SHOP_GOODS_DISABLE_TYPE_TALENT_FULL" => Some(Self::TalentFull),
            "SHOP_GOODS_DISABLE_TYPE_FURNITURE_FORMULA_UNLOCKED" => {
                Some(Self::FurnitureFormulaUnlocked)
            }
            "SHOP_GOODS_DISABLE_TYPE_COSTUME_UNLOCKED" => Some(Self::CostumeUnlocked),
            "SHOP_GOODS_DISABLE_TYPE_BGM_UNLOCKED" => Some(Self::BgmUnlocked),
            "SHOP_GOODS_DISABLE_TYPE_GCG_CARD_EXCEED" => Some(Self::GcgCardExceed),
            "SHOP_GOODS_DISABLE_TYPE_GCG_CARD_FACE_UNLOCKED" => {
                Some(Self::GcgCardFaceUnlocked)
            }
            "SHOP_GOODS_DISABLE_TYPE_GCG_CARD_BACK_UNLOCKED" => {
                Some(Self::GcgCardBackUnlocked)
            }
            "SHOP_GOODS_DISABLE_TYPE_GCG_FIELD_UNLOCKED" => Some(Self::GcgFieldUnlocked),
            "SHOP_GOODS_DISABLE_TYPE_FORMULA_HAS_LEARNED" => {
                Some(Self::FormulaHasLearned)
            }
            "SHOP_GOODS_DISABLE_TYPE_ITEM_REACHED_STACK_LIMIT" => {
                Some(Self::ItemReachedStackLimit)
            }
            "SHOP_GOODS_DISABLE_TYPE_ITEM_REACHED_GLOBAL_OUTPUT_LIMIT" => {
                Some(Self::ItemReachedGlobalOutputLimit)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FriendOnlineState {
    Disconnect = 0,
    Online = 1,
}
impl FriendOnlineState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Disconnect => "FRIEND_ONLINE_STATE_DISCONNECT",
            Self::Online => "FRIEND_ONLINE_STATE_ONLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRIEND_ONLINE_STATE_DISCONNECT" => Some(Self::Disconnect),
            "FRIEND_ONLINE_STATE_ONLINE" => Some(Self::Online),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DealAddFriendResultType {
    Reject = 0,
    Accept = 1,
}
impl DealAddFriendResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Reject => "DEAL_ADD_FRIEND_RESULT_TYPE_REJECT",
            Self::Accept => "DEAL_ADD_FRIEND_RESULT_TYPE_ACCEPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEAL_ADD_FRIEND_RESULT_TYPE_REJECT" => Some(Self::Reject),
            "DEAL_ADD_FRIEND_RESULT_TYPE_ACCEPT" => Some(Self::Accept),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FilterType {
    All = 0,
    Air = 1,
    Water = 2,
}
impl FilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::All => "FILTER_TYPE_ALL",
            Self::Air => "FILTER_TYPE_AIR",
            Self::Water => "FILTER_TYPE_WATER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILTER_TYPE_ALL" => Some(Self::All),
            "FILTER_TYPE_AIR" => Some(Self::Air),
            "FILTER_TYPE_WATER" => Some(Self::Water),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ToTheMoonQueryPathReqOptionType {
    OptionTypeNone = 0,
    OptionTypeNormal = 1,
}
impl ToTheMoonQueryPathReqOptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OptionTypeNone => "ToTheMoonQueryPathReqOptionType_OPTION_TYPE_NONE",
            Self::OptionTypeNormal => {
                "ToTheMoonQueryPathReqOptionType_OPTION_TYPE_NORMAL"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ToTheMoonQueryPathReqOptionType_OPTION_TYPE_NONE" => {
                Some(Self::OptionTypeNone)
            }
            "ToTheMoonQueryPathReqOptionType_OPTION_TYPE_NORMAL" => {
                Some(Self::OptionTypeNormal)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AStarMethod {
    Classic = 0,
    Tendency = 1,
    Adaptive = 2,
    Inflection = 3,
}
impl AStarMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Classic => "A_STAR_METHOD_CLASSIC",
            Self::Tendency => "A_STAR_METHOD_TENDENCY",
            Self::Adaptive => "A_STAR_METHOD_ADAPTIVE",
            Self::Inflection => "A_STAR_METHOD_INFLECTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "A_STAR_METHOD_CLASSIC" => Some(Self::Classic),
            "A_STAR_METHOD_TENDENCY" => Some(Self::Tendency),
            "A_STAR_METHOD_ADAPTIVE" => Some(Self::Adaptive),
            "A_STAR_METHOD_INFLECTION" => Some(Self::Inflection),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ToTheMoonQueryPathRspPathStatusType {
    PathStatusTypeFail = 0,
    PathStatusTypeSucc = 1,
    PathStatusTypePartial = 2,
}
impl ToTheMoonQueryPathRspPathStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PathStatusTypeFail => {
                "ToTheMoonQueryPathRspPathStatusType_PATH_STATUS_TYPE_FAIL"
            }
            Self::PathStatusTypeSucc => {
                "ToTheMoonQueryPathRspPathStatusType_PATH_STATUS_TYPE_SUCC"
            }
            Self::PathStatusTypePartial => {
                "ToTheMoonQueryPathRspPathStatusType_PATH_STATUS_TYPE_PARTIAL"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ToTheMoonQueryPathRspPathStatusType_PATH_STATUS_TYPE_FAIL" => {
                Some(Self::PathStatusTypeFail)
            }
            "ToTheMoonQueryPathRspPathStatusType_PATH_STATUS_TYPE_SUCC" => {
                Some(Self::PathStatusTypeSucc)
            }
            "ToTheMoonQueryPathRspPathStatusType_PATH_STATUS_TYPE_PARTIAL" => {
                Some(Self::PathStatusTypePartial)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ToTheMoonObstacleInfoShapeType {
    ShapeTypeObstacleShapeCapsule = 0,
    ShapeTypeObstacleShapeBox = 1,
}
impl ToTheMoonObstacleInfoShapeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ShapeTypeObstacleShapeCapsule => {
                "ToTheMoonObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_CAPSULE"
            }
            Self::ShapeTypeObstacleShapeBox => {
                "ToTheMoonObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_BOX"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ToTheMoonObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_CAPSULE" => {
                Some(Self::ShapeTypeObstacleShapeCapsule)
            }
            "ToTheMoonObstacleInfoShapeType_SHAPE_TYPE_OBSTACLE_SHAPE_BOX" => {
                Some(Self::ShapeTypeObstacleShapeBox)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UgcType {
    None = 0,
    MusicGame = 1,
}
impl UgcType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UGC_TYPE_NONE",
            Self::MusicGame => "UGC_TYPE_MUSIC_GAME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC_TYPE_NONE" => Some(Self::None),
            "UGC_TYPE_MUSIC_GAME" => Some(Self::MusicGame),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GetUgcType {
    None = 0,
    Mine = 1,
    Publish = 2,
}
impl GetUgcType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GET_UGC_TYPE_NONE",
            Self::Mine => "GET_UGC_TYPE_MINE",
            Self::Publish => "GET_UGC_TYPE_PUBLISH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GET_UGC_TYPE_NONE" => Some(Self::None),
            "GET_UGC_TYPE_MINE" => Some(Self::Mine),
            "GET_UGC_TYPE_PUBLISH" => Some(Self::Publish),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecordUsage {
    UgcRecordUsageNone = 0,
    UgcRecordUsageImport = 1,
    UgcRecordUsagePlay = 2,
    UgcRecordUsageTrial = 3,
    UgcRecordUsageCompare = 4,
}
impl RecordUsage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UgcRecordUsageNone => "RECORD_USAGE_UGC_RECORD_USAGE_NONE",
            Self::UgcRecordUsageImport => "RECORD_USAGE_UGC_RECORD_USAGE_IMPORT",
            Self::UgcRecordUsagePlay => "RECORD_USAGE_UGC_RECORD_USAGE_PLAY",
            Self::UgcRecordUsageTrial => "RECORD_USAGE_UGC_RECORD_USAGE_TRIAL",
            Self::UgcRecordUsageCompare => "RECORD_USAGE_UGC_RECORD_USAGE_COMPARE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECORD_USAGE_UGC_RECORD_USAGE_NONE" => Some(Self::UgcRecordUsageNone),
            "RECORD_USAGE_UGC_RECORD_USAGE_IMPORT" => Some(Self::UgcRecordUsageImport),
            "RECORD_USAGE_UGC_RECORD_USAGE_PLAY" => Some(Self::UgcRecordUsagePlay),
            "RECORD_USAGE_UGC_RECORD_USAGE_TRIAL" => Some(Self::UgcRecordUsageTrial),
            "RECORD_USAGE_UGC_RECORD_USAGE_COMPARE" => Some(Self::UgcRecordUsageCompare),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UgcDungeonSettleType {
    None = 0,
    ReachScore = 1,
    TimeUp = 2,
}
impl UgcDungeonSettleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UGC_DUNGEON_SETTLE_TYPE_NONE",
            Self::ReachScore => "UGC_DUNGEON_SETTLE_TYPE_REACH_SCORE",
            Self::TimeUp => "UGC_DUNGEON_SETTLE_TYPE_TIME_UP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC_DUNGEON_SETTLE_TYPE_NONE" => Some(Self::None),
            "UGC_DUNGEON_SETTLE_TYPE_REACH_SCORE" => Some(Self::ReachScore),
            "UGC_DUNGEON_SETTLE_TYPE_TIME_UP" => Some(Self::TimeUp),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Glnoheblmjp {
    EditUgcDungeonEdit = 0,
    EditUgcDungeonAudit = 1,
    EditUgcDungeonPublished = 2,
}
impl Glnoheblmjp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EditUgcDungeonEdit => "GLNOHEBLMJP_EDIT_UGC_DUNGEON_EDIT",
            Self::EditUgcDungeonAudit => "GLNOHEBLMJP_EDIT_UGC_DUNGEON_AUDIT",
            Self::EditUgcDungeonPublished => "GLNOHEBLMJP_EDIT_UGC_DUNGEON_PUBLISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GLNOHEBLMJP_EDIT_UGC_DUNGEON_EDIT" => Some(Self::EditUgcDungeonEdit),
            "GLNOHEBLMJP_EDIT_UGC_DUNGEON_AUDIT" => Some(Self::EditUgcDungeonAudit),
            "GLNOHEBLMJP_EDIT_UGC_DUNGEON_PUBLISHED" => {
                Some(Self::EditUgcDungeonPublished)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnterUgcDungeonType {
    None = 0,
    TrialInEditDungeon = 1,
    TrialInWorld = 2,
    Play = 3,
    Official = 4,
    ByGm = 5,
    ByEdit = 6,
    TrialOneRoom = 7,
}
impl EnterUgcDungeonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ENTER_UGC_DUNGEON_TYPE_NONE",
            Self::TrialInEditDungeon => "ENTER_UGC_DUNGEON_TYPE_TRIAL_IN_EDIT_DUNGEON",
            Self::TrialInWorld => "ENTER_UGC_DUNGEON_TYPE_TRIAL_IN_WORLD",
            Self::Play => "ENTER_UGC_DUNGEON_TYPE_PLAY",
            Self::Official => "ENTER_UGC_DUNGEON_TYPE_OFFICIAL",
            Self::ByGm => "ENTER_UGC_DUNGEON_TYPE_BY_GM",
            Self::ByEdit => "ENTER_UGC_DUNGEON_TYPE_BY_EDIT",
            Self::TrialOneRoom => "ENTER_UGC_DUNGEON_TYPE_TRIAL_ONE_ROOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTER_UGC_DUNGEON_TYPE_NONE" => Some(Self::None),
            "ENTER_UGC_DUNGEON_TYPE_TRIAL_IN_EDIT_DUNGEON" => {
                Some(Self::TrialInEditDungeon)
            }
            "ENTER_UGC_DUNGEON_TYPE_TRIAL_IN_WORLD" => Some(Self::TrialInWorld),
            "ENTER_UGC_DUNGEON_TYPE_PLAY" => Some(Self::Play),
            "ENTER_UGC_DUNGEON_TYPE_OFFICIAL" => Some(Self::Official),
            "ENTER_UGC_DUNGEON_TYPE_BY_GM" => Some(Self::ByGm),
            "ENTER_UGC_DUNGEON_TYPE_BY_EDIT" => Some(Self::ByEdit),
            "ENTER_UGC_DUNGEON_TYPE_TRIAL_ONE_ROOM" => Some(Self::TrialOneRoom),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UgcDungeonSwitchRoomInviteState {
    None = 0,
    Send = 1,
    Accept = 2,
    Refuse = 3,
}
impl UgcDungeonSwitchRoomInviteState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_NONE",
            Self::Send => "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_SEND",
            Self::Accept => "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_ACCEPT",
            Self::Refuse => "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_REFUSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_NONE" => Some(Self::None),
            "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_SEND" => Some(Self::Send),
            "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_ACCEPT" => Some(Self::Accept),
            "UGC_DUNGEON_SWITCH_ROOM_INVITE_STATE_REFUSE" => Some(Self::Refuse),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UgcDungeonImportSourceType {
    None = 0,
    Starred = 1,
    Official = 2,
    Template = 3,
}
impl UgcDungeonImportSourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UGC_DUNGEON_IMPORT_SOURCE_TYPE_NONE",
            Self::Starred => "UGC_DUNGEON_IMPORT_SOURCE_TYPE_STARRED",
            Self::Official => "UGC_DUNGEON_IMPORT_SOURCE_TYPE_OFFICIAL",
            Self::Template => "UGC_DUNGEON_IMPORT_SOURCE_TYPE_TEMPLATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC_DUNGEON_IMPORT_SOURCE_TYPE_NONE" => Some(Self::None),
            "UGC_DUNGEON_IMPORT_SOURCE_TYPE_STARRED" => Some(Self::Starred),
            "UGC_DUNGEON_IMPORT_SOURCE_TYPE_OFFICIAL" => Some(Self::Official),
            "UGC_DUNGEON_IMPORT_SOURCE_TYPE_TEMPLATE" => Some(Self::Template),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WidgetSlotTag {
    QuickUse = 0,
    AttachAvatar = 1,
}
impl WidgetSlotTag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::QuickUse => "WIDGET_SLOT_TAG_QUICK_USE",
            Self::AttachAvatar => "WIDGET_SLOT_TAG_ATTACH_AVATAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIDGET_SLOT_TAG_QUICK_USE" => Some(Self::QuickUse),
            "WIDGET_SLOT_TAG_ATTACH_AVATAR" => Some(Self::AttachAvatar),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WidgetSlotOp {
    Attach = 0,
    Detach = 1,
}
impl WidgetSlotOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Attach => "WIDGET_SLOT_OP_ATTACH",
            Self::Detach => "WIDGET_SLOT_OP_DETACH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIDGET_SLOT_OP_ATTACH" => Some(Self::Attach),
            "WIDGET_SLOT_OP_DETACH" => Some(Self::Detach),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WidgetCreatorOpType {
    None = 0,
    Retract = 1,
    RetractAndCreate = 2,
}
impl WidgetCreatorOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "WIDGET_CREATOR_OP_TYPE_NONE",
            Self::Retract => "WIDGET_CREATOR_OP_TYPE_RETRACT",
            Self::RetractAndCreate => "WIDGET_CREATOR_OP_TYPE_RETRACT_AND_CREATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIDGET_CREATOR_OP_TYPE_NONE" => Some(Self::None),
            "WIDGET_CREATOR_OP_TYPE_RETRACT" => Some(Self::Retract),
            "WIDGET_CREATOR_OP_TYPE_RETRACT_AND_CREATE" => Some(Self::RetractAndCreate),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WidgetExtraCdType {
    None = 0,
    ESkillShared = 1,
}
impl WidgetExtraCdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "WIDGET_EXTRA_CD_TYPE_NONE",
            Self::ESkillShared => "WIDGET_EXTRA_CD_TYPE_E_SKILL_SHARED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIDGET_EXTRA_CD_TYPE_NONE" => Some(Self::None),
            "WIDGET_EXTRA_CD_TYPE_E_SKILL_SHARED" => Some(Self::ESkillShared),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FireworksReformParamType {
    None = 0,
    Color = 1,
    Height = 2,
    Size = 3,
    Density = 4,
    Rotation = 5,
}
impl FireworksReformParamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FIREWORKS_REFORM_PARAM_TYPE_NONE",
            Self::Color => "FIREWORKS_REFORM_PARAM_TYPE_COLOR",
            Self::Height => "FIREWORKS_REFORM_PARAM_TYPE_HEIGHT",
            Self::Size => "FIREWORKS_REFORM_PARAM_TYPE_SIZE",
            Self::Density => "FIREWORKS_REFORM_PARAM_TYPE_DENSITY",
            Self::Rotation => "FIREWORKS_REFORM_PARAM_TYPE_ROTATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIREWORKS_REFORM_PARAM_TYPE_NONE" => Some(Self::None),
            "FIREWORKS_REFORM_PARAM_TYPE_COLOR" => Some(Self::Color),
            "FIREWORKS_REFORM_PARAM_TYPE_HEIGHT" => Some(Self::Height),
            "FIREWORKS_REFORM_PARAM_TYPE_SIZE" => Some(Self::Size),
            "FIREWORKS_REFORM_PARAM_TYPE_DENSITY" => Some(Self::Density),
            "FIREWORKS_REFORM_PARAM_TYPE_ROTATION" => Some(Self::Rotation),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FireworksLaunchParamType {
    None = 0,
    Repeat = 1,
    Interval = 2,
    Delay = 3,
    RoundInterval = 4,
    Max = 5,
}
impl FireworksLaunchParamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FIREWORKS_LAUNCH_PARAM_TYPE_NONE",
            Self::Repeat => "FIREWORKS_LAUNCH_PARAM_TYPE_REPEAT",
            Self::Interval => "FIREWORKS_LAUNCH_PARAM_TYPE_INTERVAL",
            Self::Delay => "FIREWORKS_LAUNCH_PARAM_TYPE_DELAY",
            Self::RoundInterval => "FIREWORKS_LAUNCH_PARAM_TYPE_ROUND_INTERVAL",
            Self::Max => "FIREWORKS_LAUNCH_PARAM_TYPE_MAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIREWORKS_LAUNCH_PARAM_TYPE_NONE" => Some(Self::None),
            "FIREWORKS_LAUNCH_PARAM_TYPE_REPEAT" => Some(Self::Repeat),
            "FIREWORKS_LAUNCH_PARAM_TYPE_INTERVAL" => Some(Self::Interval),
            "FIREWORKS_LAUNCH_PARAM_TYPE_DELAY" => Some(Self::Delay),
            "FIREWORKS_LAUNCH_PARAM_TYPE_ROUND_INTERVAL" => Some(Self::RoundInterval),
            "FIREWORKS_LAUNCH_PARAM_TYPE_MAX" => Some(Self::Max),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ENetReason {
    EnetTimeout = 0,
    EnetClientClose = 1,
    EnetClientRebindFail = 2,
    EnetClientShutdown = 3,
    EnetServerRelogin = 4,
    EnetServerKick = 5,
    EnetServerShutdown = 6,
    EnetNotFoundSession = 7,
    EnetLoginUnfinished = 8,
    EnetPacketFreqTooHigh = 9,
    EnetPingTimeout = 10,
    EnetTransferFailed = 11,
    EnetServerKillClient = 12,
    EnetCheckMoveSpeed = 13,
    EnetAccountPasswordChange = 14,
    EnetSecurityKick = 15,
    EnetLuaShellTimeout = 16,
    EnetSdkfailKick = 17,
    EnetPacketCostTime = 18,
    EnetPacketUnionFreq = 19,
    EnetWaitSndMax = 20,
    EnetClientConnectKey = 1234567890,
    EnetClientEditorConnectKey = 987654321,
}
impl ENetReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EnetTimeout => "ENET_TIMEOUT",
            Self::EnetClientClose => "ENET_CLIENT_CLOSE",
            Self::EnetClientRebindFail => "ENET_CLIENT_REBIND_FAIL",
            Self::EnetClientShutdown => "ENET_CLIENT_SHUTDOWN",
            Self::EnetServerRelogin => "ENET_SERVER_RELOGIN",
            Self::EnetServerKick => "ENET_SERVER_KICK",
            Self::EnetServerShutdown => "ENET_SERVER_SHUTDOWN",
            Self::EnetNotFoundSession => "ENET_NOT_FOUND_SESSION",
            Self::EnetLoginUnfinished => "ENET_LOGIN_UNFINISHED",
            Self::EnetPacketFreqTooHigh => "ENET_PACKET_FREQ_TOO_HIGH",
            Self::EnetPingTimeout => "ENET_PING_TIMEOUT",
            Self::EnetTransferFailed => "ENET_TRANSFER_FAILED",
            Self::EnetServerKillClient => "ENET_SERVER_KILL_CLIENT",
            Self::EnetCheckMoveSpeed => "ENET_CHECK_MOVE_SPEED",
            Self::EnetAccountPasswordChange => "ENET_ACCOUNT_PASSWORD_CHANGE",
            Self::EnetSecurityKick => "ENET_SECURITY_KICK",
            Self::EnetLuaShellTimeout => "ENET_LUA_SHELL_TIMEOUT",
            Self::EnetSdkfailKick => "ENET_SDKFAIL_KICK",
            Self::EnetPacketCostTime => "ENET_PACKET_COST_TIME",
            Self::EnetPacketUnionFreq => "ENET_PACKET_UNION_FREQ",
            Self::EnetWaitSndMax => "ENET_WAIT_SND_MAX",
            Self::EnetClientConnectKey => "ENET_CLIENT_CONNECT_KEY",
            Self::EnetClientEditorConnectKey => "ENET_CLIENT_EDITOR_CONNECT_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENET_TIMEOUT" => Some(Self::EnetTimeout),
            "ENET_CLIENT_CLOSE" => Some(Self::EnetClientClose),
            "ENET_CLIENT_REBIND_FAIL" => Some(Self::EnetClientRebindFail),
            "ENET_CLIENT_SHUTDOWN" => Some(Self::EnetClientShutdown),
            "ENET_SERVER_RELOGIN" => Some(Self::EnetServerRelogin),
            "ENET_SERVER_KICK" => Some(Self::EnetServerKick),
            "ENET_SERVER_SHUTDOWN" => Some(Self::EnetServerShutdown),
            "ENET_NOT_FOUND_SESSION" => Some(Self::EnetNotFoundSession),
            "ENET_LOGIN_UNFINISHED" => Some(Self::EnetLoginUnfinished),
            "ENET_PACKET_FREQ_TOO_HIGH" => Some(Self::EnetPacketFreqTooHigh),
            "ENET_PING_TIMEOUT" => Some(Self::EnetPingTimeout),
            "ENET_TRANSFER_FAILED" => Some(Self::EnetTransferFailed),
            "ENET_SERVER_KILL_CLIENT" => Some(Self::EnetServerKillClient),
            "ENET_CHECK_MOVE_SPEED" => Some(Self::EnetCheckMoveSpeed),
            "ENET_ACCOUNT_PASSWORD_CHANGE" => Some(Self::EnetAccountPasswordChange),
            "ENET_SECURITY_KICK" => Some(Self::EnetSecurityKick),
            "ENET_LUA_SHELL_TIMEOUT" => Some(Self::EnetLuaShellTimeout),
            "ENET_SDKFAIL_KICK" => Some(Self::EnetSdkfailKick),
            "ENET_PACKET_COST_TIME" => Some(Self::EnetPacketCostTime),
            "ENET_PACKET_UNION_FREQ" => Some(Self::EnetPacketUnionFreq),
            "ENET_WAIT_SND_MAX" => Some(Self::EnetWaitSndMax),
            "ENET_CLIENT_CONNECT_KEY" => Some(Self::EnetClientConnectKey),
            "ENET_CLIENT_EDITOR_CONNECT_KEY" => Some(Self::EnetClientEditorConnectKey),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActionReasonType {
    ActionReasonNone = 0,
    ActionReasonQuestItem = 1,
    ActionReasonQuestReward = 2,
    ActionReasonTrifle = 3,
    ActionReasonShop = 4,
    ActionReasonPlayerUpgradeReward = 5,
    ActionReasonAddAvatar = 6,
    ActionReasonGadgetEnvAnimal = 7,
    ActionReasonMonsterEnvAnimal = 8,
    ActionReasonCompound = 9,
    ActionReasonCook = 10,
    ActionReasonGather = 11,
    ActionReasonMailAttachment = 12,
    ActionReasonCityLevelupReturn = 15,
    ActionReasonCityLevelupReward = 17,
    ActionReasonAreaExploreReward = 18,
    ActionReasonUnlockPointReward = 19,
    ActionReasonDungeonFirstPass = 20,
    ActionReasonDungeonPass = 21,
    ActionReasonChangeElemType = 23,
    ActionReasonFetterOpen = 25,
    ActionReasonDailyTaskScore = 26,
    ActionReasonDailyTaskHost = 27,
    ActionReasonRandTaskHost = 28,
    ActionReasonExpedition = 29,
    ActionReasonGacha = 30,
    ActionReasonCombine = 31,
    ActionReasonRandTaskGuest = 32,
    ActionReasonDailyTaskGuest = 33,
    ActionReasonForgeOutput = 34,
    ActionReasonForgeReturn = 35,
    ActionReasonInitAvatar = 36,
    ActionReasonMonsterDie = 37,
    ActionReasonGm = 38,
    ActionReasonOpenChest = 39,
    ActionReasonGadgetDie = 40,
    ActionReasonMonsterChangeHp = 41,
    ActionReasonSubfieldDrop = 42,
    ActionReasonPushTipsReward = 43,
    ActionReasonActivityMonsterDrop = 44,
    ActionReasonActivityGather = 45,
    ActionReasonActivitySubfieldDrop = 46,
    ActionReasonTowerScheduleReward = 47,
    ActionReasonTowerFloorStarReward = 48,
    ActionReasonTowerFirstPassReward = 49,
    ActionReasonTowerDailyReward = 50,
    ActionReasonHitClientTrivialEntity = 51,
    ActionReasonOpenWorldBossChest = 52,
    ActionReasonMaterialDeleteReturn = 53,
    ActionReasonSignInReward = 54,
    ActionReasonOpenBlossomChest = 55,
    ActionReasonRecharge = 56,
    ActionReasonBonusActivityReward = 57,
    ActionReasonTowerCommemorativeReward = 58,
    ActionReasonTowerSkipFloorReward = 59,
    ActionReasonRechargeBonus = 60,
    ActionReasonRechargeCard = 61,
    ActionReasonRechargeCardDaily = 62,
    ActionReasonRechargeCardReplace = 63,
    ActionReasonRechargeCardReplaceFree = 64,
    ActionReasonRechargePlayReplace = 65,
    ActionReasonMpPlayTakeReward = 66,
    ActionReasonActivityWatcher = 67,
    ActionReasonSalesmanDeliverItem = 68,
    ActionReasonSalesmanReward = 69,
    ActionReasonRebate = 70,
    ActionReasonMcoinExchangeHcoin = 71,
    ActionReasonDailyTaskExchangeLegendaryKey = 72,
    ActionReasonUnlockPersonLine = 73,
    ActionReasonFetterLevelReward = 74,
    ActionReasonBuyResin = 75,
    ActionReasonRechargePackage = 76,
    ActionReasonDeliveryDailyReward = 77,
    ActionReasonCityReputationLevel = 78,
    ActionReasonCityReputationQuest = 79,
    ActionReasonCityReputationRequest = 80,
    ActionReasonCityReputationExplore = 81,
    ActionReasonOfferingLevel = 82,
    ActionReasonRoutineHost = 83,
    ActionReasonRoutineGuest = 84,
    ActionReasonTreasureMapSpotToken = 89,
    ActionReasonTreasureMapBonusLevelReward = 90,
    ActionReasonTreasureMapMpReward = 91,
    ActionReasonConvert = 92,
    ActionReasonOverflowTransform = 93,
    ActionReasonActivityAvatarSelectionReward = 96,
    ActionReasonActivityWatcherBatch = 97,
    ActionReasonHitTreeDrop = 98,
    ActionReasonGetHomeLevelupReward = 99,
    ActionReasonHomeDefaultFurniture = 100,
    ActionReasonActivityCond = 101,
    ActionReasonBattlePassNotify = 102,
    ActionReasonReliquaryDecompose = 103,
    ActionReasonRechargeGoogleGiftGard = 104,
    ActionReasonRechargeConcertProduct = 105,
    ActionReasonRechargeConcertProductReplace = 106,
    ActionReasonSendConcertProductByMuip = 107,
    ActionReasonRechargeAppleGiftGard = 108,
    ActionReasonRechargePsnCompensationProduct = 109,
    ActionReasonCompoundBoost = 110,
    ActionReasonWoodExchange = 111,
    ActionReasonAvatarRenameAuditFailed = 112,
    ActionReasonAvatarRenameReset = 113,
    ActionReasonPlayerUseItem = 1001,
    ActionReasonDropItem = 1002,
    ActionReasonWeaponUpgrade = 1011,
    ActionReasonWeaponPromote = 1012,
    ActionReasonWeaponAwaken = 1013,
    ActionReasonRelicUpgrade = 1014,
    ActionReasonAbility = 1015,
    ActionReasonDungeonStatueDrop = 1016,
    ActionReasonOfflineMsg = 1017,
    ActionReasonAvatarUpgrade = 1018,
    ActionReasonAvatarPromote = 1019,
    ActionReasonQuestAction = 1021,
    ActionReasonCityLevelup = 1022,
    ActionReasonUpgradeSkill = 1024,
    ActionReasonUnlockTalent = 1025,
    ActionReasonUpgradeProudSkill = 1026,
    ActionReasonPlayerLevelLimitUp = 1027,
    ActionReasonDungeonDaily = 1028,
    ActionReasonItemGiving = 1030,
    ActionReasonForgeCost = 1031,
    ActionReasonInvestigationReward = 1032,
    ActionReasonInvestigationTargetReward = 1033,
    ActionReasonGadgetInteract = 1034,
    ActionReasonSeaLampCiMaterial = 1036,
    ActionReasonSeaLampContributionReward = 1037,
    ActionReasonSeaLampPhaseReward = 1038,
    ActionReasonSeaLampFlyLamp = 1039,
    ActionReasonAutoRecover = 1040,
    ActionReasonActivityExpireItem = 1041,
    ActionReasonSubCoinNegative = 1042,
    ActionReasonBargainDeduct = 1043,
    ActionReasonBattlePassPaidReward = 1044,
    ActionReasonBattlePassLevelReward = 1045,
    ActionReasonTrialAvatarActivityFirstPassReward = 1046,
    ActionReasonBuyBattlePassLevel = 1047,
    ActionReasonGrantBirthdayBenefit = 1048,
    ActionReasonAchievementReward = 1049,
    ActionReasonAchievementGoalReward = 1050,
    ActionReasonFirstShareToSocialNetwork = 1051,
    ActionReasonDestroyMaterial = 1052,
    ActionReasonCodexLevelupReward = 1053,
    ActionReasonHuntingOfferReward = 1054,
    ActionReasonUseWidgetAnchorPoint = 1055,
    ActionReasonUseWidgetBonfire = 1056,
    ActionReasonUngradeWeaponReturnMaterial = 1057,
    ActionReasonUseWidgetOneoffGatherPointDetector = 1058,
    ActionReasonUseWidgetClientCollector = 1059,
    ActionReasonUseWidgetClientDetector = 1060,
    ActionReasonTakeGeneralReward = 1061,
    ActionReasonAsterTakeSpecialReward = 1062,
    ActionReasonRemoveCodexBook = 1063,
    ActionReasonOfferingItem = 1064,
    ActionReasonUseWidgetGadgetBuilder = 1065,
    ActionReasonEffigyFirstPassReward = 1066,
    ActionReasonEffigyReward = 1067,
    ActionReasonReunionFirstGiftReward = 1068,
    ActionReasonReunionSignInReward = 1069,
    ActionReasonReunionWatcherReward = 1070,
    ActionReasonSalesmanMpReward = 1071,
    ActionReasonAvatarPromoteReward = 1072,
    ActionReasonBlessingRedeemReward = 1073,
    ActionReasonMiracleRingReward = 1074,
    ActionReasonExpeditionReward = 1075,
    ActionReasonTreasureMapRemoveDetector = 1076,
    ActionReasonMechanicusDungeonTicket = 1077,
    ActionReasonMechanicusLevelupGear = 1078,
    ActionReasonMechanicusBattleSettle = 1079,
    ActionReasonRegionSearchReward = 1080,
    ActionReasonUnlockCoopChapter = 1081,
    ActionReasonTakeCoopReward = 1082,
    ActionReasonFleurFairDungeonReward = 1083,
    ActionReasonActivityScore = 1084,
    ActionReasonChannellerSlabOneoffDungeonReward = 1085,
    ActionReasonFurnitureMakeStart = 1086,
    ActionReasonFurnitureMakeTake = 1087,
    ActionReasonFurnitureMakeCancel = 1088,
    ActionReasonFurnitureMakeFastFinish = 1089,
    ActionReasonChannellerSlabLoopDungeonFirstPassReward = 1090,
    ActionReasonChannellerSlabLoopDungeonScoreReward = 1091,
    ActionReasonHomeLimitedShopBuy = 1092,
    ActionReasonHomeCoinCollect = 1093,
    ActionReasonSummerTimeSentryTowerReward = 1094,
    ActionReasonSummerTimeSprintBoatReward = 1095,
    ActionReasonSummerTimeBossReward = 1096,
    ActionReasonSummerTimeBombReward = 1097,
    ActionReasonHomeFetterCollect = 1098,
    ActionReasonEchoShellReward = 1099,
    ActionReasonHomeEventReward = 1100,
    ActionReasonBlitzRushDungeonReward = 1101,
    ActionReasonFurnitureMakeReturn = 1102,
    ActionReasonHomePlantBoxGather = 1103,
    ActionReasonHomePlantSeed = 1104,
    ActionReasonHomePlantGather = 1105,
    ActionReasonChessDungeonReward = 1106,
    ActionReasonGroupLinkBundleFinish = 1107,
    ActionReasonLunaRiteSacrifice = 1108,
    ActionReasonLunaRiteTakeSacrificeReward = 1109,
    ActionReasonFishBite = 1110,
    ActionReasonFishSucc = 1111,
    ActionReasonPlantFlowerReward = 1112,
    ActionReasonPlantFlowerDeliverItem = 1113,
    ActionReasonPlantFlowerGiveFlower = 1114,
    ActionReasonPlantFlowerRecvFlower = 1115,
    ActionReasonRogueChallengeSettle = 1116,
    ActionReasonRogueTakeFirstPassReward = 1117,
    ActionReasonRogueUpgradeShikigami = 1118,
    ActionReasonRogueRefreshCard = 1119,
    ActionReasonUseWidgetCaptureAnimal = 1120,
    ActionReasonCaptureAnimalSucc = 1121,
    ActionReasonSnowDrifts = 1122,
    ActionReasonWinterCampGiveItem = 1123,
    ActionReasonWinterCampRecvItem = 1124,
    ActionReasonWinterCampExploreReward = 1125,
    ActionReasonWinterCampBattleReward = 1126,
    ActionReasonLanternRiteSkinReward = 1127,
    ActionReasonLanternRiteDungeonReward = 1128,
    ActionReasonMichiaeMatsuriDarkChallengeReward = 1129,
    ActionReasonMichiaeMatsuriUnlockCrystalSkill = 1130,
    ActionReasonLanternRiteGroupReward = 1131,
    ActionReasonCostumeDefaultUnlock = 1132,
    ActionReasonSpiceActivityMakeSpice = 1133,
    ActionReasonSpiceActivityProcessFood = 1134,
    ActionReasonSpiceAddAvatarFetter = 1135,
    ActionReasonGachaActivityRobotReward = 1136,
    ActionReasonGivingTakeBack = 1137,
    ActionReasonSummerTimeV2DungeonReward = 1138,
    ActionReasonGravenInnocenceCampReward = 1139,
    ActionReasonTreasureSeelieChestReward = 1140,
    ActionReasonGcgTavernChallengeUnlockCharacter = 1141,
    ActionReasonGcgLevelReward = 1143,
    ActionReasonGcgChallengeFinish = 1144,
    ActionReasonVintageMarketDeal = 1145,
    ActionReasonVintageMarketBargain = 1146,
    ActionReasonVintageMarketStore = 1147,
    ActionReasonVintagePresent = 1148,
    ActionReasonVintageOpenStore = 1149,
    ActionReasonVintageStoreUnlockSlot = 1150,
    ActionReasonVintageStoreNpcEvent = 1151,
    ActionReasonRockBoardExploreReward = 1152,
    ActionReasonVintageStoreDividend = 1153,
    ActionReasonAvatarRename = 1154,
    ActionReasonGcgFinishLevelQuest = 1155,
    ActionReasonGcgProficiencyReward = 1156,
    ActionReasonTeamChainCostumeReward = 1157,
    ActionReasonOfferingPariFinishReward = 1158,
}
impl ActionReasonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ActionReasonNone => "ACTION_REASON_NONE",
            Self::ActionReasonQuestItem => "ACTION_REASON_QUEST_ITEM",
            Self::ActionReasonQuestReward => "ACTION_REASON_QUEST_REWARD",
            Self::ActionReasonTrifle => "ACTION_REASON_TRIFLE",
            Self::ActionReasonShop => "ACTION_REASON_SHOP",
            Self::ActionReasonPlayerUpgradeReward => {
                "ACTION_REASON_PLAYER_UPGRADE_REWARD"
            }
            Self::ActionReasonAddAvatar => "ACTION_REASON_ADD_AVATAR",
            Self::ActionReasonGadgetEnvAnimal => "ACTION_REASON_GADGET_ENV_ANIMAL",
            Self::ActionReasonMonsterEnvAnimal => "ACTION_REASON_MONSTER_ENV_ANIMAL",
            Self::ActionReasonCompound => "ACTION_REASON_COMPOUND",
            Self::ActionReasonCook => "ACTION_REASON_COOK",
            Self::ActionReasonGather => "ACTION_REASON_GATHER",
            Self::ActionReasonMailAttachment => "ACTION_REASON_MAIL_ATTACHMENT",
            Self::ActionReasonCityLevelupReturn => "ACTION_REASON_CITY_LEVELUP_RETURN",
            Self::ActionReasonCityLevelupReward => "ACTION_REASON_CITY_LEVELUP_REWARD",
            Self::ActionReasonAreaExploreReward => "ACTION_REASON_AREA_EXPLORE_REWARD",
            Self::ActionReasonUnlockPointReward => "ACTION_REASON_UNLOCK_POINT_REWARD",
            Self::ActionReasonDungeonFirstPass => "ACTION_REASON_DUNGEON_FIRST_PASS",
            Self::ActionReasonDungeonPass => "ACTION_REASON_DUNGEON_PASS",
            Self::ActionReasonChangeElemType => "ACTION_REASON_CHANGE_ELEM_TYPE",
            Self::ActionReasonFetterOpen => "ACTION_REASON_FETTER_OPEN",
            Self::ActionReasonDailyTaskScore => "ACTION_REASON_DAILY_TASK_SCORE",
            Self::ActionReasonDailyTaskHost => "ACTION_REASON_DAILY_TASK_HOST",
            Self::ActionReasonRandTaskHost => "ACTION_REASON_RAND_TASK_HOST",
            Self::ActionReasonExpedition => "ACTION_REASON_EXPEDITION",
            Self::ActionReasonGacha => "ACTION_REASON_GACHA",
            Self::ActionReasonCombine => "ACTION_REASON_COMBINE",
            Self::ActionReasonRandTaskGuest => "ACTION_REASON_RAND_TASK_GUEST",
            Self::ActionReasonDailyTaskGuest => "ACTION_REASON_DAILY_TASK_GUEST",
            Self::ActionReasonForgeOutput => "ACTION_REASON_FORGE_OUTPUT",
            Self::ActionReasonForgeReturn => "ACTION_REASON_FORGE_RETURN",
            Self::ActionReasonInitAvatar => "ACTION_REASON_INIT_AVATAR",
            Self::ActionReasonMonsterDie => "ACTION_REASON_MONSTER_DIE",
            Self::ActionReasonGm => "ACTION_REASON_GM",
            Self::ActionReasonOpenChest => "ACTION_REASON_OPEN_CHEST",
            Self::ActionReasonGadgetDie => "ACTION_REASON_GADGET_DIE",
            Self::ActionReasonMonsterChangeHp => "ACTION_REASON_MONSTER_CHANGE_HP",
            Self::ActionReasonSubfieldDrop => "ACTION_REASON_SUBFIELD_DROP",
            Self::ActionReasonPushTipsReward => "ACTION_REASON_PUSH_TIPS_REWARD",
            Self::ActionReasonActivityMonsterDrop => {
                "ACTION_REASON_ACTIVITY_MONSTER_DROP"
            }
            Self::ActionReasonActivityGather => "ACTION_REASON_ACTIVITY_GATHER",
            Self::ActionReasonActivitySubfieldDrop => {
                "ACTION_REASON_ACTIVITY_SUBFIELD_DROP"
            }
            Self::ActionReasonTowerScheduleReward => {
                "ACTION_REASON_TOWER_SCHEDULE_REWARD"
            }
            Self::ActionReasonTowerFloorStarReward => {
                "ACTION_REASON_TOWER_FLOOR_STAR_REWARD"
            }
            Self::ActionReasonTowerFirstPassReward => {
                "ACTION_REASON_TOWER_FIRST_PASS_REWARD"
            }
            Self::ActionReasonTowerDailyReward => "ACTION_REASON_TOWER_DAILY_REWARD",
            Self::ActionReasonHitClientTrivialEntity => {
                "ACTION_REASON_HIT_CLIENT_TRIVIAL_ENTITY"
            }
            Self::ActionReasonOpenWorldBossChest => "ACTION_REASON_OPEN_WORLD_BOSS_CHEST",
            Self::ActionReasonMaterialDeleteReturn => {
                "ACTION_REASON_MATERIAL_DELETE_RETURN"
            }
            Self::ActionReasonSignInReward => "ACTION_REASON_SIGN_IN_REWARD",
            Self::ActionReasonOpenBlossomChest => "ACTION_REASON_OPEN_BLOSSOM_CHEST",
            Self::ActionReasonRecharge => "ACTION_REASON_RECHARGE",
            Self::ActionReasonBonusActivityReward => {
                "ACTION_REASON_BONUS_ACTIVITY_REWARD"
            }
            Self::ActionReasonTowerCommemorativeReward => {
                "ACTION_REASON_TOWER_COMMEMORATIVE_REWARD"
            }
            Self::ActionReasonTowerSkipFloorReward => {
                "ACTION_REASON_TOWER_SKIP_FLOOR_REWARD"
            }
            Self::ActionReasonRechargeBonus => "ACTION_REASON_RECHARGE_BONUS",
            Self::ActionReasonRechargeCard => "ACTION_REASON_RECHARGE_CARD",
            Self::ActionReasonRechargeCardDaily => "ACTION_REASON_RECHARGE_CARD_DAILY",
            Self::ActionReasonRechargeCardReplace => {
                "ACTION_REASON_RECHARGE_CARD_REPLACE"
            }
            Self::ActionReasonRechargeCardReplaceFree => {
                "ACTION_REASON_RECHARGE_CARD_REPLACE_FREE"
            }
            Self::ActionReasonRechargePlayReplace => {
                "ACTION_REASON_RECHARGE_PLAY_REPLACE"
            }
            Self::ActionReasonMpPlayTakeReward => "ACTION_REASON_MP_PLAY_TAKE_REWARD",
            Self::ActionReasonActivityWatcher => "ACTION_REASON_ACTIVITY_WATCHER",
            Self::ActionReasonSalesmanDeliverItem => {
                "ACTION_REASON_SALESMAN_DELIVER_ITEM"
            }
            Self::ActionReasonSalesmanReward => "ACTION_REASON_SALESMAN_REWARD",
            Self::ActionReasonRebate => "ACTION_REASON_REBATE",
            Self::ActionReasonMcoinExchangeHcoin => "ACTION_REASON_MCOIN_EXCHANGE_HCOIN",
            Self::ActionReasonDailyTaskExchangeLegendaryKey => {
                "ACTION_REASON_DAILY_TASK_EXCHANGE_LEGENDARY_KEY"
            }
            Self::ActionReasonUnlockPersonLine => "ACTION_REASON_UNLOCK_PERSON_LINE",
            Self::ActionReasonFetterLevelReward => "ACTION_REASON_FETTER_LEVEL_REWARD",
            Self::ActionReasonBuyResin => "ACTION_REASON_BUY_RESIN",
            Self::ActionReasonRechargePackage => "ACTION_REASON_RECHARGE_PACKAGE",
            Self::ActionReasonDeliveryDailyReward => {
                "ACTION_REASON_DELIVERY_DAILY_REWARD"
            }
            Self::ActionReasonCityReputationLevel => {
                "ACTION_REASON_CITY_REPUTATION_LEVEL"
            }
            Self::ActionReasonCityReputationQuest => {
                "ACTION_REASON_CITY_REPUTATION_QUEST"
            }
            Self::ActionReasonCityReputationRequest => {
                "ACTION_REASON_CITY_REPUTATION_REQUEST"
            }
            Self::ActionReasonCityReputationExplore => {
                "ACTION_REASON_CITY_REPUTATION_EXPLORE"
            }
            Self::ActionReasonOfferingLevel => "ACTION_REASON_OFFERING_LEVEL",
            Self::ActionReasonRoutineHost => "ACTION_REASON_ROUTINE_HOST",
            Self::ActionReasonRoutineGuest => "ACTION_REASON_ROUTINE_GUEST",
            Self::ActionReasonTreasureMapSpotToken => {
                "ACTION_REASON_TREASURE_MAP_SPOT_TOKEN"
            }
            Self::ActionReasonTreasureMapBonusLevelReward => {
                "ACTION_REASON_TREASURE_MAP_BONUS_LEVEL_REWARD"
            }
            Self::ActionReasonTreasureMapMpReward => {
                "ACTION_REASON_TREASURE_MAP_MP_REWARD"
            }
            Self::ActionReasonConvert => "ACTION_REASON_CONVERT",
            Self::ActionReasonOverflowTransform => "ACTION_REASON_OVERFLOW_TRANSFORM",
            Self::ActionReasonActivityAvatarSelectionReward => {
                "ACTION_REASON_ACTIVITY_AVATAR_SELECTION_REWARD"
            }
            Self::ActionReasonActivityWatcherBatch => {
                "ACTION_REASON_ACTIVITY_WATCHER_BATCH"
            }
            Self::ActionReasonHitTreeDrop => "ACTION_REASON_HIT_TREE_DROP",
            Self::ActionReasonGetHomeLevelupReward => {
                "ACTION_REASON_GET_HOME_LEVELUP_REWARD"
            }
            Self::ActionReasonHomeDefaultFurniture => {
                "ACTION_REASON_HOME_DEFAULT_FURNITURE"
            }
            Self::ActionReasonActivityCond => "ACTION_REASON_ACTIVITY_COND",
            Self::ActionReasonBattlePassNotify => "ACTION_REASON_BATTLE_PASS_NOTIFY",
            Self::ActionReasonReliquaryDecompose => "ACTION_REASON_RELIQUARY_DECOMPOSE",
            Self::ActionReasonRechargeGoogleGiftGard => {
                "ACTION_REASON_RECHARGE_GOOGLE_GIFT_GARD"
            }
            Self::ActionReasonRechargeConcertProduct => {
                "ACTION_REASON_RECHARGE_CONCERT_PRODUCT"
            }
            Self::ActionReasonRechargeConcertProductReplace => {
                "ACTION_REASON_RECHARGE_CONCERT_PRODUCT_REPLACE"
            }
            Self::ActionReasonSendConcertProductByMuip => {
                "ACTION_REASON_SEND_CONCERT_PRODUCT_BY_MUIP"
            }
            Self::ActionReasonRechargeAppleGiftGard => {
                "ACTION_REASON_RECHARGE_APPLE_GIFT_GARD"
            }
            Self::ActionReasonRechargePsnCompensationProduct => {
                "ACTION_REASON_RECHARGE_PSN_COMPENSATION_PRODUCT"
            }
            Self::ActionReasonCompoundBoost => "ACTION_REASON_COMPOUND_BOOST",
            Self::ActionReasonWoodExchange => "ACTION_REASON_WOOD_EXCHANGE",
            Self::ActionReasonAvatarRenameAuditFailed => {
                "ACTION_REASON_AVATAR_RENAME_AUDIT_FAILED"
            }
            Self::ActionReasonAvatarRenameReset => "ACTION_REASON_AVATAR_RENAME_RESET",
            Self::ActionReasonPlayerUseItem => "ACTION_REASON_PLAYER_USE_ITEM",
            Self::ActionReasonDropItem => "ACTION_REASON_DROP_ITEM",
            Self::ActionReasonWeaponUpgrade => "ACTION_REASON_WEAPON_UPGRADE",
            Self::ActionReasonWeaponPromote => "ACTION_REASON_WEAPON_PROMOTE",
            Self::ActionReasonWeaponAwaken => "ACTION_REASON_WEAPON_AWAKEN",
            Self::ActionReasonRelicUpgrade => "ACTION_REASON_RELIC_UPGRADE",
            Self::ActionReasonAbility => "ACTION_REASON_ABILITY",
            Self::ActionReasonDungeonStatueDrop => "ACTION_REASON_DUNGEON_STATUE_DROP",
            Self::ActionReasonOfflineMsg => "ACTION_REASON_OFFLINE_MSG",
            Self::ActionReasonAvatarUpgrade => "ACTION_REASON_AVATAR_UPGRADE",
            Self::ActionReasonAvatarPromote => "ACTION_REASON_AVATAR_PROMOTE",
            Self::ActionReasonQuestAction => "ACTION_REASON_QUEST_ACTION",
            Self::ActionReasonCityLevelup => "ACTION_REASON_CITY_LEVELUP",
            Self::ActionReasonUpgradeSkill => "ACTION_REASON_UPGRADE_SKILL",
            Self::ActionReasonUnlockTalent => "ACTION_REASON_UNLOCK_TALENT",
            Self::ActionReasonUpgradeProudSkill => "ACTION_REASON_UPGRADE_PROUD_SKILL",
            Self::ActionReasonPlayerLevelLimitUp => "ACTION_REASON_PLAYER_LEVEL_LIMIT_UP",
            Self::ActionReasonDungeonDaily => "ACTION_REASON_DUNGEON_DAILY",
            Self::ActionReasonItemGiving => "ACTION_REASON_ITEM_GIVING",
            Self::ActionReasonForgeCost => "ACTION_REASON_FORGE_COST",
            Self::ActionReasonInvestigationReward => "ACTION_REASON_INVESTIGATION_REWARD",
            Self::ActionReasonInvestigationTargetReward => {
                "ACTION_REASON_INVESTIGATION_TARGET_REWARD"
            }
            Self::ActionReasonGadgetInteract => "ACTION_REASON_GADGET_INTERACT",
            Self::ActionReasonSeaLampCiMaterial => "ACTION_REASON_SEA_LAMP_CI_MATERIAL",
            Self::ActionReasonSeaLampContributionReward => {
                "ACTION_REASON_SEA_LAMP_CONTRIBUTION_REWARD"
            }
            Self::ActionReasonSeaLampPhaseReward => "ACTION_REASON_SEA_LAMP_PHASE_REWARD",
            Self::ActionReasonSeaLampFlyLamp => "ACTION_REASON_SEA_LAMP_FLY_LAMP",
            Self::ActionReasonAutoRecover => "ACTION_REASON_AUTO_RECOVER",
            Self::ActionReasonActivityExpireItem => "ACTION_REASON_ACTIVITY_EXPIRE_ITEM",
            Self::ActionReasonSubCoinNegative => "ACTION_REASON_SUB_COIN_NEGATIVE",
            Self::ActionReasonBargainDeduct => "ACTION_REASON_BARGAIN_DEDUCT",
            Self::ActionReasonBattlePassPaidReward => {
                "ACTION_REASON_BATTLE_PASS_PAID_REWARD"
            }
            Self::ActionReasonBattlePassLevelReward => {
                "ACTION_REASON_BATTLE_PASS_LEVEL_REWARD"
            }
            Self::ActionReasonTrialAvatarActivityFirstPassReward => {
                "ACTION_REASON_TRIAL_AVATAR_ACTIVITY_FIRST_PASS_REWARD"
            }
            Self::ActionReasonBuyBattlePassLevel => "ACTION_REASON_BUY_BATTLE_PASS_LEVEL",
            Self::ActionReasonGrantBirthdayBenefit => {
                "ACTION_REASON_GRANT_BIRTHDAY_BENEFIT"
            }
            Self::ActionReasonAchievementReward => "ACTION_REASON_ACHIEVEMENT_REWARD",
            Self::ActionReasonAchievementGoalReward => {
                "ACTION_REASON_ACHIEVEMENT_GOAL_REWARD"
            }
            Self::ActionReasonFirstShareToSocialNetwork => {
                "ACTION_REASON_FIRST_SHARE_TO_SOCIAL_NETWORK"
            }
            Self::ActionReasonDestroyMaterial => "ACTION_REASON_DESTROY_MATERIAL",
            Self::ActionReasonCodexLevelupReward => "ACTION_REASON_CODEX_LEVELUP_REWARD",
            Self::ActionReasonHuntingOfferReward => "ACTION_REASON_HUNTING_OFFER_REWARD",
            Self::ActionReasonUseWidgetAnchorPoint => {
                "ACTION_REASON_USE_WIDGET_ANCHOR_POINT"
            }
            Self::ActionReasonUseWidgetBonfire => "ACTION_REASON_USE_WIDGET_BONFIRE",
            Self::ActionReasonUngradeWeaponReturnMaterial => {
                "ACTION_REASON_UNGRADE_WEAPON_RETURN_MATERIAL"
            }
            Self::ActionReasonUseWidgetOneoffGatherPointDetector => {
                "ACTION_REASON_USE_WIDGET_ONEOFF_GATHER_POINT_DETECTOR"
            }
            Self::ActionReasonUseWidgetClientCollector => {
                "ACTION_REASON_USE_WIDGET_CLIENT_COLLECTOR"
            }
            Self::ActionReasonUseWidgetClientDetector => {
                "ACTION_REASON_USE_WIDGET_CLIENT_DETECTOR"
            }
            Self::ActionReasonTakeGeneralReward => "ACTION_REASON_TAKE_GENERAL_REWARD",
            Self::ActionReasonAsterTakeSpecialReward => {
                "ACTION_REASON_ASTER_TAKE_SPECIAL_REWARD"
            }
            Self::ActionReasonRemoveCodexBook => "ACTION_REASON_REMOVE_CODEX_BOOK",
            Self::ActionReasonOfferingItem => "ACTION_REASON_OFFERING_ITEM",
            Self::ActionReasonUseWidgetGadgetBuilder => {
                "ACTION_REASON_USE_WIDGET_GADGET_BUILDER"
            }
            Self::ActionReasonEffigyFirstPassReward => {
                "ACTION_REASON_EFFIGY_FIRST_PASS_REWARD"
            }
            Self::ActionReasonEffigyReward => "ACTION_REASON_EFFIGY_REWARD",
            Self::ActionReasonReunionFirstGiftReward => {
                "ACTION_REASON_REUNION_FIRST_GIFT_REWARD"
            }
            Self::ActionReasonReunionSignInReward => {
                "ACTION_REASON_REUNION_SIGN_IN_REWARD"
            }
            Self::ActionReasonReunionWatcherReward => {
                "ACTION_REASON_REUNION_WATCHER_REWARD"
            }
            Self::ActionReasonSalesmanMpReward => "ACTION_REASON_SALESMAN_MP_REWARD",
            Self::ActionReasonAvatarPromoteReward => {
                "ACTION_REASON_AVATAR_PROMOTE_REWARD"
            }
            Self::ActionReasonBlessingRedeemReward => {
                "ACTION_REASON_BLESSING_REDEEM_REWARD"
            }
            Self::ActionReasonMiracleRingReward => "ACTION_REASON_MIRACLE_RING_REWARD",
            Self::ActionReasonExpeditionReward => "ACTION_REASON_EXPEDITION_REWARD",
            Self::ActionReasonTreasureMapRemoveDetector => {
                "ACTION_REASON_TREASURE_MAP_REMOVE_DETECTOR"
            }
            Self::ActionReasonMechanicusDungeonTicket => {
                "ACTION_REASON_MECHANICUS_DUNGEON_TICKET"
            }
            Self::ActionReasonMechanicusLevelupGear => {
                "ACTION_REASON_MECHANICUS_LEVELUP_GEAR"
            }
            Self::ActionReasonMechanicusBattleSettle => {
                "ACTION_REASON_MECHANICUS_BATTLE_SETTLE"
            }
            Self::ActionReasonRegionSearchReward => "ACTION_REASON_REGION_SEARCH_REWARD",
            Self::ActionReasonUnlockCoopChapter => "ACTION_REASON_UNLOCK_COOP_CHAPTER",
            Self::ActionReasonTakeCoopReward => "ACTION_REASON_TAKE_COOP_REWARD",
            Self::ActionReasonFleurFairDungeonReward => {
                "ACTION_REASON_FLEUR_FAIR_DUNGEON_REWARD"
            }
            Self::ActionReasonActivityScore => "ACTION_REASON_ACTIVITY_SCORE",
            Self::ActionReasonChannellerSlabOneoffDungeonReward => {
                "ACTION_REASON_CHANNELLER_SLAB_ONEOFF_DUNGEON_REWARD"
            }
            Self::ActionReasonFurnitureMakeStart => "ACTION_REASON_FURNITURE_MAKE_START",
            Self::ActionReasonFurnitureMakeTake => "ACTION_REASON_FURNITURE_MAKE_TAKE",
            Self::ActionReasonFurnitureMakeCancel => {
                "ACTION_REASON_FURNITURE_MAKE_CANCEL"
            }
            Self::ActionReasonFurnitureMakeFastFinish => {
                "ACTION_REASON_FURNITURE_MAKE_FAST_FINISH"
            }
            Self::ActionReasonChannellerSlabLoopDungeonFirstPassReward => {
                "ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_FIRST_PASS_REWARD"
            }
            Self::ActionReasonChannellerSlabLoopDungeonScoreReward => {
                "ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_SCORE_REWARD"
            }
            Self::ActionReasonHomeLimitedShopBuy => "ACTION_REASON_HOME_LIMITED_SHOP_BUY",
            Self::ActionReasonHomeCoinCollect => "ACTION_REASON_HOME_COIN_COLLECT",
            Self::ActionReasonSummerTimeSentryTowerReward => {
                "ACTION_REASON_SUMMER_TIME_SENTRY_TOWER_REWARD"
            }
            Self::ActionReasonSummerTimeSprintBoatReward => {
                "ACTION_REASON_SUMMER_TIME_SPRINT_BOAT_REWARD"
            }
            Self::ActionReasonSummerTimeBossReward => {
                "ACTION_REASON_SUMMER_TIME_BOSS_REWARD"
            }
            Self::ActionReasonSummerTimeBombReward => {
                "ACTION_REASON_SUMMER_TIME_BOMB_REWARD"
            }
            Self::ActionReasonHomeFetterCollect => "ACTION_REASON_HOME_FETTER_COLLECT",
            Self::ActionReasonEchoShellReward => "ACTION_REASON_ECHO_SHELL_REWARD",
            Self::ActionReasonHomeEventReward => "ACTION_REASON_HOME_EVENT_REWARD",
            Self::ActionReasonBlitzRushDungeonReward => {
                "ACTION_REASON_BLITZ_RUSH_DUNGEON_REWARD"
            }
            Self::ActionReasonFurnitureMakeReturn => {
                "ACTION_REASON_FURNITURE_MAKE_RETURN"
            }
            Self::ActionReasonHomePlantBoxGather => "ACTION_REASON_HOME_PLANT_BOX_GATHER",
            Self::ActionReasonHomePlantSeed => "ACTION_REASON_HOME_PLANT_SEED",
            Self::ActionReasonHomePlantGather => "ACTION_REASON_HOME_PLANT_GATHER",
            Self::ActionReasonChessDungeonReward => "ACTION_REASON_CHESS_DUNGEON_REWARD",
            Self::ActionReasonGroupLinkBundleFinish => {
                "ACTION_REASON_GROUP_LINK_BUNDLE_FINISH"
            }
            Self::ActionReasonLunaRiteSacrifice => "ACTION_REASON_LUNA_RITE_SACRIFICE",
            Self::ActionReasonLunaRiteTakeSacrificeReward => {
                "ACTION_REASON_LUNA_RITE_TAKE_SACRIFICE_REWARD"
            }
            Self::ActionReasonFishBite => "ACTION_REASON_FISH_BITE",
            Self::ActionReasonFishSucc => "ACTION_REASON_FISH_SUCC",
            Self::ActionReasonPlantFlowerReward => "ACTION_REASON_PLANT_FLOWER_REWARD",
            Self::ActionReasonPlantFlowerDeliverItem => {
                "ACTION_REASON_PLANT_FLOWER_DELIVER_ITEM"
            }
            Self::ActionReasonPlantFlowerGiveFlower => {
                "ACTION_REASON_PLANT_FLOWER_GIVE_FLOWER"
            }
            Self::ActionReasonPlantFlowerRecvFlower => {
                "ACTION_REASON_PLANT_FLOWER_RECV_FLOWER"
            }
            Self::ActionReasonRogueChallengeSettle => {
                "ACTION_REASON_ROGUE_CHALLENGE_SETTLE"
            }
            Self::ActionReasonRogueTakeFirstPassReward => {
                "ACTION_REASON_ROGUE_TAKE_FIRST_PASS_REWARD"
            }
            Self::ActionReasonRogueUpgradeShikigami => {
                "ACTION_REASON_ROGUE_UPGRADE_SHIKIGAMI"
            }
            Self::ActionReasonRogueRefreshCard => "ACTION_REASON_ROGUE_REFRESH_CARD",
            Self::ActionReasonUseWidgetCaptureAnimal => {
                "ACTION_REASON_USE_WIDGET_CAPTURE_ANIMAL"
            }
            Self::ActionReasonCaptureAnimalSucc => "ACTION_REASON_CAPTURE_ANIMAL_SUCC",
            Self::ActionReasonSnowDrifts => "ACTION_REASON_SNOW_DRIFTS",
            Self::ActionReasonWinterCampGiveItem => "ACTION_REASON_WINTER_CAMP_GIVE_ITEM",
            Self::ActionReasonWinterCampRecvItem => "ACTION_REASON_WINTER_CAMP_RECV_ITEM",
            Self::ActionReasonWinterCampExploreReward => {
                "ACTION_REASON_WINTER_CAMP_EXPLORE_REWARD"
            }
            Self::ActionReasonWinterCampBattleReward => {
                "ACTION_REASON_WINTER_CAMP_BATTLE_REWARD"
            }
            Self::ActionReasonLanternRiteSkinReward => {
                "ACTION_REASON_LANTERN_RITE_SKIN_REWARD"
            }
            Self::ActionReasonLanternRiteDungeonReward => {
                "ACTION_REASON_LANTERN_RITE_DUNGEON_REWARD"
            }
            Self::ActionReasonMichiaeMatsuriDarkChallengeReward => {
                "ACTION_REASON_MICHIAE_MATSURI_DARK_CHALLENGE_REWARD"
            }
            Self::ActionReasonMichiaeMatsuriUnlockCrystalSkill => {
                "ACTION_REASON_MICHIAE_MATSURI_UNLOCK_CRYSTAL_SKILL"
            }
            Self::ActionReasonLanternRiteGroupReward => {
                "ACTION_REASON_LANTERN_RITE_GROUP_REWARD"
            }
            Self::ActionReasonCostumeDefaultUnlock => {
                "ACTION_REASON_COSTUME_DEFAULT_UNLOCK"
            }
            Self::ActionReasonSpiceActivityMakeSpice => {
                "ACTION_REASON_SPICE_ACTIVITY_MAKE_SPICE"
            }
            Self::ActionReasonSpiceActivityProcessFood => {
                "ACTION_REASON_SPICE_ACTIVITY_PROCESS_FOOD"
            }
            Self::ActionReasonSpiceAddAvatarFetter => {
                "ACTION_REASON_SPICE_ADD_AVATAR_FETTER"
            }
            Self::ActionReasonGachaActivityRobotReward => {
                "ACTION_REASON_GACHA_ACTIVITY_ROBOT_REWARD"
            }
            Self::ActionReasonGivingTakeBack => "ACTION_REASON_GIVING_TAKE_BACK",
            Self::ActionReasonSummerTimeV2DungeonReward => {
                "ACTION_REASON_SUMMER_TIME_V2_DUNGEON_REWARD"
            }
            Self::ActionReasonGravenInnocenceCampReward => {
                "ACTION_REASON_GRAVEN_INNOCENCE_CAMP_REWARD"
            }
            Self::ActionReasonTreasureSeelieChestReward => {
                "ACTION_REASON_TREASURE_SEELIE_CHEST_REWARD"
            }
            Self::ActionReasonGcgTavernChallengeUnlockCharacter => {
                "ACTION_REASON_GCG_TAVERN_CHALLENGE_UNLOCK_CHARACTER"
            }
            Self::ActionReasonGcgLevelReward => "ACTION_REASON_GCG_LEVEL_REWARD",
            Self::ActionReasonGcgChallengeFinish => "ACTION_REASON_GCG_CHALLENGE_FINISH",
            Self::ActionReasonVintageMarketDeal => "ACTION_REASON_VINTAGE_MARKET_DEAL",
            Self::ActionReasonVintageMarketBargain => {
                "ACTION_REASON_VINTAGE_MARKET_BARGAIN"
            }
            Self::ActionReasonVintageMarketStore => "ACTION_REASON_VINTAGE_MARKET_STORE",
            Self::ActionReasonVintagePresent => "ACTION_REASON_VINTAGE_PRESENT",
            Self::ActionReasonVintageOpenStore => "ACTION_REASON_VINTAGE_OPEN_STORE",
            Self::ActionReasonVintageStoreUnlockSlot => {
                "ACTION_REASON_VINTAGE_STORE_UNLOCK_SLOT"
            }
            Self::ActionReasonVintageStoreNpcEvent => {
                "ACTION_REASON_VINTAGE_STORE_NPC_EVENT"
            }
            Self::ActionReasonRockBoardExploreReward => {
                "ACTION_REASON_ROCK_BOARD_EXPLORE_REWARD"
            }
            Self::ActionReasonVintageStoreDividend => {
                "ACTION_REASON_VINTAGE_STORE_DIVIDEND"
            }
            Self::ActionReasonAvatarRename => "ACTION_REASON_AVATAR_RENAME",
            Self::ActionReasonGcgFinishLevelQuest => {
                "ACTION_REASON_GCG_FINISH_LEVEL_QUEST"
            }
            Self::ActionReasonGcgProficiencyReward => {
                "ACTION_REASON_GCG_PROFICIENCY_REWARD"
            }
            Self::ActionReasonTeamChainCostumeReward => {
                "ACTION_REASON_TEAM_CHAIN_COSTUME_REWARD"
            }
            Self::ActionReasonOfferingPariFinishReward => {
                "ACTION_REASON_OFFERING_PARI_FINISH_REWARD"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_REASON_NONE" => Some(Self::ActionReasonNone),
            "ACTION_REASON_QUEST_ITEM" => Some(Self::ActionReasonQuestItem),
            "ACTION_REASON_QUEST_REWARD" => Some(Self::ActionReasonQuestReward),
            "ACTION_REASON_TRIFLE" => Some(Self::ActionReasonTrifle),
            "ACTION_REASON_SHOP" => Some(Self::ActionReasonShop),
            "ACTION_REASON_PLAYER_UPGRADE_REWARD" => {
                Some(Self::ActionReasonPlayerUpgradeReward)
            }
            "ACTION_REASON_ADD_AVATAR" => Some(Self::ActionReasonAddAvatar),
            "ACTION_REASON_GADGET_ENV_ANIMAL" => Some(Self::ActionReasonGadgetEnvAnimal),
            "ACTION_REASON_MONSTER_ENV_ANIMAL" => {
                Some(Self::ActionReasonMonsterEnvAnimal)
            }
            "ACTION_REASON_COMPOUND" => Some(Self::ActionReasonCompound),
            "ACTION_REASON_COOK" => Some(Self::ActionReasonCook),
            "ACTION_REASON_GATHER" => Some(Self::ActionReasonGather),
            "ACTION_REASON_MAIL_ATTACHMENT" => Some(Self::ActionReasonMailAttachment),
            "ACTION_REASON_CITY_LEVELUP_RETURN" => {
                Some(Self::ActionReasonCityLevelupReturn)
            }
            "ACTION_REASON_CITY_LEVELUP_REWARD" => {
                Some(Self::ActionReasonCityLevelupReward)
            }
            "ACTION_REASON_AREA_EXPLORE_REWARD" => {
                Some(Self::ActionReasonAreaExploreReward)
            }
            "ACTION_REASON_UNLOCK_POINT_REWARD" => {
                Some(Self::ActionReasonUnlockPointReward)
            }
            "ACTION_REASON_DUNGEON_FIRST_PASS" => {
                Some(Self::ActionReasonDungeonFirstPass)
            }
            "ACTION_REASON_DUNGEON_PASS" => Some(Self::ActionReasonDungeonPass),
            "ACTION_REASON_CHANGE_ELEM_TYPE" => Some(Self::ActionReasonChangeElemType),
            "ACTION_REASON_FETTER_OPEN" => Some(Self::ActionReasonFetterOpen),
            "ACTION_REASON_DAILY_TASK_SCORE" => Some(Self::ActionReasonDailyTaskScore),
            "ACTION_REASON_DAILY_TASK_HOST" => Some(Self::ActionReasonDailyTaskHost),
            "ACTION_REASON_RAND_TASK_HOST" => Some(Self::ActionReasonRandTaskHost),
            "ACTION_REASON_EXPEDITION" => Some(Self::ActionReasonExpedition),
            "ACTION_REASON_GACHA" => Some(Self::ActionReasonGacha),
            "ACTION_REASON_COMBINE" => Some(Self::ActionReasonCombine),
            "ACTION_REASON_RAND_TASK_GUEST" => Some(Self::ActionReasonRandTaskGuest),
            "ACTION_REASON_DAILY_TASK_GUEST" => Some(Self::ActionReasonDailyTaskGuest),
            "ACTION_REASON_FORGE_OUTPUT" => Some(Self::ActionReasonForgeOutput),
            "ACTION_REASON_FORGE_RETURN" => Some(Self::ActionReasonForgeReturn),
            "ACTION_REASON_INIT_AVATAR" => Some(Self::ActionReasonInitAvatar),
            "ACTION_REASON_MONSTER_DIE" => Some(Self::ActionReasonMonsterDie),
            "ACTION_REASON_GM" => Some(Self::ActionReasonGm),
            "ACTION_REASON_OPEN_CHEST" => Some(Self::ActionReasonOpenChest),
            "ACTION_REASON_GADGET_DIE" => Some(Self::ActionReasonGadgetDie),
            "ACTION_REASON_MONSTER_CHANGE_HP" => Some(Self::ActionReasonMonsterChangeHp),
            "ACTION_REASON_SUBFIELD_DROP" => Some(Self::ActionReasonSubfieldDrop),
            "ACTION_REASON_PUSH_TIPS_REWARD" => Some(Self::ActionReasonPushTipsReward),
            "ACTION_REASON_ACTIVITY_MONSTER_DROP" => {
                Some(Self::ActionReasonActivityMonsterDrop)
            }
            "ACTION_REASON_ACTIVITY_GATHER" => Some(Self::ActionReasonActivityGather),
            "ACTION_REASON_ACTIVITY_SUBFIELD_DROP" => {
                Some(Self::ActionReasonActivitySubfieldDrop)
            }
            "ACTION_REASON_TOWER_SCHEDULE_REWARD" => {
                Some(Self::ActionReasonTowerScheduleReward)
            }
            "ACTION_REASON_TOWER_FLOOR_STAR_REWARD" => {
                Some(Self::ActionReasonTowerFloorStarReward)
            }
            "ACTION_REASON_TOWER_FIRST_PASS_REWARD" => {
                Some(Self::ActionReasonTowerFirstPassReward)
            }
            "ACTION_REASON_TOWER_DAILY_REWARD" => {
                Some(Self::ActionReasonTowerDailyReward)
            }
            "ACTION_REASON_HIT_CLIENT_TRIVIAL_ENTITY" => {
                Some(Self::ActionReasonHitClientTrivialEntity)
            }
            "ACTION_REASON_OPEN_WORLD_BOSS_CHEST" => {
                Some(Self::ActionReasonOpenWorldBossChest)
            }
            "ACTION_REASON_MATERIAL_DELETE_RETURN" => {
                Some(Self::ActionReasonMaterialDeleteReturn)
            }
            "ACTION_REASON_SIGN_IN_REWARD" => Some(Self::ActionReasonSignInReward),
            "ACTION_REASON_OPEN_BLOSSOM_CHEST" => {
                Some(Self::ActionReasonOpenBlossomChest)
            }
            "ACTION_REASON_RECHARGE" => Some(Self::ActionReasonRecharge),
            "ACTION_REASON_BONUS_ACTIVITY_REWARD" => {
                Some(Self::ActionReasonBonusActivityReward)
            }
            "ACTION_REASON_TOWER_COMMEMORATIVE_REWARD" => {
                Some(Self::ActionReasonTowerCommemorativeReward)
            }
            "ACTION_REASON_TOWER_SKIP_FLOOR_REWARD" => {
                Some(Self::ActionReasonTowerSkipFloorReward)
            }
            "ACTION_REASON_RECHARGE_BONUS" => Some(Self::ActionReasonRechargeBonus),
            "ACTION_REASON_RECHARGE_CARD" => Some(Self::ActionReasonRechargeCard),
            "ACTION_REASON_RECHARGE_CARD_DAILY" => {
                Some(Self::ActionReasonRechargeCardDaily)
            }
            "ACTION_REASON_RECHARGE_CARD_REPLACE" => {
                Some(Self::ActionReasonRechargeCardReplace)
            }
            "ACTION_REASON_RECHARGE_CARD_REPLACE_FREE" => {
                Some(Self::ActionReasonRechargeCardReplaceFree)
            }
            "ACTION_REASON_RECHARGE_PLAY_REPLACE" => {
                Some(Self::ActionReasonRechargePlayReplace)
            }
            "ACTION_REASON_MP_PLAY_TAKE_REWARD" => {
                Some(Self::ActionReasonMpPlayTakeReward)
            }
            "ACTION_REASON_ACTIVITY_WATCHER" => Some(Self::ActionReasonActivityWatcher),
            "ACTION_REASON_SALESMAN_DELIVER_ITEM" => {
                Some(Self::ActionReasonSalesmanDeliverItem)
            }
            "ACTION_REASON_SALESMAN_REWARD" => Some(Self::ActionReasonSalesmanReward),
            "ACTION_REASON_REBATE" => Some(Self::ActionReasonRebate),
            "ACTION_REASON_MCOIN_EXCHANGE_HCOIN" => {
                Some(Self::ActionReasonMcoinExchangeHcoin)
            }
            "ACTION_REASON_DAILY_TASK_EXCHANGE_LEGENDARY_KEY" => {
                Some(Self::ActionReasonDailyTaskExchangeLegendaryKey)
            }
            "ACTION_REASON_UNLOCK_PERSON_LINE" => {
                Some(Self::ActionReasonUnlockPersonLine)
            }
            "ACTION_REASON_FETTER_LEVEL_REWARD" => {
                Some(Self::ActionReasonFetterLevelReward)
            }
            "ACTION_REASON_BUY_RESIN" => Some(Self::ActionReasonBuyResin),
            "ACTION_REASON_RECHARGE_PACKAGE" => Some(Self::ActionReasonRechargePackage),
            "ACTION_REASON_DELIVERY_DAILY_REWARD" => {
                Some(Self::ActionReasonDeliveryDailyReward)
            }
            "ACTION_REASON_CITY_REPUTATION_LEVEL" => {
                Some(Self::ActionReasonCityReputationLevel)
            }
            "ACTION_REASON_CITY_REPUTATION_QUEST" => {
                Some(Self::ActionReasonCityReputationQuest)
            }
            "ACTION_REASON_CITY_REPUTATION_REQUEST" => {
                Some(Self::ActionReasonCityReputationRequest)
            }
            "ACTION_REASON_CITY_REPUTATION_EXPLORE" => {
                Some(Self::ActionReasonCityReputationExplore)
            }
            "ACTION_REASON_OFFERING_LEVEL" => Some(Self::ActionReasonOfferingLevel),
            "ACTION_REASON_ROUTINE_HOST" => Some(Self::ActionReasonRoutineHost),
            "ACTION_REASON_ROUTINE_GUEST" => Some(Self::ActionReasonRoutineGuest),
            "ACTION_REASON_TREASURE_MAP_SPOT_TOKEN" => {
                Some(Self::ActionReasonTreasureMapSpotToken)
            }
            "ACTION_REASON_TREASURE_MAP_BONUS_LEVEL_REWARD" => {
                Some(Self::ActionReasonTreasureMapBonusLevelReward)
            }
            "ACTION_REASON_TREASURE_MAP_MP_REWARD" => {
                Some(Self::ActionReasonTreasureMapMpReward)
            }
            "ACTION_REASON_CONVERT" => Some(Self::ActionReasonConvert),
            "ACTION_REASON_OVERFLOW_TRANSFORM" => {
                Some(Self::ActionReasonOverflowTransform)
            }
            "ACTION_REASON_ACTIVITY_AVATAR_SELECTION_REWARD" => {
                Some(Self::ActionReasonActivityAvatarSelectionReward)
            }
            "ACTION_REASON_ACTIVITY_WATCHER_BATCH" => {
                Some(Self::ActionReasonActivityWatcherBatch)
            }
            "ACTION_REASON_HIT_TREE_DROP" => Some(Self::ActionReasonHitTreeDrop),
            "ACTION_REASON_GET_HOME_LEVELUP_REWARD" => {
                Some(Self::ActionReasonGetHomeLevelupReward)
            }
            "ACTION_REASON_HOME_DEFAULT_FURNITURE" => {
                Some(Self::ActionReasonHomeDefaultFurniture)
            }
            "ACTION_REASON_ACTIVITY_COND" => Some(Self::ActionReasonActivityCond),
            "ACTION_REASON_BATTLE_PASS_NOTIFY" => {
                Some(Self::ActionReasonBattlePassNotify)
            }
            "ACTION_REASON_RELIQUARY_DECOMPOSE" => {
                Some(Self::ActionReasonReliquaryDecompose)
            }
            "ACTION_REASON_RECHARGE_GOOGLE_GIFT_GARD" => {
                Some(Self::ActionReasonRechargeGoogleGiftGard)
            }
            "ACTION_REASON_RECHARGE_CONCERT_PRODUCT" => {
                Some(Self::ActionReasonRechargeConcertProduct)
            }
            "ACTION_REASON_RECHARGE_CONCERT_PRODUCT_REPLACE" => {
                Some(Self::ActionReasonRechargeConcertProductReplace)
            }
            "ACTION_REASON_SEND_CONCERT_PRODUCT_BY_MUIP" => {
                Some(Self::ActionReasonSendConcertProductByMuip)
            }
            "ACTION_REASON_RECHARGE_APPLE_GIFT_GARD" => {
                Some(Self::ActionReasonRechargeAppleGiftGard)
            }
            "ACTION_REASON_RECHARGE_PSN_COMPENSATION_PRODUCT" => {
                Some(Self::ActionReasonRechargePsnCompensationProduct)
            }
            "ACTION_REASON_COMPOUND_BOOST" => Some(Self::ActionReasonCompoundBoost),
            "ACTION_REASON_WOOD_EXCHANGE" => Some(Self::ActionReasonWoodExchange),
            "ACTION_REASON_AVATAR_RENAME_AUDIT_FAILED" => {
                Some(Self::ActionReasonAvatarRenameAuditFailed)
            }
            "ACTION_REASON_AVATAR_RENAME_RESET" => {
                Some(Self::ActionReasonAvatarRenameReset)
            }
            "ACTION_REASON_PLAYER_USE_ITEM" => Some(Self::ActionReasonPlayerUseItem),
            "ACTION_REASON_DROP_ITEM" => Some(Self::ActionReasonDropItem),
            "ACTION_REASON_WEAPON_UPGRADE" => Some(Self::ActionReasonWeaponUpgrade),
            "ACTION_REASON_WEAPON_PROMOTE" => Some(Self::ActionReasonWeaponPromote),
            "ACTION_REASON_WEAPON_AWAKEN" => Some(Self::ActionReasonWeaponAwaken),
            "ACTION_REASON_RELIC_UPGRADE" => Some(Self::ActionReasonRelicUpgrade),
            "ACTION_REASON_ABILITY" => Some(Self::ActionReasonAbility),
            "ACTION_REASON_DUNGEON_STATUE_DROP" => {
                Some(Self::ActionReasonDungeonStatueDrop)
            }
            "ACTION_REASON_OFFLINE_MSG" => Some(Self::ActionReasonOfflineMsg),
            "ACTION_REASON_AVATAR_UPGRADE" => Some(Self::ActionReasonAvatarUpgrade),
            "ACTION_REASON_AVATAR_PROMOTE" => Some(Self::ActionReasonAvatarPromote),
            "ACTION_REASON_QUEST_ACTION" => Some(Self::ActionReasonQuestAction),
            "ACTION_REASON_CITY_LEVELUP" => Some(Self::ActionReasonCityLevelup),
            "ACTION_REASON_UPGRADE_SKILL" => Some(Self::ActionReasonUpgradeSkill),
            "ACTION_REASON_UNLOCK_TALENT" => Some(Self::ActionReasonUnlockTalent),
            "ACTION_REASON_UPGRADE_PROUD_SKILL" => {
                Some(Self::ActionReasonUpgradeProudSkill)
            }
            "ACTION_REASON_PLAYER_LEVEL_LIMIT_UP" => {
                Some(Self::ActionReasonPlayerLevelLimitUp)
            }
            "ACTION_REASON_DUNGEON_DAILY" => Some(Self::ActionReasonDungeonDaily),
            "ACTION_REASON_ITEM_GIVING" => Some(Self::ActionReasonItemGiving),
            "ACTION_REASON_FORGE_COST" => Some(Self::ActionReasonForgeCost),
            "ACTION_REASON_INVESTIGATION_REWARD" => {
                Some(Self::ActionReasonInvestigationReward)
            }
            "ACTION_REASON_INVESTIGATION_TARGET_REWARD" => {
                Some(Self::ActionReasonInvestigationTargetReward)
            }
            "ACTION_REASON_GADGET_INTERACT" => Some(Self::ActionReasonGadgetInteract),
            "ACTION_REASON_SEA_LAMP_CI_MATERIAL" => {
                Some(Self::ActionReasonSeaLampCiMaterial)
            }
            "ACTION_REASON_SEA_LAMP_CONTRIBUTION_REWARD" => {
                Some(Self::ActionReasonSeaLampContributionReward)
            }
            "ACTION_REASON_SEA_LAMP_PHASE_REWARD" => {
                Some(Self::ActionReasonSeaLampPhaseReward)
            }
            "ACTION_REASON_SEA_LAMP_FLY_LAMP" => Some(Self::ActionReasonSeaLampFlyLamp),
            "ACTION_REASON_AUTO_RECOVER" => Some(Self::ActionReasonAutoRecover),
            "ACTION_REASON_ACTIVITY_EXPIRE_ITEM" => {
                Some(Self::ActionReasonActivityExpireItem)
            }
            "ACTION_REASON_SUB_COIN_NEGATIVE" => Some(Self::ActionReasonSubCoinNegative),
            "ACTION_REASON_BARGAIN_DEDUCT" => Some(Self::ActionReasonBargainDeduct),
            "ACTION_REASON_BATTLE_PASS_PAID_REWARD" => {
                Some(Self::ActionReasonBattlePassPaidReward)
            }
            "ACTION_REASON_BATTLE_PASS_LEVEL_REWARD" => {
                Some(Self::ActionReasonBattlePassLevelReward)
            }
            "ACTION_REASON_TRIAL_AVATAR_ACTIVITY_FIRST_PASS_REWARD" => {
                Some(Self::ActionReasonTrialAvatarActivityFirstPassReward)
            }
            "ACTION_REASON_BUY_BATTLE_PASS_LEVEL" => {
                Some(Self::ActionReasonBuyBattlePassLevel)
            }
            "ACTION_REASON_GRANT_BIRTHDAY_BENEFIT" => {
                Some(Self::ActionReasonGrantBirthdayBenefit)
            }
            "ACTION_REASON_ACHIEVEMENT_REWARD" => {
                Some(Self::ActionReasonAchievementReward)
            }
            "ACTION_REASON_ACHIEVEMENT_GOAL_REWARD" => {
                Some(Self::ActionReasonAchievementGoalReward)
            }
            "ACTION_REASON_FIRST_SHARE_TO_SOCIAL_NETWORK" => {
                Some(Self::ActionReasonFirstShareToSocialNetwork)
            }
            "ACTION_REASON_DESTROY_MATERIAL" => Some(Self::ActionReasonDestroyMaterial),
            "ACTION_REASON_CODEX_LEVELUP_REWARD" => {
                Some(Self::ActionReasonCodexLevelupReward)
            }
            "ACTION_REASON_HUNTING_OFFER_REWARD" => {
                Some(Self::ActionReasonHuntingOfferReward)
            }
            "ACTION_REASON_USE_WIDGET_ANCHOR_POINT" => {
                Some(Self::ActionReasonUseWidgetAnchorPoint)
            }
            "ACTION_REASON_USE_WIDGET_BONFIRE" => {
                Some(Self::ActionReasonUseWidgetBonfire)
            }
            "ACTION_REASON_UNGRADE_WEAPON_RETURN_MATERIAL" => {
                Some(Self::ActionReasonUngradeWeaponReturnMaterial)
            }
            "ACTION_REASON_USE_WIDGET_ONEOFF_GATHER_POINT_DETECTOR" => {
                Some(Self::ActionReasonUseWidgetOneoffGatherPointDetector)
            }
            "ACTION_REASON_USE_WIDGET_CLIENT_COLLECTOR" => {
                Some(Self::ActionReasonUseWidgetClientCollector)
            }
            "ACTION_REASON_USE_WIDGET_CLIENT_DETECTOR" => {
                Some(Self::ActionReasonUseWidgetClientDetector)
            }
            "ACTION_REASON_TAKE_GENERAL_REWARD" => {
                Some(Self::ActionReasonTakeGeneralReward)
            }
            "ACTION_REASON_ASTER_TAKE_SPECIAL_REWARD" => {
                Some(Self::ActionReasonAsterTakeSpecialReward)
            }
            "ACTION_REASON_REMOVE_CODEX_BOOK" => Some(Self::ActionReasonRemoveCodexBook),
            "ACTION_REASON_OFFERING_ITEM" => Some(Self::ActionReasonOfferingItem),
            "ACTION_REASON_USE_WIDGET_GADGET_BUILDER" => {
                Some(Self::ActionReasonUseWidgetGadgetBuilder)
            }
            "ACTION_REASON_EFFIGY_FIRST_PASS_REWARD" => {
                Some(Self::ActionReasonEffigyFirstPassReward)
            }
            "ACTION_REASON_EFFIGY_REWARD" => Some(Self::ActionReasonEffigyReward),
            "ACTION_REASON_REUNION_FIRST_GIFT_REWARD" => {
                Some(Self::ActionReasonReunionFirstGiftReward)
            }
            "ACTION_REASON_REUNION_SIGN_IN_REWARD" => {
                Some(Self::ActionReasonReunionSignInReward)
            }
            "ACTION_REASON_REUNION_WATCHER_REWARD" => {
                Some(Self::ActionReasonReunionWatcherReward)
            }
            "ACTION_REASON_SALESMAN_MP_REWARD" => {
                Some(Self::ActionReasonSalesmanMpReward)
            }
            "ACTION_REASON_AVATAR_PROMOTE_REWARD" => {
                Some(Self::ActionReasonAvatarPromoteReward)
            }
            "ACTION_REASON_BLESSING_REDEEM_REWARD" => {
                Some(Self::ActionReasonBlessingRedeemReward)
            }
            "ACTION_REASON_MIRACLE_RING_REWARD" => {
                Some(Self::ActionReasonMiracleRingReward)
            }
            "ACTION_REASON_EXPEDITION_REWARD" => Some(Self::ActionReasonExpeditionReward),
            "ACTION_REASON_TREASURE_MAP_REMOVE_DETECTOR" => {
                Some(Self::ActionReasonTreasureMapRemoveDetector)
            }
            "ACTION_REASON_MECHANICUS_DUNGEON_TICKET" => {
                Some(Self::ActionReasonMechanicusDungeonTicket)
            }
            "ACTION_REASON_MECHANICUS_LEVELUP_GEAR" => {
                Some(Self::ActionReasonMechanicusLevelupGear)
            }
            "ACTION_REASON_MECHANICUS_BATTLE_SETTLE" => {
                Some(Self::ActionReasonMechanicusBattleSettle)
            }
            "ACTION_REASON_REGION_SEARCH_REWARD" => {
                Some(Self::ActionReasonRegionSearchReward)
            }
            "ACTION_REASON_UNLOCK_COOP_CHAPTER" => {
                Some(Self::ActionReasonUnlockCoopChapter)
            }
            "ACTION_REASON_TAKE_COOP_REWARD" => Some(Self::ActionReasonTakeCoopReward),
            "ACTION_REASON_FLEUR_FAIR_DUNGEON_REWARD" => {
                Some(Self::ActionReasonFleurFairDungeonReward)
            }
            "ACTION_REASON_ACTIVITY_SCORE" => Some(Self::ActionReasonActivityScore),
            "ACTION_REASON_CHANNELLER_SLAB_ONEOFF_DUNGEON_REWARD" => {
                Some(Self::ActionReasonChannellerSlabOneoffDungeonReward)
            }
            "ACTION_REASON_FURNITURE_MAKE_START" => {
                Some(Self::ActionReasonFurnitureMakeStart)
            }
            "ACTION_REASON_FURNITURE_MAKE_TAKE" => {
                Some(Self::ActionReasonFurnitureMakeTake)
            }
            "ACTION_REASON_FURNITURE_MAKE_CANCEL" => {
                Some(Self::ActionReasonFurnitureMakeCancel)
            }
            "ACTION_REASON_FURNITURE_MAKE_FAST_FINISH" => {
                Some(Self::ActionReasonFurnitureMakeFastFinish)
            }
            "ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_FIRST_PASS_REWARD" => {
                Some(Self::ActionReasonChannellerSlabLoopDungeonFirstPassReward)
            }
            "ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_SCORE_REWARD" => {
                Some(Self::ActionReasonChannellerSlabLoopDungeonScoreReward)
            }
            "ACTION_REASON_HOME_LIMITED_SHOP_BUY" => {
                Some(Self::ActionReasonHomeLimitedShopBuy)
            }
            "ACTION_REASON_HOME_COIN_COLLECT" => Some(Self::ActionReasonHomeCoinCollect),
            "ACTION_REASON_SUMMER_TIME_SENTRY_TOWER_REWARD" => {
                Some(Self::ActionReasonSummerTimeSentryTowerReward)
            }
            "ACTION_REASON_SUMMER_TIME_SPRINT_BOAT_REWARD" => {
                Some(Self::ActionReasonSummerTimeSprintBoatReward)
            }
            "ACTION_REASON_SUMMER_TIME_BOSS_REWARD" => {
                Some(Self::ActionReasonSummerTimeBossReward)
            }
            "ACTION_REASON_SUMMER_TIME_BOMB_REWARD" => {
                Some(Self::ActionReasonSummerTimeBombReward)
            }
            "ACTION_REASON_HOME_FETTER_COLLECT" => {
                Some(Self::ActionReasonHomeFetterCollect)
            }
            "ACTION_REASON_ECHO_SHELL_REWARD" => Some(Self::ActionReasonEchoShellReward),
            "ACTION_REASON_HOME_EVENT_REWARD" => Some(Self::ActionReasonHomeEventReward),
            "ACTION_REASON_BLITZ_RUSH_DUNGEON_REWARD" => {
                Some(Self::ActionReasonBlitzRushDungeonReward)
            }
            "ACTION_REASON_FURNITURE_MAKE_RETURN" => {
                Some(Self::ActionReasonFurnitureMakeReturn)
            }
            "ACTION_REASON_HOME_PLANT_BOX_GATHER" => {
                Some(Self::ActionReasonHomePlantBoxGather)
            }
            "ACTION_REASON_HOME_PLANT_SEED" => Some(Self::ActionReasonHomePlantSeed),
            "ACTION_REASON_HOME_PLANT_GATHER" => Some(Self::ActionReasonHomePlantGather),
            "ACTION_REASON_CHESS_DUNGEON_REWARD" => {
                Some(Self::ActionReasonChessDungeonReward)
            }
            "ACTION_REASON_GROUP_LINK_BUNDLE_FINISH" => {
                Some(Self::ActionReasonGroupLinkBundleFinish)
            }
            "ACTION_REASON_LUNA_RITE_SACRIFICE" => {
                Some(Self::ActionReasonLunaRiteSacrifice)
            }
            "ACTION_REASON_LUNA_RITE_TAKE_SACRIFICE_REWARD" => {
                Some(Self::ActionReasonLunaRiteTakeSacrificeReward)
            }
            "ACTION_REASON_FISH_BITE" => Some(Self::ActionReasonFishBite),
            "ACTION_REASON_FISH_SUCC" => Some(Self::ActionReasonFishSucc),
            "ACTION_REASON_PLANT_FLOWER_REWARD" => {
                Some(Self::ActionReasonPlantFlowerReward)
            }
            "ACTION_REASON_PLANT_FLOWER_DELIVER_ITEM" => {
                Some(Self::ActionReasonPlantFlowerDeliverItem)
            }
            "ACTION_REASON_PLANT_FLOWER_GIVE_FLOWER" => {
                Some(Self::ActionReasonPlantFlowerGiveFlower)
            }
            "ACTION_REASON_PLANT_FLOWER_RECV_FLOWER" => {
                Some(Self::ActionReasonPlantFlowerRecvFlower)
            }
            "ACTION_REASON_ROGUE_CHALLENGE_SETTLE" => {
                Some(Self::ActionReasonRogueChallengeSettle)
            }
            "ACTION_REASON_ROGUE_TAKE_FIRST_PASS_REWARD" => {
                Some(Self::ActionReasonRogueTakeFirstPassReward)
            }
            "ACTION_REASON_ROGUE_UPGRADE_SHIKIGAMI" => {
                Some(Self::ActionReasonRogueUpgradeShikigami)
            }
            "ACTION_REASON_ROGUE_REFRESH_CARD" => {
                Some(Self::ActionReasonRogueRefreshCard)
            }
            "ACTION_REASON_USE_WIDGET_CAPTURE_ANIMAL" => {
                Some(Self::ActionReasonUseWidgetCaptureAnimal)
            }
            "ACTION_REASON_CAPTURE_ANIMAL_SUCC" => {
                Some(Self::ActionReasonCaptureAnimalSucc)
            }
            "ACTION_REASON_SNOW_DRIFTS" => Some(Self::ActionReasonSnowDrifts),
            "ACTION_REASON_WINTER_CAMP_GIVE_ITEM" => {
                Some(Self::ActionReasonWinterCampGiveItem)
            }
            "ACTION_REASON_WINTER_CAMP_RECV_ITEM" => {
                Some(Self::ActionReasonWinterCampRecvItem)
            }
            "ACTION_REASON_WINTER_CAMP_EXPLORE_REWARD" => {
                Some(Self::ActionReasonWinterCampExploreReward)
            }
            "ACTION_REASON_WINTER_CAMP_BATTLE_REWARD" => {
                Some(Self::ActionReasonWinterCampBattleReward)
            }
            "ACTION_REASON_LANTERN_RITE_SKIN_REWARD" => {
                Some(Self::ActionReasonLanternRiteSkinReward)
            }
            "ACTION_REASON_LANTERN_RITE_DUNGEON_REWARD" => {
                Some(Self::ActionReasonLanternRiteDungeonReward)
            }
            "ACTION_REASON_MICHIAE_MATSURI_DARK_CHALLENGE_REWARD" => {
                Some(Self::ActionReasonMichiaeMatsuriDarkChallengeReward)
            }
            "ACTION_REASON_MICHIAE_MATSURI_UNLOCK_CRYSTAL_SKILL" => {
                Some(Self::ActionReasonMichiaeMatsuriUnlockCrystalSkill)
            }
            "ACTION_REASON_LANTERN_RITE_GROUP_REWARD" => {
                Some(Self::ActionReasonLanternRiteGroupReward)
            }
            "ACTION_REASON_COSTUME_DEFAULT_UNLOCK" => {
                Some(Self::ActionReasonCostumeDefaultUnlock)
            }
            "ACTION_REASON_SPICE_ACTIVITY_MAKE_SPICE" => {
                Some(Self::ActionReasonSpiceActivityMakeSpice)
            }
            "ACTION_REASON_SPICE_ACTIVITY_PROCESS_FOOD" => {
                Some(Self::ActionReasonSpiceActivityProcessFood)
            }
            "ACTION_REASON_SPICE_ADD_AVATAR_FETTER" => {
                Some(Self::ActionReasonSpiceAddAvatarFetter)
            }
            "ACTION_REASON_GACHA_ACTIVITY_ROBOT_REWARD" => {
                Some(Self::ActionReasonGachaActivityRobotReward)
            }
            "ACTION_REASON_GIVING_TAKE_BACK" => Some(Self::ActionReasonGivingTakeBack),
            "ACTION_REASON_SUMMER_TIME_V2_DUNGEON_REWARD" => {
                Some(Self::ActionReasonSummerTimeV2DungeonReward)
            }
            "ACTION_REASON_GRAVEN_INNOCENCE_CAMP_REWARD" => {
                Some(Self::ActionReasonGravenInnocenceCampReward)
            }
            "ACTION_REASON_TREASURE_SEELIE_CHEST_REWARD" => {
                Some(Self::ActionReasonTreasureSeelieChestReward)
            }
            "ACTION_REASON_GCG_TAVERN_CHALLENGE_UNLOCK_CHARACTER" => {
                Some(Self::ActionReasonGcgTavernChallengeUnlockCharacter)
            }
            "ACTION_REASON_GCG_LEVEL_REWARD" => Some(Self::ActionReasonGcgLevelReward),
            "ACTION_REASON_GCG_CHALLENGE_FINISH" => {
                Some(Self::ActionReasonGcgChallengeFinish)
            }
            "ACTION_REASON_VINTAGE_MARKET_DEAL" => {
                Some(Self::ActionReasonVintageMarketDeal)
            }
            "ACTION_REASON_VINTAGE_MARKET_BARGAIN" => {
                Some(Self::ActionReasonVintageMarketBargain)
            }
            "ACTION_REASON_VINTAGE_MARKET_STORE" => {
                Some(Self::ActionReasonVintageMarketStore)
            }
            "ACTION_REASON_VINTAGE_PRESENT" => Some(Self::ActionReasonVintagePresent),
            "ACTION_REASON_VINTAGE_OPEN_STORE" => {
                Some(Self::ActionReasonVintageOpenStore)
            }
            "ACTION_REASON_VINTAGE_STORE_UNLOCK_SLOT" => {
                Some(Self::ActionReasonVintageStoreUnlockSlot)
            }
            "ACTION_REASON_VINTAGE_STORE_NPC_EVENT" => {
                Some(Self::ActionReasonVintageStoreNpcEvent)
            }
            "ACTION_REASON_ROCK_BOARD_EXPLORE_REWARD" => {
                Some(Self::ActionReasonRockBoardExploreReward)
            }
            "ACTION_REASON_VINTAGE_STORE_DIVIDEND" => {
                Some(Self::ActionReasonVintageStoreDividend)
            }
            "ACTION_REASON_AVATAR_RENAME" => Some(Self::ActionReasonAvatarRename),
            "ACTION_REASON_GCG_FINISH_LEVEL_QUEST" => {
                Some(Self::ActionReasonGcgFinishLevelQuest)
            }
            "ACTION_REASON_GCG_PROFICIENCY_REWARD" => {
                Some(Self::ActionReasonGcgProficiencyReward)
            }
            "ACTION_REASON_TEAM_CHAIN_COSTUME_REWARD" => {
                Some(Self::ActionReasonTeamChainCostumeReward)
            }
            "ACTION_REASON_OFFERING_PARI_FINISH_REWARD" => {
                Some(Self::ActionReasonOfferingPariFinishReward)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreType {
    None = 0,
    Pack = 1,
    Depot = 2,
}
impl StoreType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "STORE_TYPE_NONE",
            Self::Pack => "STORE_TYPE_PACK",
            Self::Depot => "STORE_TYPE_DEPOT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORE_TYPE_NONE" => Some(Self::None),
            "STORE_TYPE_PACK" => Some(Self::Pack),
            "STORE_TYPE_DEPOT" => Some(Self::Depot),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReliquaryFilterLockState {
    None = 0,
    Lock = 1,
    Unlock = 2,
}
impl ReliquaryFilterLockState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "RELIQUARY_FILTER_LOCK_STATE_NONE",
            Self::Lock => "RELIQUARY_FILTER_LOCK_STATE_LOCK",
            Self::Unlock => "RELIQUARY_FILTER_LOCK_STATE_UNLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELIQUARY_FILTER_LOCK_STATE_NONE" => Some(Self::None),
            "RELIQUARY_FILTER_LOCK_STATE_LOCK" => Some(Self::Lock),
            "RELIQUARY_FILTER_LOCK_STATE_UNLOCK" => Some(Self::Unlock),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReliquaryFilterLevelState {
    None = 0,
    FullLevel = 1,
    NotFullLevel = 2,
}
impl ReliquaryFilterLevelState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "RELIQUARY_FILTER_LEVEL_STATE_NONE",
            Self::FullLevel => "RELIQUARY_FILTER_LEVEL_STATE_FULL_LEVEL",
            Self::NotFullLevel => "RELIQUARY_FILTER_LEVEL_STATE_NOT_FULL_LEVEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELIQUARY_FILTER_LEVEL_STATE_NONE" => Some(Self::None),
            "RELIQUARY_FILTER_LEVEL_STATE_FULL_LEVEL" => Some(Self::FullLevel),
            "RELIQUARY_FILTER_LEVEL_STATE_NOT_FULL_LEVEL" => Some(Self::NotFullLevel),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReliquaryFilterWearedState {
    None = 0,
    HasBeenWeared = 1,
    HasNotBeenWeared = 2,
}
impl ReliquaryFilterWearedState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "RELIQUARY_FILTER_WEARED_STATE_NONE",
            Self::HasBeenWeared => "RELIQUARY_FILTER_WEARED_STATE_HAS_BEEN_WEARED",
            Self::HasNotBeenWeared => "RELIQUARY_FILTER_WEARED_STATE_HAS_NOT_BEEN_WEARED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELIQUARY_FILTER_WEARED_STATE_NONE" => Some(Self::None),
            "RELIQUARY_FILTER_WEARED_STATE_HAS_BEEN_WEARED" => Some(Self::HasBeenWeared),
            "RELIQUARY_FILTER_WEARED_STATE_HAS_NOT_BEEN_WEARED" => {
                Some(Self::HasNotBeenWeared)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AbilityScalarType {
    Unknown = 0,
    Float = 1,
    Int = 2,
    Bool = 3,
    Trigger = 4,
    String = 5,
    Uint = 6,
}
impl AbilityScalarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ABILITY_SCALAR_TYPE_UNKNOWN",
            Self::Float => "ABILITY_SCALAR_TYPE_FLOAT",
            Self::Int => "ABILITY_SCALAR_TYPE_INT",
            Self::Bool => "ABILITY_SCALAR_TYPE_BOOL",
            Self::Trigger => "ABILITY_SCALAR_TYPE_TRIGGER",
            Self::String => "ABILITY_SCALAR_TYPE_STRING",
            Self::Uint => "ABILITY_SCALAR_TYPE_UINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ABILITY_SCALAR_TYPE_UNKNOWN" => Some(Self::Unknown),
            "ABILITY_SCALAR_TYPE_FLOAT" => Some(Self::Float),
            "ABILITY_SCALAR_TYPE_INT" => Some(Self::Int),
            "ABILITY_SCALAR_TYPE_BOOL" => Some(Self::Bool),
            "ABILITY_SCALAR_TYPE_TRIGGER" => Some(Self::Trigger),
            "ABILITY_SCALAR_TYPE_STRING" => Some(Self::String),
            "ABILITY_SCALAR_TYPE_UINT" => Some(Self::Uint),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MotionState {
    None = 0,
    Reset = 1,
    Standby = 2,
    StandbyMove = 3,
    Walk = 4,
    Run = 5,
    Dash = 6,
    Climb = 7,
    ClimbJump = 8,
    StandbyToClimb = 9,
    Fight = 10,
    Jump = 11,
    Drop = 12,
    Fly = 13,
    SwimMove = 14,
    SwimIdle = 15,
    SwimDash = 16,
    SwimJump = 17,
    Slip = 18,
    GoUpstairs = 19,
    FallOnGround = 20,
    JumpUpWallForStandby = 21,
    JumpOffWall = 22,
    PoweredFly = 23,
    LadderIdle = 24,
    LadderMove = 25,
    LadderSlip = 26,
    StandbyToLadder = 27,
    LadderToStandby = 28,
    DangerStandby = 29,
    DangerStandbyMove = 30,
    DangerWalk = 31,
    DangerRun = 32,
    DangerDash = 33,
    CrouchIdle = 34,
    CrouchMove = 35,
    CrouchRoll = 36,
    Notify = 37,
    LandSpeed = 38,
    MoveFailAck = 39,
    Waterfall = 40,
    DashBeforeShake = 41,
    SitIdle = 42,
    ForceSetPos = 43,
    QuestForceDrag = 44,
    FollowRoute = 45,
    SkiffBoarding = 46,
    SkiffNormal = 47,
    SkiffDash = 48,
    SkiffPoweredDash = 49,
    DestroyVehicle = 50,
    FlyIdle = 51,
    FlySlow = 52,
    FlyFast = 53,
    AimMove = 54,
    AirCompensation = 55,
    SorushNormal = 56,
    Num = 57,
}
impl MotionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MOTION_STATE_NONE",
            Self::Reset => "MOTION_STATE_RESET",
            Self::Standby => "MOTION_STATE_STANDBY",
            Self::StandbyMove => "MOTION_STATE_STANDBY_MOVE",
            Self::Walk => "MOTION_STATE_WALK",
            Self::Run => "MOTION_STATE_RUN",
            Self::Dash => "MOTION_STATE_DASH",
            Self::Climb => "MOTION_STATE_CLIMB",
            Self::ClimbJump => "MOTION_STATE_CLIMB_JUMP",
            Self::StandbyToClimb => "MOTION_STATE_STANDBY_TO_CLIMB",
            Self::Fight => "MOTION_STATE_FIGHT",
            Self::Jump => "MOTION_STATE_JUMP",
            Self::Drop => "MOTION_STATE_DROP",
            Self::Fly => "MOTION_STATE_FLY",
            Self::SwimMove => "MOTION_STATE_SWIM_MOVE",
            Self::SwimIdle => "MOTION_STATE_SWIM_IDLE",
            Self::SwimDash => "MOTION_STATE_SWIM_DASH",
            Self::SwimJump => "MOTION_STATE_SWIM_JUMP",
            Self::Slip => "MOTION_STATE_SLIP",
            Self::GoUpstairs => "MOTION_STATE_GO_UPSTAIRS",
            Self::FallOnGround => "MOTION_STATE_FALL_ON_GROUND",
            Self::JumpUpWallForStandby => "MOTION_STATE_JUMP_UP_WALL_FOR_STANDBY",
            Self::JumpOffWall => "MOTION_STATE_JUMP_OFF_WALL",
            Self::PoweredFly => "MOTION_STATE_POWERED_FLY",
            Self::LadderIdle => "MOTION_STATE_LADDER_IDLE",
            Self::LadderMove => "MOTION_STATE_LADDER_MOVE",
            Self::LadderSlip => "MOTION_STATE_LADDER_SLIP",
            Self::StandbyToLadder => "MOTION_STATE_STANDBY_TO_LADDER",
            Self::LadderToStandby => "MOTION_STATE_LADDER_TO_STANDBY",
            Self::DangerStandby => "MOTION_STATE_DANGER_STANDBY",
            Self::DangerStandbyMove => "MOTION_STATE_DANGER_STANDBY_MOVE",
            Self::DangerWalk => "MOTION_STATE_DANGER_WALK",
            Self::DangerRun => "MOTION_STATE_DANGER_RUN",
            Self::DangerDash => "MOTION_STATE_DANGER_DASH",
            Self::CrouchIdle => "MOTION_STATE_CROUCH_IDLE",
            Self::CrouchMove => "MOTION_STATE_CROUCH_MOVE",
            Self::CrouchRoll => "MOTION_STATE_CROUCH_ROLL",
            Self::Notify => "MOTION_STATE_NOTIFY",
            Self::LandSpeed => "MOTION_STATE_LAND_SPEED",
            Self::MoveFailAck => "MOTION_STATE_MOVE_FAIL_ACK",
            Self::Waterfall => "MOTION_STATE_WATERFALL",
            Self::DashBeforeShake => "MOTION_STATE_DASH_BEFORE_SHAKE",
            Self::SitIdle => "MOTION_STATE_SIT_IDLE",
            Self::ForceSetPos => "MOTION_STATE_FORCE_SET_POS",
            Self::QuestForceDrag => "MOTION_STATE_QUEST_FORCE_DRAG",
            Self::FollowRoute => "MOTION_STATE_FOLLOW_ROUTE",
            Self::SkiffBoarding => "MOTION_STATE_SKIFF_BOARDING",
            Self::SkiffNormal => "MOTION_STATE_SKIFF_NORMAL",
            Self::SkiffDash => "MOTION_STATE_SKIFF_DASH",
            Self::SkiffPoweredDash => "MOTION_STATE_SKIFF_POWERED_DASH",
            Self::DestroyVehicle => "MOTION_STATE_DESTROY_VEHICLE",
            Self::FlyIdle => "MOTION_STATE_FLY_IDLE",
            Self::FlySlow => "MOTION_STATE_FLY_SLOW",
            Self::FlyFast => "MOTION_STATE_FLY_FAST",
            Self::AimMove => "MOTION_STATE_AIM_MOVE",
            Self::AirCompensation => "MOTION_STATE_AIR_COMPENSATION",
            Self::SorushNormal => "MOTION_STATE_SORUSH_NORMAL",
            Self::Num => "MOTION_STATE_NUM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MOTION_STATE_NONE" => Some(Self::None),
            "MOTION_STATE_RESET" => Some(Self::Reset),
            "MOTION_STATE_STANDBY" => Some(Self::Standby),
            "MOTION_STATE_STANDBY_MOVE" => Some(Self::StandbyMove),
            "MOTION_STATE_WALK" => Some(Self::Walk),
            "MOTION_STATE_RUN" => Some(Self::Run),
            "MOTION_STATE_DASH" => Some(Self::Dash),
            "MOTION_STATE_CLIMB" => Some(Self::Climb),
            "MOTION_STATE_CLIMB_JUMP" => Some(Self::ClimbJump),
            "MOTION_STATE_STANDBY_TO_CLIMB" => Some(Self::StandbyToClimb),
            "MOTION_STATE_FIGHT" => Some(Self::Fight),
            "MOTION_STATE_JUMP" => Some(Self::Jump),
            "MOTION_STATE_DROP" => Some(Self::Drop),
            "MOTION_STATE_FLY" => Some(Self::Fly),
            "MOTION_STATE_SWIM_MOVE" => Some(Self::SwimMove),
            "MOTION_STATE_SWIM_IDLE" => Some(Self::SwimIdle),
            "MOTION_STATE_SWIM_DASH" => Some(Self::SwimDash),
            "MOTION_STATE_SWIM_JUMP" => Some(Self::SwimJump),
            "MOTION_STATE_SLIP" => Some(Self::Slip),
            "MOTION_STATE_GO_UPSTAIRS" => Some(Self::GoUpstairs),
            "MOTION_STATE_FALL_ON_GROUND" => Some(Self::FallOnGround),
            "MOTION_STATE_JUMP_UP_WALL_FOR_STANDBY" => Some(Self::JumpUpWallForStandby),
            "MOTION_STATE_JUMP_OFF_WALL" => Some(Self::JumpOffWall),
            "MOTION_STATE_POWERED_FLY" => Some(Self::PoweredFly),
            "MOTION_STATE_LADDER_IDLE" => Some(Self::LadderIdle),
            "MOTION_STATE_LADDER_MOVE" => Some(Self::LadderMove),
            "MOTION_STATE_LADDER_SLIP" => Some(Self::LadderSlip),
            "MOTION_STATE_STANDBY_TO_LADDER" => Some(Self::StandbyToLadder),
            "MOTION_STATE_LADDER_TO_STANDBY" => Some(Self::LadderToStandby),
            "MOTION_STATE_DANGER_STANDBY" => Some(Self::DangerStandby),
            "MOTION_STATE_DANGER_STANDBY_MOVE" => Some(Self::DangerStandbyMove),
            "MOTION_STATE_DANGER_WALK" => Some(Self::DangerWalk),
            "MOTION_STATE_DANGER_RUN" => Some(Self::DangerRun),
            "MOTION_STATE_DANGER_DASH" => Some(Self::DangerDash),
            "MOTION_STATE_CROUCH_IDLE" => Some(Self::CrouchIdle),
            "MOTION_STATE_CROUCH_MOVE" => Some(Self::CrouchMove),
            "MOTION_STATE_CROUCH_ROLL" => Some(Self::CrouchRoll),
            "MOTION_STATE_NOTIFY" => Some(Self::Notify),
            "MOTION_STATE_LAND_SPEED" => Some(Self::LandSpeed),
            "MOTION_STATE_MOVE_FAIL_ACK" => Some(Self::MoveFailAck),
            "MOTION_STATE_WATERFALL" => Some(Self::Waterfall),
            "MOTION_STATE_DASH_BEFORE_SHAKE" => Some(Self::DashBeforeShake),
            "MOTION_STATE_SIT_IDLE" => Some(Self::SitIdle),
            "MOTION_STATE_FORCE_SET_POS" => Some(Self::ForceSetPos),
            "MOTION_STATE_QUEST_FORCE_DRAG" => Some(Self::QuestForceDrag),
            "MOTION_STATE_FOLLOW_ROUTE" => Some(Self::FollowRoute),
            "MOTION_STATE_SKIFF_BOARDING" => Some(Self::SkiffBoarding),
            "MOTION_STATE_SKIFF_NORMAL" => Some(Self::SkiffNormal),
            "MOTION_STATE_SKIFF_DASH" => Some(Self::SkiffDash),
            "MOTION_STATE_SKIFF_POWERED_DASH" => Some(Self::SkiffPoweredDash),
            "MOTION_STATE_DESTROY_VEHICLE" => Some(Self::DestroyVehicle),
            "MOTION_STATE_FLY_IDLE" => Some(Self::FlyIdle),
            "MOTION_STATE_FLY_SLOW" => Some(Self::FlySlow),
            "MOTION_STATE_FLY_FAST" => Some(Self::FlyFast),
            "MOTION_STATE_AIM_MOVE" => Some(Self::AimMove),
            "MOTION_STATE_AIR_COMPENSATION" => Some(Self::AirCompensation),
            "MOTION_STATE_SORUSH_NORMAL" => Some(Self::SorushNormal),
            "MOTION_STATE_NUM" => Some(Self::Num),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtEntityType {
    None = 0,
    Avatar = 1,
    Monster = 2,
    Npc = 3,
    Gadget = 4,
    Region = 5,
    Weapon = 6,
    Weather = 7,
    Scene = 8,
    Team = 9,
    MassiveEntity = 10,
    MpLevel = 11,
    PlayTeamEntity = 12,
    EyePoint = 13,
    Max = 14,
}
impl ProtEntityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PROT_ENTITY_TYPE_NONE",
            Self::Avatar => "PROT_ENTITY_TYPE_AVATAR",
            Self::Monster => "PROT_ENTITY_TYPE_MONSTER",
            Self::Npc => "PROT_ENTITY_TYPE_NPC",
            Self::Gadget => "PROT_ENTITY_TYPE_GADGET",
            Self::Region => "PROT_ENTITY_TYPE_REGION",
            Self::Weapon => "PROT_ENTITY_TYPE_WEAPON",
            Self::Weather => "PROT_ENTITY_TYPE_WEATHER",
            Self::Scene => "PROT_ENTITY_TYPE_SCENE",
            Self::Team => "PROT_ENTITY_TYPE_TEAM",
            Self::MassiveEntity => "PROT_ENTITY_TYPE_MASSIVE_ENTITY",
            Self::MpLevel => "PROT_ENTITY_TYPE_MP_LEVEL",
            Self::PlayTeamEntity => "PROT_ENTITY_TYPE_PLAY_TEAM_ENTITY",
            Self::EyePoint => "PROT_ENTITY_TYPE_EYE_POINT",
            Self::Max => "PROT_ENTITY_TYPE_MAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROT_ENTITY_TYPE_NONE" => Some(Self::None),
            "PROT_ENTITY_TYPE_AVATAR" => Some(Self::Avatar),
            "PROT_ENTITY_TYPE_MONSTER" => Some(Self::Monster),
            "PROT_ENTITY_TYPE_NPC" => Some(Self::Npc),
            "PROT_ENTITY_TYPE_GADGET" => Some(Self::Gadget),
            "PROT_ENTITY_TYPE_REGION" => Some(Self::Region),
            "PROT_ENTITY_TYPE_WEAPON" => Some(Self::Weapon),
            "PROT_ENTITY_TYPE_WEATHER" => Some(Self::Weather),
            "PROT_ENTITY_TYPE_SCENE" => Some(Self::Scene),
            "PROT_ENTITY_TYPE_TEAM" => Some(Self::Team),
            "PROT_ENTITY_TYPE_MASSIVE_ENTITY" => Some(Self::MassiveEntity),
            "PROT_ENTITY_TYPE_MP_LEVEL" => Some(Self::MpLevel),
            "PROT_ENTITY_TYPE_PLAY_TEAM_ENTITY" => Some(Self::PlayTeamEntity),
            "PROT_ENTITY_TYPE_EYE_POINT" => Some(Self::EyePoint),
            "PROT_ENTITY_TYPE_MAX" => Some(Self::Max),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MonsterBornType {
    None = 0,
    Default = 1,
    Random = 2,
}
impl MonsterBornType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MONSTER_BORN_TYPE_NONE",
            Self::Default => "MONSTER_BORN_TYPE_DEFAULT",
            Self::Random => "MONSTER_BORN_TYPE_RANDOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MONSTER_BORN_TYPE_NONE" => Some(Self::None),
            "MONSTER_BORN_TYPE_DEFAULT" => Some(Self::Default),
            "MONSTER_BORN_TYPE_RANDOM" => Some(Self::Random),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GadgetBornType {
    None = 0,
    InAir = 1,
    Player = 2,
    MonsterHit = 3,
    MonsterDie = 4,
    Gadget = 5,
    Ground = 6,
}
impl GadgetBornType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GADGET_BORN_TYPE_NONE",
            Self::InAir => "GADGET_BORN_TYPE_IN_AIR",
            Self::Player => "GADGET_BORN_TYPE_PLAYER",
            Self::MonsterHit => "GADGET_BORN_TYPE_MONSTER_HIT",
            Self::MonsterDie => "GADGET_BORN_TYPE_MONSTER_DIE",
            Self::Gadget => "GADGET_BORN_TYPE_GADGET",
            Self::Ground => "GADGET_BORN_TYPE_GROUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GADGET_BORN_TYPE_NONE" => Some(Self::None),
            "GADGET_BORN_TYPE_IN_AIR" => Some(Self::InAir),
            "GADGET_BORN_TYPE_PLAYER" => Some(Self::Player),
            "GADGET_BORN_TYPE_MONSTER_HIT" => Some(Self::MonsterHit),
            "GADGET_BORN_TYPE_MONSTER_DIE" => Some(Self::MonsterDie),
            "GADGET_BORN_TYPE_GADGET" => Some(Self::Gadget),
            "GADGET_BORN_TYPE_GROUND" => Some(Self::Ground),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MovingPlatformType {
    None = 0,
    UseConfig = 1,
    Ability = 2,
    Route = 3,
}
impl MovingPlatformType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MOVING_PLATFORM_TYPE_NONE",
            Self::UseConfig => "MOVING_PLATFORM_TYPE_USE_CONFIG",
            Self::Ability => "MOVING_PLATFORM_TYPE_ABILITY",
            Self::Route => "MOVING_PLATFORM_TYPE_ROUTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MOVING_PLATFORM_TYPE_NONE" => Some(Self::None),
            "MOVING_PLATFORM_TYPE_USE_CONFIG" => Some(Self::UseConfig),
            "MOVING_PLATFORM_TYPE_ABILITY" => Some(Self::Ability),
            "MOVING_PLATFORM_TYPE_ROUTE" => Some(Self::Route),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FoundationStatus {
    None = 0,
    Init = 1,
    Building = 2,
    Built = 3,
}
impl FoundationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FOUNDATION_STATUS_NONE",
            Self::Init => "FOUNDATION_STATUS_INIT",
            Self::Building => "FOUNDATION_STATUS_BUILDING",
            Self::Built => "FOUNDATION_STATUS_BUILT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FOUNDATION_STATUS_NONE" => Some(Self::None),
            "FOUNDATION_STATUS_INIT" => Some(Self::Init),
            "FOUNDATION_STATUS_BUILDING" => Some(Self::Building),
            "FOUNDATION_STATUS_BUILT" => Some(Self::Built),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeHpReason {
    None = 0,
    SubAvatar = 1,
    SubMonster = 2,
    SubGear = 3,
    SubEnvir = 4,
    SubFall = 5,
    SubDrawn = 6,
    SubAbyss = 7,
    SubAbility = 8,
    SubSummon = 9,
    SubScript = 10,
    SubGm = 11,
    SubKillSelf = 12,
    SubClimateCold = 13,
    SubStormLightning = 14,
    SubKillServerGadget = 15,
    SubReplace = 16,
    SubPlayerLeave = 17,
    AttackByEnergy = 18,
    AttackByRecycle = 19,
    SubPlayerBack = 20,
    SubUgc = 21,
    ByLua = 51,
    AddAbility = 101,
    AddItem = 102,
    AddRevive = 103,
    AddUpgrade = 104,
    AddStatue = 105,
    AddBackground = 106,
    AddGm = 107,
    AddTrialAvatarActivity = 108,
    AddRoguelikeSpring = 109,
}
impl ChangeHpReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CHANGE_HP_REASON_NONE",
            Self::SubAvatar => "CHANGE_HP_REASON_SUB_AVATAR",
            Self::SubMonster => "CHANGE_HP_REASON_SUB_MONSTER",
            Self::SubGear => "CHANGE_HP_REASON_SUB_GEAR",
            Self::SubEnvir => "CHANGE_HP_REASON_SUB_ENVIR",
            Self::SubFall => "CHANGE_HP_REASON_SUB_FALL",
            Self::SubDrawn => "CHANGE_HP_REASON_SUB_DRAWN",
            Self::SubAbyss => "CHANGE_HP_REASON_SUB_ABYSS",
            Self::SubAbility => "CHANGE_HP_REASON_SUB_ABILITY",
            Self::SubSummon => "CHANGE_HP_REASON_SUB_SUMMON",
            Self::SubScript => "CHANGE_HP_REASON_SUB_SCRIPT",
            Self::SubGm => "CHANGE_HP_REASON_SUB_GM",
            Self::SubKillSelf => "CHANGE_HP_REASON_SUB_KILL_SELF",
            Self::SubClimateCold => "CHANGE_HP_REASON_SUB_CLIMATE_COLD",
            Self::SubStormLightning => "CHANGE_HP_REASON_SUB_STORM_LIGHTNING",
            Self::SubKillServerGadget => "CHANGE_HP_REASON_SUB_KILL_SERVER_GADGET",
            Self::SubReplace => "CHANGE_HP_REASON_SUB_REPLACE",
            Self::SubPlayerLeave => "CHANGE_HP_REASON_SUB_PLAYER_LEAVE",
            Self::AttackByEnergy => "CHANGE_HP_REASON_ATTACK_BY_ENERGY",
            Self::AttackByRecycle => "CHANGE_HP_REASON_ATTACK_BY_RECYCLE",
            Self::SubPlayerBack => "CHANGE_HP_REASON_SUB_PLAYER_BACK",
            Self::SubUgc => "CHANGE_HP_REASON_SUB_UGC",
            Self::ByLua => "CHANGE_HP_REASON_BY_LUA",
            Self::AddAbility => "CHANGE_HP_REASON_ADD_ABILITY",
            Self::AddItem => "CHANGE_HP_REASON_ADD_ITEM",
            Self::AddRevive => "CHANGE_HP_REASON_ADD_REVIVE",
            Self::AddUpgrade => "CHANGE_HP_REASON_ADD_UPGRADE",
            Self::AddStatue => "CHANGE_HP_REASON_ADD_STATUE",
            Self::AddBackground => "CHANGE_HP_REASON_ADD_BACKGROUND",
            Self::AddGm => "CHANGE_HP_REASON_ADD_GM",
            Self::AddTrialAvatarActivity => "CHANGE_HP_REASON_ADD_TRIAL_AVATAR_ACTIVITY",
            Self::AddRoguelikeSpring => "CHANGE_HP_REASON_ADD_ROGUELIKE_SPRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_HP_REASON_NONE" => Some(Self::None),
            "CHANGE_HP_REASON_SUB_AVATAR" => Some(Self::SubAvatar),
            "CHANGE_HP_REASON_SUB_MONSTER" => Some(Self::SubMonster),
            "CHANGE_HP_REASON_SUB_GEAR" => Some(Self::SubGear),
            "CHANGE_HP_REASON_SUB_ENVIR" => Some(Self::SubEnvir),
            "CHANGE_HP_REASON_SUB_FALL" => Some(Self::SubFall),
            "CHANGE_HP_REASON_SUB_DRAWN" => Some(Self::SubDrawn),
            "CHANGE_HP_REASON_SUB_ABYSS" => Some(Self::SubAbyss),
            "CHANGE_HP_REASON_SUB_ABILITY" => Some(Self::SubAbility),
            "CHANGE_HP_REASON_SUB_SUMMON" => Some(Self::SubSummon),
            "CHANGE_HP_REASON_SUB_SCRIPT" => Some(Self::SubScript),
            "CHANGE_HP_REASON_SUB_GM" => Some(Self::SubGm),
            "CHANGE_HP_REASON_SUB_KILL_SELF" => Some(Self::SubKillSelf),
            "CHANGE_HP_REASON_SUB_CLIMATE_COLD" => Some(Self::SubClimateCold),
            "CHANGE_HP_REASON_SUB_STORM_LIGHTNING" => Some(Self::SubStormLightning),
            "CHANGE_HP_REASON_SUB_KILL_SERVER_GADGET" => Some(Self::SubKillServerGadget),
            "CHANGE_HP_REASON_SUB_REPLACE" => Some(Self::SubReplace),
            "CHANGE_HP_REASON_SUB_PLAYER_LEAVE" => Some(Self::SubPlayerLeave),
            "CHANGE_HP_REASON_ATTACK_BY_ENERGY" => Some(Self::AttackByEnergy),
            "CHANGE_HP_REASON_ATTACK_BY_RECYCLE" => Some(Self::AttackByRecycle),
            "CHANGE_HP_REASON_SUB_PLAYER_BACK" => Some(Self::SubPlayerBack),
            "CHANGE_HP_REASON_SUB_UGC" => Some(Self::SubUgc),
            "CHANGE_HP_REASON_BY_LUA" => Some(Self::ByLua),
            "CHANGE_HP_REASON_ADD_ABILITY" => Some(Self::AddAbility),
            "CHANGE_HP_REASON_ADD_ITEM" => Some(Self::AddItem),
            "CHANGE_HP_REASON_ADD_REVIVE" => Some(Self::AddRevive),
            "CHANGE_HP_REASON_ADD_UPGRADE" => Some(Self::AddUpgrade),
            "CHANGE_HP_REASON_ADD_STATUE" => Some(Self::AddStatue),
            "CHANGE_HP_REASON_ADD_BACKGROUND" => Some(Self::AddBackground),
            "CHANGE_HP_REASON_ADD_GM" => Some(Self::AddGm),
            "CHANGE_HP_REASON_ADD_TRIAL_AVATAR_ACTIVITY" => {
                Some(Self::AddTrialAvatarActivity)
            }
            "CHANGE_HP_REASON_ADD_ROGUELIKE_SPRING" => Some(Self::AddRoguelikeSpring),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerDieType {
    None = 0,
    KillByMonster = 1,
    KillByGear = 2,
    Fall = 3,
    Drawn = 4,
    Abyss = 5,
    Gm = 6,
    ClimateCold = 7,
    StormLighting = 8,
}
impl PlayerDieType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PLAYER_DIE_TYPE_NONE",
            Self::KillByMonster => "PLAYER_DIE_TYPE_KILL_BY_MONSTER",
            Self::KillByGear => "PLAYER_DIE_TYPE_KILL_BY_GEAR",
            Self::Fall => "PLAYER_DIE_TYPE_FALL",
            Self::Drawn => "PLAYER_DIE_TYPE_DRAWN",
            Self::Abyss => "PLAYER_DIE_TYPE_ABYSS",
            Self::Gm => "PLAYER_DIE_TYPE_GM",
            Self::ClimateCold => "PLAYER_DIE_TYPE_CLIMATE_COLD",
            Self::StormLighting => "PLAYER_DIE_TYPE_STORM_LIGHTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAYER_DIE_TYPE_NONE" => Some(Self::None),
            "PLAYER_DIE_TYPE_KILL_BY_MONSTER" => Some(Self::KillByMonster),
            "PLAYER_DIE_TYPE_KILL_BY_GEAR" => Some(Self::KillByGear),
            "PLAYER_DIE_TYPE_FALL" => Some(Self::Fall),
            "PLAYER_DIE_TYPE_DRAWN" => Some(Self::Drawn),
            "PLAYER_DIE_TYPE_ABYSS" => Some(Self::Abyss),
            "PLAYER_DIE_TYPE_GM" => Some(Self::Gm),
            "PLAYER_DIE_TYPE_CLIMATE_COLD" => Some(Self::ClimateCold),
            "PLAYER_DIE_TYPE_STORM_LIGHTING" => Some(Self::StormLighting),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerDieOption {
    OptNone = 0,
    OptReplay = 1,
    OptCancel = 2,
    OptRevive = 3,
}
impl PlayerDieOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OptNone => "PLAYER_DIE_OPTION_OPT_NONE",
            Self::OptReplay => "PLAYER_DIE_OPTION_OPT_REPLAY",
            Self::OptCancel => "PLAYER_DIE_OPTION_OPT_CANCEL",
            Self::OptRevive => "PLAYER_DIE_OPTION_OPT_REVIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAYER_DIE_OPTION_OPT_NONE" => Some(Self::OptNone),
            "PLAYER_DIE_OPTION_OPT_REPLAY" => Some(Self::OptReplay),
            "PLAYER_DIE_OPTION_OPT_CANCEL" => Some(Self::OptCancel),
            "PLAYER_DIE_OPTION_OPT_REVIVE" => Some(Self::OptRevive),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FetterState {
    None = 0,
    NotOpen = 1,
    Open = 2,
    Finish = 3,
    Conceal = 4,
}
impl FetterState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FETTER_STATE_NONE",
            Self::NotOpen => "FETTER_STATE_NOT_OPEN",
            Self::Open => "FETTER_STATE_OPEN",
            Self::Finish => "FETTER_STATE_FINISH",
            Self::Conceal => "FETTER_STATE_CONCEAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FETTER_STATE_NONE" => Some(Self::None),
            "FETTER_STATE_NOT_OPEN" => Some(Self::NotOpen),
            "FETTER_STATE_OPEN" => Some(Self::Open),
            "FETTER_STATE_FINISH" => Some(Self::Finish),
            "FETTER_STATE_CONCEAL" => Some(Self::Conceal),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AvatarExpeditionState {
    None = 0,
    Doing = 1,
    FinishWaitReward = 2,
    CallbackWaitReward = 3,
    Locked = 4,
}
impl AvatarExpeditionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AVATAR_EXPEDITION_STATE_NONE",
            Self::Doing => "AVATAR_EXPEDITION_STATE_DOING",
            Self::FinishWaitReward => "AVATAR_EXPEDITION_STATE_FINISH_WAIT_REWARD",
            Self::CallbackWaitReward => "AVATAR_EXPEDITION_STATE_CALLBACK_WAIT_REWARD",
            Self::Locked => "AVATAR_EXPEDITION_STATE_LOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AVATAR_EXPEDITION_STATE_NONE" => Some(Self::None),
            "AVATAR_EXPEDITION_STATE_DOING" => Some(Self::Doing),
            "AVATAR_EXPEDITION_STATE_FINISH_WAIT_REWARD" => Some(Self::FinishWaitReward),
            "AVATAR_EXPEDITION_STATE_CALLBACK_WAIT_REWARD" => {
                Some(Self::CallbackWaitReward)
            }
            "AVATAR_EXPEDITION_STATE_LOCKED" => Some(Self::Locked),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AvatarType {
    None = 0,
    Formal = 1,
    Trial = 2,
    Mirror = 3,
}
impl AvatarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AVATAR_TYPE_NONE",
            Self::Formal => "AVATAR_TYPE_FORMAL",
            Self::Trial => "AVATAR_TYPE_TRIAL",
            Self::Mirror => "AVATAR_TYPE_MIRROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AVATAR_TYPE_NONE" => Some(Self::None),
            "AVATAR_TYPE_FORMAL" => Some(Self::Formal),
            "AVATAR_TYPE_TRIAL" => Some(Self::Trial),
            "AVATAR_TYPE_MIRROR" => Some(Self::Mirror),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventTriggerType {
    None = 0,
    EnterForce = 1,
}
impl EventTriggerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "EVENT_TRIGGER_TYPE_NONE",
            Self::EnterForce => "EVENT_TRIGGER_TYPE_ENTER_FORCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TRIGGER_TYPE_NONE" => Some(Self::None),
            "EVENT_TRIGGER_TYPE_ENTER_FORCE" => Some(Self::EnterForce),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MailCollectState {
    CollectibleUnkonw = 0,
    NotCollectible = 1,
    CollectibleUncollected = 2,
    CollectibleCollected = 3,
}
impl MailCollectState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CollectibleUnkonw => "MAIL_COLLECT_STATE_COLLECTIBLE_UNKONW",
            Self::NotCollectible => "MAIL_COLLECT_STATE_NOT_COLLECTIBLE",
            Self::CollectibleUncollected => "MAIL_COLLECT_STATE_COLLECTIBLE_UNCOLLECTED",
            Self::CollectibleCollected => "MAIL_COLLECT_STATE_COLLECTIBLE_COLLECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAIL_COLLECT_STATE_COLLECTIBLE_UNKONW" => Some(Self::CollectibleUnkonw),
            "MAIL_COLLECT_STATE_NOT_COLLECTIBLE" => Some(Self::NotCollectible),
            "MAIL_COLLECT_STATE_COLLECTIBLE_UNCOLLECTED" => {
                Some(Self::CollectibleUncollected)
            }
            "MAIL_COLLECT_STATE_COLLECTIBLE_COLLECTED" => {
                Some(Self::CollectibleCollected)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MpSettingType {
    NoEnter = 0,
    EnterFreely = 1,
    EnterAfterApply = 2,
}
impl MpSettingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoEnter => "MP_SETTING_TYPE_NO_ENTER",
            Self::EnterFreely => "MP_SETTING_TYPE_ENTER_FREELY",
            Self::EnterAfterApply => "MP_SETTING_TYPE_ENTER_AFTER_APPLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MP_SETTING_TYPE_NO_ENTER" => Some(Self::NoEnter),
            "MP_SETTING_TYPE_ENTER_FREELY" => Some(Self::EnterFreely),
            "MP_SETTING_TYPE_ENTER_AFTER_APPLY" => Some(Self::EnterAfterApply),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LanguageType {
    None = 0,
    En = 1,
    Sc = 2,
    Tc = 3,
    Fr = 4,
    De = 5,
    Es = 6,
    Pt = 7,
    Ru = 8,
    Jp = 9,
    Kr = 10,
    Th = 11,
    Vn = 12,
    Id = 13,
    Tr = 14,
    It = 15,
}
impl LanguageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "LANGUAGE_TYPE_NONE",
            Self::En => "LANGUAGE_TYPE_EN",
            Self::Sc => "LANGUAGE_TYPE_SC",
            Self::Tc => "LANGUAGE_TYPE_TC",
            Self::Fr => "LANGUAGE_TYPE_FR",
            Self::De => "LANGUAGE_TYPE_DE",
            Self::Es => "LANGUAGE_TYPE_ES",
            Self::Pt => "LANGUAGE_TYPE_PT",
            Self::Ru => "LANGUAGE_TYPE_RU",
            Self::Jp => "LANGUAGE_TYPE_JP",
            Self::Kr => "LANGUAGE_TYPE_KR",
            Self::Th => "LANGUAGE_TYPE_TH",
            Self::Vn => "LANGUAGE_TYPE_VN",
            Self::Id => "LANGUAGE_TYPE_ID",
            Self::Tr => "LANGUAGE_TYPE_TR",
            Self::It => "LANGUAGE_TYPE_IT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LANGUAGE_TYPE_NONE" => Some(Self::None),
            "LANGUAGE_TYPE_EN" => Some(Self::En),
            "LANGUAGE_TYPE_SC" => Some(Self::Sc),
            "LANGUAGE_TYPE_TC" => Some(Self::Tc),
            "LANGUAGE_TYPE_FR" => Some(Self::Fr),
            "LANGUAGE_TYPE_DE" => Some(Self::De),
            "LANGUAGE_TYPE_ES" => Some(Self::Es),
            "LANGUAGE_TYPE_PT" => Some(Self::Pt),
            "LANGUAGE_TYPE_RU" => Some(Self::Ru),
            "LANGUAGE_TYPE_JP" => Some(Self::Jp),
            "LANGUAGE_TYPE_KR" => Some(Self::Kr),
            "LANGUAGE_TYPE_TH" => Some(Self::Th),
            "LANGUAGE_TYPE_VN" => Some(Self::Vn),
            "LANGUAGE_TYPE_ID" => Some(Self::Id),
            "LANGUAGE_TYPE_TR" => Some(Self::Tr),
            "LANGUAGE_TYPE_IT" => Some(Self::It),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlatformType {
    Editor = 0,
    Ios = 1,
    Android = 2,
    Pc = 3,
    Ps4 = 4,
    Server = 5,
    CloudAndroid = 6,
    CloudIos = 7,
    Ps5 = 8,
    CloudWeb = 9,
    CloudTv = 10,
    CloudMac = 11,
    CloudPc = 12,
    CloudThirdPartyMobile = 13,
    CloudThirdPartyPc = 14,
}
impl PlatformType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Editor => "PLATFORM_TYPE_EDITOR",
            Self::Ios => "PLATFORM_TYPE_IOS",
            Self::Android => "PLATFORM_TYPE_ANDROID",
            Self::Pc => "PLATFORM_TYPE_PC",
            Self::Ps4 => "PLATFORM_TYPE_PS4",
            Self::Server => "PLATFORM_TYPE_SERVER",
            Self::CloudAndroid => "PLATFORM_TYPE_CLOUD_ANDROID",
            Self::CloudIos => "PLATFORM_TYPE_CLOUD_IOS",
            Self::Ps5 => "PLATFORM_TYPE_PS5",
            Self::CloudWeb => "PLATFORM_TYPE_CLOUD_WEB",
            Self::CloudTv => "PLATFORM_TYPE_CLOUD_TV",
            Self::CloudMac => "PLATFORM_TYPE_CLOUD_MAC",
            Self::CloudPc => "PLATFORM_TYPE_CLOUD_PC",
            Self::CloudThirdPartyMobile => "PLATFORM_TYPE_CLOUD_THIRD_PARTY_MOBILE",
            Self::CloudThirdPartyPc => "PLATFORM_TYPE_CLOUD_THIRD_PARTY_PC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLATFORM_TYPE_EDITOR" => Some(Self::Editor),
            "PLATFORM_TYPE_IOS" => Some(Self::Ios),
            "PLATFORM_TYPE_ANDROID" => Some(Self::Android),
            "PLATFORM_TYPE_PC" => Some(Self::Pc),
            "PLATFORM_TYPE_PS4" => Some(Self::Ps4),
            "PLATFORM_TYPE_SERVER" => Some(Self::Server),
            "PLATFORM_TYPE_CLOUD_ANDROID" => Some(Self::CloudAndroid),
            "PLATFORM_TYPE_CLOUD_IOS" => Some(Self::CloudIos),
            "PLATFORM_TYPE_PS5" => Some(Self::Ps5),
            "PLATFORM_TYPE_CLOUD_WEB" => Some(Self::CloudWeb),
            "PLATFORM_TYPE_CLOUD_TV" => Some(Self::CloudTv),
            "PLATFORM_TYPE_CLOUD_MAC" => Some(Self::CloudMac),
            "PLATFORM_TYPE_CLOUD_PC" => Some(Self::CloudPc),
            "PLATFORM_TYPE_CLOUD_THIRD_PARTY_MOBILE" => Some(Self::CloudThirdPartyMobile),
            "PLATFORM_TYPE_CLOUD_THIRD_PARTY_PC" => Some(Self::CloudThirdPartyPc),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MapMarkPointType {
    Npc = 0,
    Quest = 1,
    Special = 2,
    Mine = 3,
    Collection = 4,
    Monster = 5,
    FishPool = 6,
}
impl MapMarkPointType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Npc => "MAP_MARK_POINT_TYPE_NPC",
            Self::Quest => "MAP_MARK_POINT_TYPE_QUEST",
            Self::Special => "MAP_MARK_POINT_TYPE_SPECIAL",
            Self::Mine => "MAP_MARK_POINT_TYPE_MINE",
            Self::Collection => "MAP_MARK_POINT_TYPE_COLLECTION",
            Self::Monster => "MAP_MARK_POINT_TYPE_MONSTER",
            Self::FishPool => "MAP_MARK_POINT_TYPE_FISH_POOL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAP_MARK_POINT_TYPE_NPC" => Some(Self::Npc),
            "MAP_MARK_POINT_TYPE_QUEST" => Some(Self::Quest),
            "MAP_MARK_POINT_TYPE_SPECIAL" => Some(Self::Special),
            "MAP_MARK_POINT_TYPE_MINE" => Some(Self::Mine),
            "MAP_MARK_POINT_TYPE_COLLECTION" => Some(Self::Collection),
            "MAP_MARK_POINT_TYPE_MONSTER" => Some(Self::Monster),
            "MAP_MARK_POINT_TYPE_FISH_POOL" => Some(Self::FishPool),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MapMarkFromType {
    None = 0,
    Monster = 1,
    Quest = 2,
}
impl MapMarkFromType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MAP_MARK_FROM_TYPE_NONE",
            Self::Monster => "MAP_MARK_FROM_TYPE_MONSTER",
            Self::Quest => "MAP_MARK_FROM_TYPE_QUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAP_MARK_FROM_TYPE_NONE" => Some(Self::None),
            "MAP_MARK_FROM_TYPE_MONSTER" => Some(Self::Monster),
            "MAP_MARK_FROM_TYPE_QUEST" => Some(Self::Quest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchType {
    None = 0,
    Dungeon = 1,
    MpPlay = 2,
    Mechanicus = 3,
    General = 4,
    Gcg = 5,
}
impl MatchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MATCH_TYPE_NONE",
            Self::Dungeon => "MATCH_TYPE_DUNGEON",
            Self::MpPlay => "MATCH_TYPE_MP_PLAY",
            Self::Mechanicus => "MATCH_TYPE_MECHANICUS",
            Self::General => "MATCH_TYPE_GENERAL",
            Self::Gcg => "MATCH_TYPE_GCG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_TYPE_NONE" => Some(Self::None),
            "MATCH_TYPE_DUNGEON" => Some(Self::Dungeon),
            "MATCH_TYPE_MP_PLAY" => Some(Self::MpPlay),
            "MATCH_TYPE_MECHANICUS" => Some(Self::Mechanicus),
            "MATCH_TYPE_GENERAL" => Some(Self::General),
            "MATCH_TYPE_GCG" => Some(Self::Gcg),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchReason {
    None = 0,
    Finish = 1,
    PlayerCancel = 2,
    Timeout = 3,
    PlayerConfirm = 4,
    Failed = 5,
    SystemError = 6,
    Interrupted = 7,
    MpUnavailable = 8,
    ConfirmTimeout = 9,
}
impl MatchReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MATCH_REASON_NONE",
            Self::Finish => "MATCH_REASON_FINISH",
            Self::PlayerCancel => "MATCH_REASON_PLAYER_CANCEL",
            Self::Timeout => "MATCH_REASON_TIMEOUT",
            Self::PlayerConfirm => "MATCH_REASON_PLAYER_CONFIRM",
            Self::Failed => "MATCH_REASON_FAILED",
            Self::SystemError => "MATCH_REASON_SYSTEM_ERROR",
            Self::Interrupted => "MATCH_REASON_INTERRUPTED",
            Self::MpUnavailable => "MATCH_REASON_MP_UNAVAILABLE",
            Self::ConfirmTimeout => "MATCH_REASON_CONFIRM_TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_REASON_NONE" => Some(Self::None),
            "MATCH_REASON_FINISH" => Some(Self::Finish),
            "MATCH_REASON_PLAYER_CANCEL" => Some(Self::PlayerCancel),
            "MATCH_REASON_TIMEOUT" => Some(Self::Timeout),
            "MATCH_REASON_PLAYER_CONFIRM" => Some(Self::PlayerConfirm),
            "MATCH_REASON_FAILED" => Some(Self::Failed),
            "MATCH_REASON_SYSTEM_ERROR" => Some(Self::SystemError),
            "MATCH_REASON_INTERRUPTED" => Some(Self::Interrupted),
            "MATCH_REASON_MP_UNAVAILABLE" => Some(Self::MpUnavailable),
            "MATCH_REASON_CONFIRM_TIMEOUT" => Some(Self::ConfirmTimeout),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LuaShellType {
    LuashellNone = 0,
    LuashellNormal = 1,
    LuashellSecurity = 2,
    LuashellShellCode = 3,
}
impl LuaShellType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LuashellNone => "LUA_SHELL_TYPE_LUASHELL_NONE",
            Self::LuashellNormal => "LUA_SHELL_TYPE_LUASHELL_NORMAL",
            Self::LuashellSecurity => "LUA_SHELL_TYPE_LUASHELL_SECURITY",
            Self::LuashellShellCode => "LUA_SHELL_TYPE_LUASHELL_SHELL_CODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LUA_SHELL_TYPE_LUASHELL_NONE" => Some(Self::LuashellNone),
            "LUA_SHELL_TYPE_LUASHELL_NORMAL" => Some(Self::LuashellNormal),
            "LUA_SHELL_TYPE_LUASHELL_SECURITY" => Some(Self::LuashellSecurity),
            "LUA_SHELL_TYPE_LUASHELL_SHELL_CODE" => Some(Self::LuashellShellCode),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SalesmanStatusType {
    None = 0,
    Unstarted = 1,
    Started = 2,
    Delivered = 3,
}
impl SalesmanStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SALESMAN_STATUS_TYPE_NONE",
            Self::Unstarted => "SALESMAN_STATUS_TYPE_UNSTARTED",
            Self::Started => "SALESMAN_STATUS_TYPE_STARTED",
            Self::Delivered => "SALESMAN_STATUS_TYPE_DELIVERED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SALESMAN_STATUS_TYPE_NONE" => Some(Self::None),
            "SALESMAN_STATUS_TYPE_UNSTARTED" => Some(Self::Unstarted),
            "SALESMAN_STATUS_TYPE_STARTED" => Some(Self::Started),
            "SALESMAN_STATUS_TYPE_DELIVERED" => Some(Self::Delivered),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CodexType {
    None = 0,
    Quest = 1,
    Weapon = 2,
    Animal = 3,
    Material = 4,
    Books = 5,
    Pushtips = 6,
    View = 7,
    Reliquary = 8,
}
impl CodexType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CODEX_TYPE_NONE",
            Self::Quest => "CODEX_TYPE_QUEST",
            Self::Weapon => "CODEX_TYPE_WEAPON",
            Self::Animal => "CODEX_TYPE_ANIMAL",
            Self::Material => "CODEX_TYPE_MATERIAL",
            Self::Books => "CODEX_TYPE_BOOKS",
            Self::Pushtips => "CODEX_TYPE_PUSHTIPS",
            Self::View => "CODEX_TYPE_VIEW",
            Self::Reliquary => "CODEX_TYPE_RELIQUARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CODEX_TYPE_NONE" => Some(Self::None),
            "CODEX_TYPE_QUEST" => Some(Self::Quest),
            "CODEX_TYPE_WEAPON" => Some(Self::Weapon),
            "CODEX_TYPE_ANIMAL" => Some(Self::Animal),
            "CODEX_TYPE_MATERIAL" => Some(Self::Material),
            "CODEX_TYPE_BOOKS" => Some(Self::Books),
            "CODEX_TYPE_PUSHTIPS" => Some(Self::Pushtips),
            "CODEX_TYPE_VIEW" => Some(Self::View),
            "CODEX_TYPE_RELIQUARY" => Some(Self::Reliquary),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AsterLittleStageState {
    None = 0,
    Unstarted = 1,
    Started = 2,
    Finished = 3,
}
impl AsterLittleStageState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ASTER_LITTLE_STAGE_STATE_NONE",
            Self::Unstarted => "ASTER_LITTLE_STAGE_STATE_UNSTARTED",
            Self::Started => "ASTER_LITTLE_STAGE_STATE_STARTED",
            Self::Finished => "ASTER_LITTLE_STAGE_STATE_FINISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASTER_LITTLE_STAGE_STATE_NONE" => Some(Self::None),
            "ASTER_LITTLE_STAGE_STATE_UNSTARTED" => Some(Self::Unstarted),
            "ASTER_LITTLE_STAGE_STATE_STARTED" => Some(Self::Started),
            "ASTER_LITTLE_STAGE_STATE_FINISHED" => Some(Self::Finished),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HuntingOfferState {
    None = 0,
    Started = 1,
    Unstarted = 2,
    Succ = 3,
}
impl HuntingOfferState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "HUNTING_OFFER_STATE_NONE",
            Self::Started => "HUNTING_OFFER_STATE_STARTED",
            Self::Unstarted => "HUNTING_OFFER_STATE_UNSTARTED",
            Self::Succ => "HUNTING_OFFER_STATE_SUCC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HUNTING_OFFER_STATE_NONE" => Some(Self::None),
            "HUNTING_OFFER_STATE_STARTED" => Some(Self::Started),
            "HUNTING_OFFER_STATE_UNSTARTED" => Some(Self::Unstarted),
            "HUNTING_OFFER_STATE_SUCC" => Some(Self::Succ),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RegionSearchState {
    None = 0,
    Unstarted = 1,
    Started = 2,
    WaitReward = 3,
    Finished = 4,
}
impl RegionSearchState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "REGION_SEARCH_STATE_NONE",
            Self::Unstarted => "REGION_SEARCH_STATE_UNSTARTED",
            Self::Started => "REGION_SEARCH_STATE_STARTED",
            Self::WaitReward => "REGION_SEARCH_STATE_WAIT_REWARD",
            Self::Finished => "REGION_SEARCH_STATE_FINISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGION_SEARCH_STATE_NONE" => Some(Self::None),
            "REGION_SEARCH_STATE_UNSTARTED" => Some(Self::Unstarted),
            "REGION_SEARCH_STATE_STARTED" => Some(Self::Started),
            "REGION_SEARCH_STATE_WAIT_REWARD" => Some(Self::WaitReward),
            "REGION_SEARCH_STATE_FINISHED" => Some(Self::Finished),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReportReasonType {
    None = 0,
    DeceptiveAds = 1,
    Abusing = 2,
    Cheat = 3,
    Political = 4,
    Other = 5,
    Home = 6,
}
impl ReportReasonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "REPORT_REASON_TYPE_NONE",
            Self::DeceptiveAds => "REPORT_REASON_TYPE_DECEPTIVE_ADS",
            Self::Abusing => "REPORT_REASON_TYPE_ABUSING",
            Self::Cheat => "REPORT_REASON_TYPE_CHEAT",
            Self::Political => "REPORT_REASON_TYPE_POLITICAL",
            Self::Other => "REPORT_REASON_TYPE_OTHER",
            Self::Home => "REPORT_REASON_TYPE_HOME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPORT_REASON_TYPE_NONE" => Some(Self::None),
            "REPORT_REASON_TYPE_DECEPTIVE_ADS" => Some(Self::DeceptiveAds),
            "REPORT_REASON_TYPE_ABUSING" => Some(Self::Abusing),
            "REPORT_REASON_TYPE_CHEAT" => Some(Self::Cheat),
            "REPORT_REASON_TYPE_POLITICAL" => Some(Self::Political),
            "REPORT_REASON_TYPE_OTHER" => Some(Self::Other),
            "REPORT_REASON_TYPE_HOME" => Some(Self::Home),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReportSubtype {
    ReasonSubtypeNone = 0,
    ReasonSubtypeInvalidNickname = 1,
    ReasonSubtypeInvalidSignature = 2,
    ReasonSubtypeInvalidArrangement = 3,
    ReasonSubtypeInvalidChat = 4,
    ReasonSubtypeInvalidAvatarName = 5,
    ReasonSubtypeInvalidOther = 6,
}
impl ReportSubtype {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReasonSubtypeNone => "REPORT_SUBTYPE_REASON_SUBTYPE_NONE",
            Self::ReasonSubtypeInvalidNickname => {
                "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_NICKNAME"
            }
            Self::ReasonSubtypeInvalidSignature => {
                "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_SIGNATURE"
            }
            Self::ReasonSubtypeInvalidArrangement => {
                "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_ARRANGEMENT"
            }
            Self::ReasonSubtypeInvalidChat => {
                "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_CHAT"
            }
            Self::ReasonSubtypeInvalidAvatarName => {
                "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_AVATAR_NAME"
            }
            Self::ReasonSubtypeInvalidOther => {
                "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_OTHER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPORT_SUBTYPE_REASON_SUBTYPE_NONE" => Some(Self::ReasonSubtypeNone),
            "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_NICKNAME" => {
                Some(Self::ReasonSubtypeInvalidNickname)
            }
            "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_SIGNATURE" => {
                Some(Self::ReasonSubtypeInvalidSignature)
            }
            "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_ARRANGEMENT" => {
                Some(Self::ReasonSubtypeInvalidArrangement)
            }
            "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_CHAT" => {
                Some(Self::ReasonSubtypeInvalidChat)
            }
            "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_AVATAR_NAME" => {
                Some(Self::ReasonSubtypeInvalidAvatarName)
            }
            "REPORT_SUBTYPE_REASON_SUBTYPE_INVALID_OTHER" => {
                Some(Self::ReasonSubtypeInvalidOther)
            }
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MapMarkTipsType {
    DungeonElementTrial = 0,
}
impl MapMarkTipsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DungeonElementTrial => "MAP_MARK_TIPS_TYPE_DUNGEON_ELEMENT_TRIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAP_MARK_TIPS_TYPE_DUNGEON_ELEMENT_TRIAL" => Some(Self::DungeonElementTrial),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExpeditionState {
    None = 0,
    Started = 1,
    Finished = 2,
    Rewarded = 3,
    Locked = 4,
}
impl ExpeditionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "EXPEDITION_STATE_NONE",
            Self::Started => "EXPEDITION_STATE_STARTED",
            Self::Finished => "EXPEDITION_STATE_FINISHED",
            Self::Rewarded => "EXPEDITION_STATE_REWARDED",
            Self::Locked => "EXPEDITION_STATE_LOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXPEDITION_STATE_NONE" => Some(Self::None),
            "EXPEDITION_STATE_STARTED" => Some(Self::Started),
            "EXPEDITION_STATE_FINISHED" => Some(Self::Finished),
            "EXPEDITION_STATE_REWARDED" => Some(Self::Rewarded),
            "EXPEDITION_STATE_LOCKED" => Some(Self::Locked),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FriendEnterHomeOption {
    NeedConfirm = 0,
    Refuse = 1,
    Direct = 2,
}
impl FriendEnterHomeOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NeedConfirm => "FRIEND_ENTER_HOME_OPTION_NEED_CONFIRM",
            Self::Refuse => "FRIEND_ENTER_HOME_OPTION_REFUSE",
            Self::Direct => "FRIEND_ENTER_HOME_OPTION_DIRECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRIEND_ENTER_HOME_OPTION_NEED_CONFIRM" => Some(Self::NeedConfirm),
            "FRIEND_ENTER_HOME_OPTION_REFUSE" => Some(Self::Refuse),
            "FRIEND_ENTER_HOME_OPTION_DIRECT" => Some(Self::Direct),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatChannel {
    Team = 0,
    Friend = 1,
    None = 2,
    Hideandseek = 3,
    HideandseekTeam = 5,
    LanV3Boat = 6,
    All = 10,
    Test = 100,
}
impl ChatChannel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Team => "CHAT_CHANNEL_TEAM",
            Self::Friend => "CHAT_CHANNEL_FRIEND",
            Self::None => "CHAT_CHANNEL_NONE",
            Self::Hideandseek => "CHAT_CHANNEL_HIDEANDSEEK",
            Self::HideandseekTeam => "CHAT_CHANNEL_HIDEANDSEEK_TEAM",
            Self::LanV3Boat => "CHAT_CHANNEL_LAN_V3_BOAT",
            Self::All => "CHAT_CHANNEL_ALL",
            Self::Test => "CHAT_CHANNEL_TEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAT_CHANNEL_TEAM" => Some(Self::Team),
            "CHAT_CHANNEL_FRIEND" => Some(Self::Friend),
            "CHAT_CHANNEL_NONE" => Some(Self::None),
            "CHAT_CHANNEL_HIDEANDSEEK" => Some(Self::Hideandseek),
            "CHAT_CHANNEL_HIDEANDSEEK_TEAM" => Some(Self::HideandseekTeam),
            "CHAT_CHANNEL_LAN_V3_BOAT" => Some(Self::LanV3Boat),
            "CHAT_CHANNEL_ALL" => Some(Self::All),
            "CHAT_CHANNEL_TEST" => Some(Self::Test),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DungeonCandidateTeamPlayerState {
    Idle = 0,
    ChangingAvatar = 1,
    Ready = 2,
}
impl DungeonCandidateTeamPlayerState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Idle => "DUNGEON_CANDIDATE_TEAM_PLAYER_STATE_IDLE",
            Self::ChangingAvatar => "DUNGEON_CANDIDATE_TEAM_PLAYER_STATE_CHANGING_AVATAR",
            Self::Ready => "DUNGEON_CANDIDATE_TEAM_PLAYER_STATE_READY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUNGEON_CANDIDATE_TEAM_PLAYER_STATE_IDLE" => Some(Self::Idle),
            "DUNGEON_CANDIDATE_TEAM_PLAYER_STATE_CHANGING_AVATAR" => {
                Some(Self::ChangingAvatar)
            }
            "DUNGEON_CANDIDATE_TEAM_PLAYER_STATE_READY" => Some(Self::Ready),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LunaRiteHintStatusType {
    Default = 0,
    NoCount = 1,
    Finish = 2,
}
impl LunaRiteHintStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "LUNA_RITE_HINT_STATUS_TYPE_DEFAULT",
            Self::NoCount => "LUNA_RITE_HINT_STATUS_TYPE_NO_COUNT",
            Self::Finish => "LUNA_RITE_HINT_STATUS_TYPE_FINISH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LUNA_RITE_HINT_STATUS_TYPE_DEFAULT" => Some(Self::Default),
            "LUNA_RITE_HINT_STATUS_TYPE_NO_COUNT" => Some(Self::NoCount),
            "LUNA_RITE_HINT_STATUS_TYPE_FINISH" => Some(Self::Finish),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LunaRiteHintPointType {
    None = 0,
    Rune = 1,
    Chest = 2,
}
impl LunaRiteHintPointType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "LUNA_RITE_HINT_POINT_TYPE_NONE",
            Self::Rune => "LUNA_RITE_HINT_POINT_TYPE_RUNE",
            Self::Chest => "LUNA_RITE_HINT_POINT_TYPE_CHEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LUNA_RITE_HINT_POINT_TYPE_NONE" => Some(Self::None),
            "LUNA_RITE_HINT_POINT_TYPE_RUNE" => Some(Self::Rune),
            "LUNA_RITE_HINT_POINT_TYPE_CHEST" => Some(Self::Chest),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClientInputType {
    None = 0,
    KeyboardMouse = 1,
    Gamepad = 2,
    TouchPanel = 3,
}
impl ClientInputType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CLIENT_INPUT_TYPE_NONE",
            Self::KeyboardMouse => "CLIENT_INPUT_TYPE_KEYBOARD_MOUSE",
            Self::Gamepad => "CLIENT_INPUT_TYPE_GAMEPAD",
            Self::TouchPanel => "CLIENT_INPUT_TYPE_TOUCH_PANEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLIENT_INPUT_TYPE_NONE" => Some(Self::None),
            "CLIENT_INPUT_TYPE_KEYBOARD_MOUSE" => Some(Self::KeyboardMouse),
            "CLIENT_INPUT_TYPE_GAMEPAD" => Some(Self::Gamepad),
            "CLIENT_INPUT_TYPE_TOUCH_PANEL" => Some(Self::TouchPanel),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AranaraCollectionState {
    None = 0,
    Collectable = 1,
    Collected = 2,
    Finished = 3,
}
impl AranaraCollectionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ARANARA_COLLECTION_STATE_NONE",
            Self::Collectable => "ARANARA_COLLECTION_STATE_COLLECTABLE",
            Self::Collected => "ARANARA_COLLECTION_STATE_COLLECTED",
            Self::Finished => "ARANARA_COLLECTION_STATE_FINISHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ARANARA_COLLECTION_STATE_NONE" => Some(Self::None),
            "ARANARA_COLLECTION_STATE_COLLECTABLE" => Some(Self::Collectable),
            "ARANARA_COLLECTION_STATE_COLLECTED" => Some(Self::Collected),
            "ARANARA_COLLECTION_STATE_FINISHED" => Some(Self::Finished),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuditState {
    None = 0,
    Waiting = 1,
    Failed = 2,
}
impl AuditState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AUDIT_STATE_NONE",
            Self::Waiting => "AUDIT_STATE_WAITING",
            Self::Failed => "AUDIT_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDIT_STATE_NONE" => Some(Self::None),
            "AUDIT_STATE_WAITING" => Some(Self::Waiting),
            "AUDIT_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupLinkShowAreaState {
    None = 0,
    Transculent = 1,
}
impl GroupLinkShowAreaState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GROUP_LINK_SHOW_AREA_STATE_NONE",
            Self::Transculent => "GROUP_LINK_SHOW_AREA_STATE_TRANSCULENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GROUP_LINK_SHOW_AREA_STATE_NONE" => Some(Self::None),
            "GROUP_LINK_SHOW_AREA_STATE_TRANSCULENT" => Some(Self::Transculent),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UgcDungeonCandidateAvatarType {
    None = 0,
    Formal = 1,
    Ugc = 2,
}
impl UgcDungeonCandidateAvatarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UGC_DUNGEON_CANDIDATE_AVATAR_TYPE_NONE",
            Self::Formal => "UGC_DUNGEON_CANDIDATE_AVATAR_TYPE_FORMAL",
            Self::Ugc => "UGC_DUNGEON_CANDIDATE_AVATAR_TYPE_UGC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC_DUNGEON_CANDIDATE_AVATAR_TYPE_NONE" => Some(Self::None),
            "UGC_DUNGEON_CANDIDATE_AVATAR_TYPE_FORMAL" => Some(Self::Formal),
            "UGC_DUNGEON_CANDIDATE_AVATAR_TYPE_UGC" => Some(Self::Ugc),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GetUgcDungeonBriefType {
    None = 0,
    StarredDungeon = 1,
    StarredRoom = 2,
    Owner = 3,
    History = 4,
    Search = 5,
    Official = 6,
    Template = 7,
}
impl GetUgcDungeonBriefType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "GET_UGC_DUNGEON_BRIEF_TYPE_NONE",
            Self::StarredDungeon => "GET_UGC_DUNGEON_BRIEF_TYPE_STARRED_DUNGEON",
            Self::StarredRoom => "GET_UGC_DUNGEON_BRIEF_TYPE_STARRED_ROOM",
            Self::Owner => "GET_UGC_DUNGEON_BRIEF_TYPE_OWNER",
            Self::History => "GET_UGC_DUNGEON_BRIEF_TYPE_HISTORY",
            Self::Search => "GET_UGC_DUNGEON_BRIEF_TYPE_SEARCH",
            Self::Official => "GET_UGC_DUNGEON_BRIEF_TYPE_OFFICIAL",
            Self::Template => "GET_UGC_DUNGEON_BRIEF_TYPE_TEMPLATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GET_UGC_DUNGEON_BRIEF_TYPE_NONE" => Some(Self::None),
            "GET_UGC_DUNGEON_BRIEF_TYPE_STARRED_DUNGEON" => Some(Self::StarredDungeon),
            "GET_UGC_DUNGEON_BRIEF_TYPE_STARRED_ROOM" => Some(Self::StarredRoom),
            "GET_UGC_DUNGEON_BRIEF_TYPE_OWNER" => Some(Self::Owner),
            "GET_UGC_DUNGEON_BRIEF_TYPE_HISTORY" => Some(Self::History),
            "GET_UGC_DUNGEON_BRIEF_TYPE_SEARCH" => Some(Self::Search),
            "GET_UGC_DUNGEON_BRIEF_TYPE_OFFICIAL" => Some(Self::Official),
            "GET_UGC_DUNGEON_BRIEF_TYPE_TEMPLATE" => Some(Self::Template),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UgcDungeonImportOpType {
    None = 0,
    Dungeon = 1,
    Room = 2,
}
impl UgcDungeonImportOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UGC_DUNGEON_IMPORT_OP_TYPE_NONE",
            Self::Dungeon => "UGC_DUNGEON_IMPORT_OP_TYPE_DUNGEON",
            Self::Room => "UGC_DUNGEON_IMPORT_OP_TYPE_ROOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC_DUNGEON_IMPORT_OP_TYPE_NONE" => Some(Self::None),
            "UGC_DUNGEON_IMPORT_OP_TYPE_DUNGEON" => Some(Self::Dungeon),
            "UGC_DUNGEON_IMPORT_OP_TYPE_ROOM" => Some(Self::Room),
            _ => None,
        }
    }
}
#[derive(sakura_proto_derive::CmdID)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BreakoutActionType {
    None = 0,
    LaunchBall = 1,
    DestroyBall = 2,
    FallingObject = 3,
    Missile = 4,
}
impl BreakoutActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "BREAKOUT_ACTION_TYPE_NONE",
            Self::LaunchBall => "BREAKOUT_ACTION_TYPE_LAUNCH_BALL",
            Self::DestroyBall => "BREAKOUT_ACTION_TYPE_DESTROY_BALL",
            Self::FallingObject => "BREAKOUT_ACTION_TYPE_FALLING_OBJECT",
            Self::Missile => "BREAKOUT_ACTION_TYPE_MISSILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BREAKOUT_ACTION_TYPE_NONE" => Some(Self::None),
            "BREAKOUT_ACTION_TYPE_LAUNCH_BALL" => Some(Self::LaunchBall),
            "BREAKOUT_ACTION_TYPE_DESTROY_BALL" => Some(Self::DestroyBall),
            "BREAKOUT_ACTION_TYPE_FALLING_OBJECT" => Some(Self::FallingObject),
            "BREAKOUT_ACTION_TYPE_MISSILE" => Some(Self::Missile),
            _ => None,
        }
    }
}